{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-next-master/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"22f078646eb223d92f744fcb8963c576805b4e2d","modified":1515935168702},{"_id":"themes/hexo-theme-next-master/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/README.md","hash":"3d438555ca87b1d247536b3b56fc0672eb001518","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/bower.json","hash":"74115626b419f40126e07bb0bbfc5e6ab163f222","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/_config.yml","hash":"d00c02b2615bfbb872fa3723b6a309aa8f82c8c7","modified":1516432683022},{"_id":"themes/hexo-theme-next-master/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/package.json","hash":"edcba128994bb34491334db3a49d5c3a50976cf3","modified":1515552024000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1515935352842},{"_id":"source/_posts/2018前端面试题总结.md","hash":"c2a27f8fdf4f91c6bbe5cc29941f477ee1abc6f3","modified":1515737337939},{"_id":"source/_posts/NodeJS-学习之路.md","hash":"9dd181f0508c420911cb52d19764c227a1f332d9","modified":1515814954156},{"_id":"source/_posts/React元素和组件.md","hash":"3abc018acb00447bf6b98901417bbb9bcb662389","modified":1517361555434},{"_id":"source/_posts/关于puppeteer.md","hash":"4a4a472a5abf789bf0c634a7103d09bf892286e3","modified":1516586613903},{"_id":"source/_posts/关于Array的ES5部分方法的实现.md","hash":"75933e9ec4fe620377ca5be083bf1f41873c55b3","modified":1517403327943},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1515935456064},{"_id":"source/_posts/WebSocket：5分钟从入门到精通.md","hash":"4c98516e6bc6a6388f6ca466170bea8a0e6d83df","modified":1515733585139},{"_id":"themes/hexo-theme-next-master/.github/CONTRIBUTING.md","hash":"792b4e3c3544d51164e8a414219dc1b388dc65dc","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.github/ISSUE_TEMPLATE.md","hash":"054be54a22f3aea601a29334c7577ffa793f1a48","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/.github/stale.yml","hash":"1bbdd20d025010ec57225712be82988a26485836","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/DATA-FILES.md","hash":"de63aa8466ee8c4d4b418dfbe4e8f27fa117751d","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/INSTALLATION.md","hash":"01a383fd1d46752d4b4f22047b535127b44adb75","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/de.yml","hash":"92964c8ed184fa959a5e2001e7c6d9a07d7a4344","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/default.yml","hash":"b39706b2d22696eed6b036f4c90aa5362e331090","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/en.yml","hash":"df63017548589b2e567647e08d736c2a7f342b12","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/fr-FR.yml","hash":"6ee34c8103a95839207dac1201fef7a8f727d2fc","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/id.yml","hash":"60473cc81a871ceb868c97cd3291d602fda1b338","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/it.yml","hash":"5a8a29d145dd2cd882d52b3fbb1203c1a3540cbd","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/ja.yml","hash":"8a3acfb56dc783f261b640dca662c0ec431fea6f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/ko.yml","hash":"73253087d7754a0213e2ad72de16ab5138b9ba54","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/pt-BR.yml","hash":"4d017b7b9542050b87a99931dff98889090fc781","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/pt.yml","hash":"95585897cd108d5ff15e998cd0acdc0fba5d572c","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/ru.yml","hash":"4ba9f4971115bce0213c437158424428e0e13d5a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/zh-Hans.yml","hash":"ce7413e9619d55e794dcab1e914bc7359a3c5568","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/zh-hk.yml","hash":"54e4aa1d04ccad1e13cf08124fe5f70a930592dd","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/languages/zh-tw.yml","hash":"280dd00495e90b8a8c4d9351bab8ae65c78bbe87","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_layout.swig","hash":"d128adc19685ce7d7063c54edde8c769497a52b3","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/post.swig","hash":"8e2d079b46076996cc9343213d5bf7da8178d32d","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/.DS_Store","hash":"e44c79971e2ae6227af48a6ee05d66907da711f8","modified":1516114712006},{"_id":"themes/hexo-theme-next-master/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/cn/DATA-FILES.md","hash":"58c58c7d98365395dba904a87f9b5f5e0b1e99cb","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/cn/INSTALLATION.md","hash":"15b09b7cf4e4159858895e37ce334fcc96ac08d7","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/cn/README.md","hash":"68b98e7489b8d53e8367500507b9ce43d094d48b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/ru/DATA-FILES.md","hash":"1f15b876c106bae74148fb526bc3b914721b8ff2","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/cn/UPDATE-FROM-5.1.X.md","hash":"b6422e0e1bbb02ddd29a2f9969fc3ff709555560","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/ru/README.md","hash":"95a904683da99daf1473fb7c1ffe8a6322ef8fb9","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/ru/INSTALLATION.md","hash":"43a70e456d15e9eab3753c22a5253ed2ff300ac8","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_macro/post.swig","hash":"443aa293a1735488e838cd5896e549e35b6832aa","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_macro/reward.swig","hash":"aa620c582143f43ba1cb1a5e59240041a911185b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_macro/sidebar.swig","hash":"43f13d75cfb37ec4ed5386bee0f737641977200b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_macro/wechat-subscriber.swig","hash":"fea45ab314b9ea23edab25c2b8620f909d856b1d","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/comments.swig","hash":"f71a2f726bcebebae78fb9a46a511fe38ebd8acf","modified":1516432484526},{"_id":"themes/hexo-theme-next-master/layout/_partials/footer.swig的副本","hash":"73835db2ea30a9824f1d90351f975f6011f42d27","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/footer.swig","hash":"040e92fc09619b757beeb0e858773c7eba25734c","modified":1515742568866},{"_id":"themes/hexo-theme-next-master/layout/_partials/head.swig","hash":"1384aaabd325eeba28772f825308bad58ab904fe","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/header.swig","hash":"203fabaf17acfafbaf1a97d0015a6613ec71d2b0","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_scripts/commons.swig","hash":"5b16304b556011b0ea1987bda9dfd06da2ac731b","modified":1516432941455},{"_id":"themes/hexo-theme-next-master/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/avatar.jpeg","hash":"2e5fbca62ef07983db66732e6ed061dcfa60c4b7","modified":1515685643249},{"_id":"themes/hexo-theme-next-master/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/disqus.swig","hash":"683955d9dc806c3309c2c6b137c4fb19f089763e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/hypercomments.swig","hash":"17a54796f6e03fc834880a58efca45c286e40e40","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/index.swig","hash":"40e3cacbd5fa5f2948d0179eff6dd88053e8648e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/livere.swig","hash":"6f340d122a9816ccdf4b45b662880a4b2d087671","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/youyan.swig","hash":"d73409b453ec39c2bb6c50b197b03d7edff49726","modified":1516431879517},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/bootstrap.js","hash":"531cdedd7fbe8cb1dab2e4328774a9f6b15b59da","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_menu.styl","hash":"bb20cbd5df6433af2746a0a59aca0415c77bc17e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_menu.styl","hash":"3bc53d98f7ab29b48f0d7a6212c6488c5458ed88","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_menu.styl","hash":"d204ef41e5f59aa102baf02e1751075a041ae7f4","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-meta.styl","hash":"0abb074afb6ab7242a22fa6dc3ac688251df708a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post.styl","hash":"8bf095377d28881f63a30bd7db97526829103bf2","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/third-party.styl","hash":"96326454eb7c7a3ec38d20294c94c4cc63f16ebe","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1515552024000},{"_id":"themes/hexo-theme-next-master/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1515552024000},{"_id":"public/2018/01/13/关于Array的ES5部分方法的实现/index.html","hash":"3f2f1a517425541fa59f969a2a3f8f2dff3dfd41","modified":1517403334009},{"_id":"public/2018/01/13/NodeJS-学习之路/index.html","hash":"82cf47596a78119c5d365b8e814f3b0a05f94b5e","modified":1517361561728},{"_id":"public/archives/index.html","hash":"6d85ceff7ae5ec4e8387d834781ffdae53504a84","modified":1517361561728},{"_id":"public/archives/2018/index.html","hash":"6d85ceff7ae5ec4e8387d834781ffdae53504a84","modified":1517361561728},{"_id":"public/archives/2018/01/index.html","hash":"6d85ceff7ae5ec4e8387d834781ffdae53504a84","modified":1517361561728},{"_id":"public/categories/Node/index.html","hash":"00b43d1ed65e649c68c1562a096f845234da564c","modified":1517361561728},{"_id":"public/tags/puppeteer/index.html","hash":"63cbbd3960300e3ac27a72bff2506fee0723b350","modified":1517361561728},{"_id":"public/2018/01/20/关于puppeteer/index.html","hash":"04fbfa56494b411e197751d76d8f712e9813e92b","modified":1517361561729},{"_id":"public/2018/01/12/2018前端面试题总结/index.html","hash":"2560ee986f437b4c3e7f52a00dfa666a2635762e","modified":1517361561729},{"_id":"public/2018/01/12/WebSocket：5分钟从入门到精通/index.html","hash":"5b4ff61c14a9e3d5e122f4a93cc7a9b431be8e9c","modified":1517361561729},{"_id":"public/index.html","hash":"5d1e43d5bf609a646ef5965e63ee61bea62fd598","modified":1517403296705},{"_id":"public/2018/01/31/React元素和组件/index.html","hash":"3058d4bdbfd5b10eb176ecc6ce5585ea8f2343a0","modified":1517361561728},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1517360698521},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1517360698521},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1517360698521},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1517360698521},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1517360698521},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1517360698521},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1517360698522},{"_id":"public/images/avatar.jpeg","hash":"2e5fbca62ef07983db66732e6ed061dcfa60c4b7","modified":1517360698522},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1517360698522},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1517360698522},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1517360698522},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1517360698522},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1517360698522},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1517360698522},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1517360698522},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1517360698522},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1517360698522},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1517360698522},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1517360698522},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1517360698522},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1517360698522},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1517360699071},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1517360699074},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1517360699110},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1517360699110},{"_id":"public/js/src/bootstrap.js","hash":"531cdedd7fbe8cb1dab2e4328774a9f6b15b59da","modified":1517360699111},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1517360699111},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1517360699111},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1517360699111},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1517360699111},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1517360699111},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1517360699111},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1517360699111},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1517360699111},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1517360699111},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1517360699111},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1517360699111},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1517360699112},{"_id":"public/css/main.css","hash":"07911e8a23a09f550e19cb980dbd274fee816a04","modified":1517360699112},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1517360699112},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1517360699112},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1517360699112},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1517360699112},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1517360699112},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1517360699112},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1517360699112},{"_id":"public/tags/React/index.html","hash":"6584ba786cc0ebe4b33e2bf46ac69516ea868d5e","modified":1517361561728},{"_id":"public/categories/React/index.html","hash":"0994b03db599b221a0bee9e309794d6f7238c63a","modified":1517361561728},{"_id":"source/img/React.jpeg","hash":"2b258b81cbff5d51ad5f3921f07f7bfca0c77d4f","modified":1517361171167},{"_id":"public/img/React.jpeg","hash":"2b258b81cbff5d51ad5f3921f07f7bfca0c77d4f","modified":1517361263402}],"Category":[{"name":"Node","_id":"cjd2ddrdc0005uqzz2qe70in6"},{"name":"React","_id":"cjd2djcf600009rzzcmtrypdn"}],"Data":[],"Page":[],"Post":[{"title":"2018前端面试题总结","date":"2018-01-12T11:48:25.000Z","_content":"![title](http://onh0umlhz.bkt.clouddn.com/0524themetitle.PNG)\n\n## 计算机网络\n\n### 一、HTTP协议头含有哪些重要的部分，HTTP状态码\n\n#### Request Headers (请求头)\n\nAccept : 浏览器可以接受的媒体类型\n\nAccept-Encoding :  浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）\n\nAccept-Language : 浏览器申明自己接收的语言。 \n\nUser-Agent : 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.\n\nAccept-Charset : 浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）\n\nConnection :\n\n1. Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接\n2. Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。\n\nCookie: :  最重要的header, 将cookie的值发送给HTTP 服务器\n\nHost : 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的\n\nReferer : 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。\n\n### Response Header (响应头)\n\n#### Cache : \n\nDate : 生成消息的具体时间和日期\n\nExpires : 浏览器会在指定过期时间内使用本地缓存\n\nContent-Encoding : WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。\n\nContent-Length : 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。\n\nContent-Type : WEB服务器告诉浏览器自己响应的对象的类型和字符集,\n\n### HTTP状态码\n\n#### 常见\n\n- 200 - 请求成功\n- 301 - 资源（网页等）被永久转移到其它URL\n- 404 - 请求的资源（网页等）不存在\n- 500 - 内部服务器错误\n\n1XX : 信息，服务器收到请求，需要请求者继续执行操作\n\n2XX : 成功，操作被成功接收并处理\n\n3XX : 重定向，需要进一步的操作以完成请求\n\n4XX : 客户端错误，请求包含语法错误或无法完成请求\n\n5XX : 服务器错误，服务器在处理请求的过程中发生了错误\n\n","source":"_posts/2018前端面试题总结.md","raw":"---\ntitle: 2018前端面试题总结\ndate: 2018-01-12 19:48:25\ntags:\n---\n![title](http://onh0umlhz.bkt.clouddn.com/0524themetitle.PNG)\n\n## 计算机网络\n\n### 一、HTTP协议头含有哪些重要的部分，HTTP状态码\n\n#### Request Headers (请求头)\n\nAccept : 浏览器可以接受的媒体类型\n\nAccept-Encoding :  浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）\n\nAccept-Language : 浏览器申明自己接收的语言。 \n\nUser-Agent : 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.\n\nAccept-Charset : 浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）\n\nConnection :\n\n1. Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接\n2. Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。\n\nCookie: :  最重要的header, 将cookie的值发送给HTTP 服务器\n\nHost : 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的\n\nReferer : 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。\n\n### Response Header (响应头)\n\n#### Cache : \n\nDate : 生成消息的具体时间和日期\n\nExpires : 浏览器会在指定过期时间内使用本地缓存\n\nContent-Encoding : WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。\n\nContent-Length : 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。\n\nContent-Type : WEB服务器告诉浏览器自己响应的对象的类型和字符集,\n\n### HTTP状态码\n\n#### 常见\n\n- 200 - 请求成功\n- 301 - 资源（网页等）被永久转移到其它URL\n- 404 - 请求的资源（网页等）不存在\n- 500 - 内部服务器错误\n\n1XX : 信息，服务器收到请求，需要请求者继续执行操作\n\n2XX : 成功，操作被成功接收并处理\n\n3XX : 重定向，需要进一步的操作以完成请求\n\n4XX : 客户端错误，请求包含语法错误或无法完成请求\n\n5XX : 服务器错误，服务器在处理请求的过程中发生了错误\n\n","slug":"2018前端面试题总结","published":1,"updated":"2018-01-12T06:08:57.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd2ddrcs0000uqzzigjt1804","content":"<p><img src=\"http://onh0umlhz.bkt.clouddn.com/0524themetitle.PNG\" alt=\"title\"></p>\n<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><h3 id=\"一、HTTP协议头含有哪些重要的部分，HTTP状态码\"><a href=\"#一、HTTP协议头含有哪些重要的部分，HTTP状态码\" class=\"headerlink\" title=\"一、HTTP协议头含有哪些重要的部分，HTTP状态码\"></a>一、HTTP协议头含有哪些重要的部分，HTTP状态码</h3><h4 id=\"Request-Headers-请求头\"><a href=\"#Request-Headers-请求头\" class=\"headerlink\" title=\"Request Headers (请求头)\"></a>Request Headers (请求头)</h4><p>Accept : 浏览器可以接受的媒体类型</p>\n<p>Accept-Encoding :  浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）</p>\n<p>Accept-Language : 浏览器申明自己接收的语言。 </p>\n<p>User-Agent : 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>\n<p>Accept-Charset : 浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）</p>\n<p>Connection :</p>\n<ol>\n<li>Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</li>\n<li>Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li>\n</ol>\n<p>Cookie: :  最重要的header, 将cookie的值发送给HTTP 服务器</p>\n<p>Host : 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p>\n<p>Referer : 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>\n<h3 id=\"Response-Header-响应头\"><a href=\"#Response-Header-响应头\" class=\"headerlink\" title=\"Response Header (响应头)\"></a>Response Header (响应头)</h3><h4 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache :\"></a>Cache :</h4><p>Date : 生成消息的具体时间和日期</p>\n<p>Expires : 浏览器会在指定过期时间内使用本地缓存</p>\n<p>Content-Encoding : WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p>\n<p>Content-Length : 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>\n<p>Content-Type : WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><h4 id=\"常见\"><a href=\"#常见\" class=\"headerlink\" title=\"常见\"></a>常见</h4><ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n<p>1XX : 信息，服务器收到请求，需要请求者继续执行操作</p>\n<p>2XX : 成功，操作被成功接收并处理</p>\n<p>3XX : 重定向，需要进一步的操作以完成请求</p>\n<p>4XX : 客户端错误，请求包含语法错误或无法完成请求</p>\n<p>5XX : 服务器错误，服务器在处理请求的过程中发生了错误</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://onh0umlhz.bkt.clouddn.com/0524themetitle.PNG\" alt=\"title\"></p>\n<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><h3 id=\"一、HTTP协议头含有哪些重要的部分，HTTP状态码\"><a href=\"#一、HTTP协议头含有哪些重要的部分，HTTP状态码\" class=\"headerlink\" title=\"一、HTTP协议头含有哪些重要的部分，HTTP状态码\"></a>一、HTTP协议头含有哪些重要的部分，HTTP状态码</h3><h4 id=\"Request-Headers-请求头\"><a href=\"#Request-Headers-请求头\" class=\"headerlink\" title=\"Request Headers (请求头)\"></a>Request Headers (请求头)</h4><p>Accept : 浏览器可以接受的媒体类型</p>\n<p>Accept-Encoding :  浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）</p>\n<p>Accept-Language : 浏览器申明自己接收的语言。 </p>\n<p>User-Agent : 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>\n<p>Accept-Charset : 浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）</p>\n<p>Connection :</p>\n<ol>\n<li>Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</li>\n<li>Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li>\n</ol>\n<p>Cookie: :  最重要的header, 将cookie的值发送给HTTP 服务器</p>\n<p>Host : 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p>\n<p>Referer : 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>\n<h3 id=\"Response-Header-响应头\"><a href=\"#Response-Header-响应头\" class=\"headerlink\" title=\"Response Header (响应头)\"></a>Response Header (响应头)</h3><h4 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache :\"></a>Cache :</h4><p>Date : 生成消息的具体时间和日期</p>\n<p>Expires : 浏览器会在指定过期时间内使用本地缓存</p>\n<p>Content-Encoding : WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p>\n<p>Content-Length : 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>\n<p>Content-Type : WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><h4 id=\"常见\"><a href=\"#常见\" class=\"headerlink\" title=\"常见\"></a>常见</h4><ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n<p>1XX : 信息，服务器收到请求，需要请求者继续执行操作</p>\n<p>2XX : 成功，操作被成功接收并处理</p>\n<p>3XX : 重定向，需要进一步的操作以完成请求</p>\n<p>4XX : 客户端错误，请求包含语法错误或无法完成请求</p>\n<p>5XX : 服务器错误，服务器在处理请求的过程中发生了错误</p>\n"},{"title":"NodeJS 学习之路","date":"2018-01-13T03:42:34.000Z","_content":"","source":"_posts/NodeJS-学习之路.md","raw":"---\ntitle: NodeJS 学习之路\ndate: 2018-01-13 11:42:34\ntags:\n---\n","slug":"NodeJS-学习之路","published":1,"updated":"2018-01-13T03:42:34.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd2ddrd20001uqzz4c7ox2zl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"React元素和组件","date":"2018-01-31T01:03:54.000Z","_content":"![](http://p2oiag4fy.bkt.clouddn.com/React.jpeg)\n# 一 、属性和状态\n\n### (一)什么是属性？\n\nprops=properties \n\n#### 1、属性的含义和用法\n\n含义 ：一个事物的性质与关系，属性往往是与生俱来的、无法自己改变的。\n\n3种用法 ：\n\n(1)键值对\n\n传入一个字符串：\n\n```js\n'Hello,World!' 或 {'Hello,World!'}\n```\n\n传入一个数组：\n\n```js\n{[Array1,Array2,Array3]}\n```\n\n传入一个变量：\n\n```js\n{variable}\n```\n\n(2)展开对象形式\n\n```js\nvar props = {\n\tone:\"123\",\n\ttwo:321\n\t}\n<HelloWorld {...props}/>\n```\n\nReact提供展开语法…,使用…加对象,react就会把对象中的属性和值，当成是属性的赋值。\n\n(3)setProps形式：\n\n通过组件更新属性，不能在组件内部中修改属性的，因为会违背组件设计原则（尽量避免）\n\n```js\n<script type=\"text/babel\">\n    var HelloWorld = React.createClass({\n        render: function(){\n            return <p>Hello, {this.props.name}</p>\n        }\n    });\n    var instance = ReactDOM.render(<HelloWorld></HelloWorld>, document.querySelector(\"#example\"));\n    instance.setProps({name: \"William\"});\n</script>\n```\n\nsetProps接收的参数是一个对象，但是react不推荐改变组件的属性,可以通过父组件向子组件传入的方式。\n\n### (二)什么是状态？\n\nstate\n\n#### 1、状态的含义和用法\n\n含义 ：事物所处的状况。状态是由事物自行处理、不断变化的，是事物的私有属性。 \n\n用法：\n\ngetInitialState:初始化每个实例特有的状态 \nsetState:更新组件状态 \n使用setState——启用diff算法——有变化，更新DOM\n\n```js\n\t//使用状态 state，实现时钟\n    class Time extends React.Component{\n        //构造器函数（初始化函数）：初始化\n        constructor(props) {\n            super(props);\n            //初始化状态\n            this.state={\n                date:new Date()\n            }\n            //修改状态:每隔一秒，修改状态\n            setInterval(()=>{\n                console.log('定时器执行');\n                this.setState({\n                    date:new Date()\n                })\n            },1000);\n        }\n        render(){\n            console.log('时间',this.state.date);\n            return(\n                //使用\n                <p>当前时间:  {this.state.date.toLocaleTimeString()}</p>\n            );\n        }\n    }\n    ReactDOM.render(\n        <Time />,\n        document.getElementById('root')\n        );\n```\n\n### (三)属性和状态对比 \n\n属性和状态作为组件之间数据流动的途径，非常容易混用，下面对属性和状态进行对比，介绍两者的相同点、不同点以及使用方法。\n\n#### 1、相同点\n\n- 都是纯JS对象\n- 都会触发render更新\n- 都具有确定性\n\n#### 2、对比\n\n| -            | 属性( props) | 状态(state) |\n| ------------ | :--------: | :-------: |\n| 能否从父组件获取初始值  |     √      |     ×     |\n| 能否由父组件修改     |     √      |     ×     |\n| 能否在组件内部设置默认值 |     √      |     √     |\n| 能否在组件内部修改    |     ×      |     √     |\n| 能否设置子组件的初始值  |     √      |     ×     |\n| 能否修改子组件的值    |     √      |     ×     |\n\n状态只和组件本身相关，组件不能修改属性\n\n#### 3、区分\n\n- 状态和属性都会触发render更新，都是纯JS对象\n\n- 状态：是和自己相关的，既不受父组件也不受子组件影响\n\n- 属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性。\n\n  根本的区别：组件在运行时需要去修改维护的就是状态\n\n  ​\n\n# 二、元素和组件\n\n### (一)、什么是元素？ \n\n元素用来描述你在屏幕上看到的内容\n\n与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。\n\nReact 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素:\n\n```js\nconst element = <div className=\"element\">I'm element</div>\n```\n\nReact 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的：\n\n```json\n{\n    _context: Object,\n    _owner: null,\n    key: null,\n    props: {\n    className: 'element'，\n    children: 'I'm element'\n  },\n    ref: null,\n    type: \"div\"\n}\n```\n\n只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口`ref`和`getDOMNode()`。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。\n\n除了使用 JSX 语法，我们还可以使用 `React.createElement()` 和 `React.cloneElement()` 来构建 React 元素。\n\n#### 1、React.createElement() 创建元素\n\nJSX 语法就是用`React.createElement()`来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如`div`、`span`，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。\n\n```js\nReact.createElement(\n    type,\n    [props],\n    [...children]\n)\n```\n\n该方法创建并返回一个`ReactElement`对象，其参数如下：\n\n- `type`，可以是一个`HTML标签`或是一个`React组件`（`ReactClass`）\n- `props`，可选参数，表示对象的属性\n- `children`，第三个参数及其后的参数都会被认为是元素的子元素\n- 返回值：`ReactElement`对象\n\n示例，创建一个如下结构的组件：\n\n```html\n<div className=\"myClass\">\n  <h2>itbilu.com</h2><hr/>\n</div>\n\n```\n\n使用`createElement()`方法操作如下：\n\n```js\nReactDOM.render(\n  React.createElement('div', {className:'myClass'},  \n    React.createElement('h2', null, 'itbilu.com'),\n    React.createElement('hr')\n  ),\n  document.getElementById('example')\n);\n\n// itbilu.com\n```\n\n\n\n#### 2、React.cloneElement() 元素克隆\n\n`React.cloneElement()`与`React.createElement()`相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。\n\n```js\nReact.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n```\n\n该方法会从已有的`ReactElement`中复制，并返回一个新的`ReactElement`对象，其参数如下：\n\n- `element`，一个`React元素`（`ReactElement`）\n- `props`，可选参数，表示对象的属性\n- `children`，第三个参数及其后的参数都会被认为是元素的子元素\n- 返回值：`ReactElement`对象\n\n示例，已有如下元素：\n\n```js\nReact.createElement('div');\n```\n\n使用`cloneElement()`复制这个元素，并最终生前面示例中的HTML。复制方法如下:\n\n```js\nvar div = React.createElement('div');\n\nReactDOM.render(\n  React.cloneElement(div, {className:'myClass'},  \n    React.createElement('h2', null, 'itbilu.com'),\n    React.createElement('hr')\n  ),\n  document.getElementById('example')\n);\n```\n\n### (二)、什么是组件？\n\n组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。\n\n组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。\n\n**特点 **：\n\n1. 组件就是函数\n2. 组件编写时，首字母大写\n3. 组件可以嵌套组合使用 ，遵循是W3C的规范\n\n定义一个组件最简单的方式是使用JavaScript函数：\n\n```js\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\n#### 1、函数定义组件(写法一)\n\n```js\nfunction Welcome(props) {\n        return <h1>Welcome,{props.name}</h1>\n    }\n```\n\n#### 2、类定义组件(写法二)\n\n```js\nclass Member extends React.Component{\n        render(){\n            return <h1>Welcome,{this.props.name}</h1>\n        }\n    };\n```\n\n#### 3、组合组件\n\n```js\nfunction Welcome(props) {\n        return <h1>Hello,{props.name}</h1>\n    }\n    function App() {\n        return(\n            // 组件的返回值只能有一个根元素。\n            // 这也是我们要用一个<div>来包裹所有<Welcome />元素的原因。\n            <div>\n                <Welcome name='Sara' />\n                <Welcome name='Cahal' />\n                <Welcome name='Edite' />\n            </div>\n        )\n    }\n    ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n    );\n```\n\n#### 4、提取组件\n\n**意义** :\n\n1. 可重用性\n2. 可读性\n3. 可维护性\n4. 便于调试与测试\n\n```js\n        function Avatar(props) {\n            return(\n                <img\n                    className='Avatar' \n                    src={props.user.avator} \n                    alt={props.user.name} \n                />\n            );\n        }\n        function UserInfo(props) {\n            return(\n                <div className=\"UserInfo\">\n                    <Avatar user={props.user} />\n                    <div className=\"UserInfoName\">\n                        {props.user.name}\n                    </div>\n                </div>\n            );\n        }\n        function Comment(props) { \n            return(\n                <div className=\"Comment\">\n                    <UserInfo user={props.user} /> \n                    <div className=\"CommentText\">\n                        {props.text}\n                    </div>\n                    <div className=\"CommentDate\">\n                        {props.date}\n                    </div>\n                </div>\n            ) \n        } \n        //提取Avatar组件 \n        ReactDOM.render(\n            <h1>Hello,World</h1>, \n            document.getElementById('root') \n        );\n```\n\n### (三)元素和组件的区别\n\n组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。\n\n打个不恰当的比喻，React 组件是`MyComponent`，React 元素就是`<MyComponent />`。\n\n# 三、组件的类型及其区别\n\nReact推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：\n\n1. 函数式定义的`无状态组件`\n2. es5原生方式`React.createClass`定义的组件\n3. es6形式的`extends React.Component`定义的组件\n\n虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。\n\n### (一)无状态函数式组件\n\n创建[无状态函数式组件形式](https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components)是从`React 0.14`版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的`props`来展示，不涉及到要`state`状态的操作。具体的*无状态函数式组件*，其官方指出：\n\n```\n   在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。\n```\n\n无状态函数式组件形式上表现为一个只带有一个`render`方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无`state`状态的。具体的创建形式如下：\n\n```js\nfunction HelloComponent(props, /* context */) {\n  return <div>Hello {props.name}</div>\n}\nReactDOM.render(<HelloComponent name=\"Sebastian\" />, mountNode) \n```\n\n无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：\n\n1. **组件不会被实例化，整体渲染性能得到提升**\n   因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。\n2. **组件不能访问this对象**\n   无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：`this.ref`、`this.state`等均不能访问。若想访问就不能使用这种形式来创建组件\n3. **组件无法访问生命周期的方法**\n   因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。\n4. **无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用**\n\n无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以**只要有可能，尽量使用无状态组件**。\n\n### (二)React.createClass\n\n```\n`React.createClass`是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：\n```\n\n```js\nvar InputControlES5 = React.createClass({\n    propTypes: {//定义传入props中的属性各种类型\n        initialValue: React.PropTypes.string\n    },\n    defaultProps: { //组件默认的props对象\n        initialValue: ''\n    },\n    // 设置 initial state\n    getInitialState: function() {//组件相关的状态对象\n        return {\n            text: this.props.initialValue || 'placeholder'\n        };\n    },\n    handleChange: function(event) {\n        this.setState({ //this represents react component instance\n            text: event.target.value\n        });\n    },\n    render: function() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange} value={this.state.text} />\n            </div>\n        );\n    }\n});\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n与无状态组件相比，`React.createClass`和后面要描述的`React.Component`都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，`React.createClass`形式自身的问题暴露出来：\n\n- React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。\n- React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components--HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考[无状态组件(Stateless Component) 与高阶组件](http://www.jianshu.com/p/63569386befc)。\n\n### (三)React.Component\n\n`React.Component`是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代`React.createClass`形式；相对于 `React.createClass`可以更好实现代码复用。将上面`React.createClass`的形式改为`React.Component`形式如下：\n\n```js\nclass InputControlES6 extends React.Component {\n    constructor(props) {\n        super(props);\n\n        // 设置 initial state\n        this.state = {\n            text: props.initialValue || 'placeholder'\n        };\n\n        // ES6 类中函数必须手动绑定\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(event) {\n        this.setState({\n            text: event.target.value\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange}\n               value={this.state.text} />\n            </div>\n        );\n    }\n}\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n### (四)React.createClass与React.Component区别\n\n根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。\n\n### 1、函数this自绑定\n\n`React.createClass`创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用`this.method`即可，函数中的`this`会被正确设置。\n\n```js\nconst Contacts = React.createClass({  \n  handleClick() {\n    console.log(this); // React Component instance\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n`React.Component`创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。\n\n```js\nclass Contacts extends React.Component {  \n  constructor(props) {\n    super(props);\n  }\n  handleClick() {\n    console.log(this); // null\n  }\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n```\n\n当然，`React.Component`有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用`method.bind(this)`来完成绑定，还可以使用arrow function来绑定。拿上例的`handleClick`函数来说，其绑定可以有：\n\n```js\n    constructor(props) {\n       super(props);\n       this.handleClick = this.handleClick.bind(this); //构造函数中绑定\n  }\n```\n\n```js\n    <div onClick={this.handleClick.bind(this)}></div> //使用bind来绑定\n```\n\n```js\n    <div onClick={()=>this.handleClick()}></div> //使用arrow function来绑定\n```\n\n### 2、组件属性类型propTypes及其默认props属性defaultProps配置不同\n\n`React.createClass`在创建组件时，有关组件props的属性类型及组件默认的属性会作为**组件实例的属性**来配置，其中defaultProps是使用`getDefaultProps`的方法来获取默认组件属性的\n\n```\nconst TodoItem = React.createClass({\n    propTypes: { // as an object\n        name: React.PropTypes.string\n    },\n    getDefaultProps(){   // return a object\n        return {\n            name: ''    \n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\n```\n\n`React.Component`在创建组件时配置这两个对应信息时，他们是作为**组件类的属性**，不是组件实例的属性，也就是所谓的**类的静态属性**来配置的。对应上面配置如下：\n\n```\nclass TodoItem extends React.Component {\n    static propTypes = {//类的静态属性\n        name: React.PropTypes.string\n    };\n\n    static defaultProps = {//类的静态属性\n        name: ''\n    };\n\n    ...\n}\n```\n\n### 3、组件初始状态state的配置不同\n\n`React.createClass`创建的组件，其状态state是通过`getInitialState`方法来配置组件相关的状态；\n`React.Component`创建的组件，其状态state是在`constructor`中像初始化组件属性一样声明的。\n\n```\nconst TodoItem = React.createClass({\n    // return an object\n    getInitialState(){ \n        return {\n            isEditing: false\n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\n```\n\n```\nclass TodoItem extends React.Component{\n    constructor(props){\n        super(props);\n        this.state = { // define this.state in constructor\n            isEditing: false\n        } \n    }\n    render(){\n        return <div></div>\n    }\n}\n```\n\n### 4、Mixins的支持不同\n\n[`Mixins`](https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins)(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过`Mixins`进该对象来达到代码复用。具体可以参考[React Mixin的前世今生](http://www.w3ctech.com/topic/1599)。\n\n`React.createClass`在创建组件时可以使用`mixins`属性，以数组的形式来混合类的集合。\n\n```\nvar SomeMixin = {  \n  doSomething() {\n\n  }\n};\nconst Contacts = React.createClass({  \n  mixins: [SomeMixin],\n  handleClick() {\n    this.doSomething(); // use mixin\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n但是遗憾的是`React.Component`这种形式并不支持`Mixins`，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代`Mixins`,那就是**Higher-Order Components**，具体细节可以参考[这篇文章](https://leozdgao.me/chushi-hoc/)\n\n### (五)如何选择哪种方式创建组件\n\n由于React团队[已经声明](https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html)React.createClass最终会被React.Component的类形式所取代。但是在找到`Mixins`替代方案之前是不会废弃掉`React.createClass`形式。所以：\n\n```\n能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。\n```\n\n除此之外，创建组件的形式选择还应该根据下面来决定：\n\n```\n1、只要有可能，尽量使用无状态组件创建形式。\n\n2、否则（如需要state、生命周期方法等），使用`React.Component`这种es6形式创建组件\n```\n\n**补充一点**\n\n> 无状态组件内部其实是可以使用`ref`功能的，虽然不能通过`this.refs`访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。\n\n例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：\n\n```js\nfunction TestComp(props){\n    let ref;\n    return (<div>\n        <div ref={(node) => ref = node}>\n            ...\n        </div>\n    </div>)\n}\n```\n\n### 参考文献\n\n- [React 组件构造方法: ES5 (createClass) 还是 ES6 (class)？](http://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html)\n- [React.createClass 对比 extends React.Component](http://www.peachis.me/react-createclass-versus-extends-react-component/)\n- [应该如何选择：React.createClass, ES6 Classes, 无状态函数式组件](https://medium.com/@kingzs70/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-react-createclass-es6-classes-%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-52f07dd70e75#.3m2m0t62r)\n- [React中函数式声明组件](https://segmentfault.com/a/1190000006180667)\n- [React Mixin 的前世今生](http://www.w3ctech.com/topic/1599)","source":"_posts/React元素和组件.md","raw":"---\ntitle: React元素和组件\ndate: 2018-01-31 09:03:54\ntags: React\ncategories: React\n---\n![](http://p2oiag4fy.bkt.clouddn.com/React.jpeg)\n# 一 、属性和状态\n\n### (一)什么是属性？\n\nprops=properties \n\n#### 1、属性的含义和用法\n\n含义 ：一个事物的性质与关系，属性往往是与生俱来的、无法自己改变的。\n\n3种用法 ：\n\n(1)键值对\n\n传入一个字符串：\n\n```js\n'Hello,World!' 或 {'Hello,World!'}\n```\n\n传入一个数组：\n\n```js\n{[Array1,Array2,Array3]}\n```\n\n传入一个变量：\n\n```js\n{variable}\n```\n\n(2)展开对象形式\n\n```js\nvar props = {\n\tone:\"123\",\n\ttwo:321\n\t}\n<HelloWorld {...props}/>\n```\n\nReact提供展开语法…,使用…加对象,react就会把对象中的属性和值，当成是属性的赋值。\n\n(3)setProps形式：\n\n通过组件更新属性，不能在组件内部中修改属性的，因为会违背组件设计原则（尽量避免）\n\n```js\n<script type=\"text/babel\">\n    var HelloWorld = React.createClass({\n        render: function(){\n            return <p>Hello, {this.props.name}</p>\n        }\n    });\n    var instance = ReactDOM.render(<HelloWorld></HelloWorld>, document.querySelector(\"#example\"));\n    instance.setProps({name: \"William\"});\n</script>\n```\n\nsetProps接收的参数是一个对象，但是react不推荐改变组件的属性,可以通过父组件向子组件传入的方式。\n\n### (二)什么是状态？\n\nstate\n\n#### 1、状态的含义和用法\n\n含义 ：事物所处的状况。状态是由事物自行处理、不断变化的，是事物的私有属性。 \n\n用法：\n\ngetInitialState:初始化每个实例特有的状态 \nsetState:更新组件状态 \n使用setState——启用diff算法——有变化，更新DOM\n\n```js\n\t//使用状态 state，实现时钟\n    class Time extends React.Component{\n        //构造器函数（初始化函数）：初始化\n        constructor(props) {\n            super(props);\n            //初始化状态\n            this.state={\n                date:new Date()\n            }\n            //修改状态:每隔一秒，修改状态\n            setInterval(()=>{\n                console.log('定时器执行');\n                this.setState({\n                    date:new Date()\n                })\n            },1000);\n        }\n        render(){\n            console.log('时间',this.state.date);\n            return(\n                //使用\n                <p>当前时间:  {this.state.date.toLocaleTimeString()}</p>\n            );\n        }\n    }\n    ReactDOM.render(\n        <Time />,\n        document.getElementById('root')\n        );\n```\n\n### (三)属性和状态对比 \n\n属性和状态作为组件之间数据流动的途径，非常容易混用，下面对属性和状态进行对比，介绍两者的相同点、不同点以及使用方法。\n\n#### 1、相同点\n\n- 都是纯JS对象\n- 都会触发render更新\n- 都具有确定性\n\n#### 2、对比\n\n| -            | 属性( props) | 状态(state) |\n| ------------ | :--------: | :-------: |\n| 能否从父组件获取初始值  |     √      |     ×     |\n| 能否由父组件修改     |     √      |     ×     |\n| 能否在组件内部设置默认值 |     √      |     √     |\n| 能否在组件内部修改    |     ×      |     √     |\n| 能否设置子组件的初始值  |     √      |     ×     |\n| 能否修改子组件的值    |     √      |     ×     |\n\n状态只和组件本身相关，组件不能修改属性\n\n#### 3、区分\n\n- 状态和属性都会触发render更新，都是纯JS对象\n\n- 状态：是和自己相关的，既不受父组件也不受子组件影响\n\n- 属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性。\n\n  根本的区别：组件在运行时需要去修改维护的就是状态\n\n  ​\n\n# 二、元素和组件\n\n### (一)、什么是元素？ \n\n元素用来描述你在屏幕上看到的内容\n\n与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。\n\nReact 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素:\n\n```js\nconst element = <div className=\"element\">I'm element</div>\n```\n\nReact 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的：\n\n```json\n{\n    _context: Object,\n    _owner: null,\n    key: null,\n    props: {\n    className: 'element'，\n    children: 'I'm element'\n  },\n    ref: null,\n    type: \"div\"\n}\n```\n\n只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口`ref`和`getDOMNode()`。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。\n\n除了使用 JSX 语法，我们还可以使用 `React.createElement()` 和 `React.cloneElement()` 来构建 React 元素。\n\n#### 1、React.createElement() 创建元素\n\nJSX 语法就是用`React.createElement()`来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如`div`、`span`，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。\n\n```js\nReact.createElement(\n    type,\n    [props],\n    [...children]\n)\n```\n\n该方法创建并返回一个`ReactElement`对象，其参数如下：\n\n- `type`，可以是一个`HTML标签`或是一个`React组件`（`ReactClass`）\n- `props`，可选参数，表示对象的属性\n- `children`，第三个参数及其后的参数都会被认为是元素的子元素\n- 返回值：`ReactElement`对象\n\n示例，创建一个如下结构的组件：\n\n```html\n<div className=\"myClass\">\n  <h2>itbilu.com</h2><hr/>\n</div>\n\n```\n\n使用`createElement()`方法操作如下：\n\n```js\nReactDOM.render(\n  React.createElement('div', {className:'myClass'},  \n    React.createElement('h2', null, 'itbilu.com'),\n    React.createElement('hr')\n  ),\n  document.getElementById('example')\n);\n\n// itbilu.com\n```\n\n\n\n#### 2、React.cloneElement() 元素克隆\n\n`React.cloneElement()`与`React.createElement()`相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。\n\n```js\nReact.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n```\n\n该方法会从已有的`ReactElement`中复制，并返回一个新的`ReactElement`对象，其参数如下：\n\n- `element`，一个`React元素`（`ReactElement`）\n- `props`，可选参数，表示对象的属性\n- `children`，第三个参数及其后的参数都会被认为是元素的子元素\n- 返回值：`ReactElement`对象\n\n示例，已有如下元素：\n\n```js\nReact.createElement('div');\n```\n\n使用`cloneElement()`复制这个元素，并最终生前面示例中的HTML。复制方法如下:\n\n```js\nvar div = React.createElement('div');\n\nReactDOM.render(\n  React.cloneElement(div, {className:'myClass'},  \n    React.createElement('h2', null, 'itbilu.com'),\n    React.createElement('hr')\n  ),\n  document.getElementById('example')\n);\n```\n\n### (二)、什么是组件？\n\n组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。\n\n组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。\n\n**特点 **：\n\n1. 组件就是函数\n2. 组件编写时，首字母大写\n3. 组件可以嵌套组合使用 ，遵循是W3C的规范\n\n定义一个组件最简单的方式是使用JavaScript函数：\n\n```js\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\n#### 1、函数定义组件(写法一)\n\n```js\nfunction Welcome(props) {\n        return <h1>Welcome,{props.name}</h1>\n    }\n```\n\n#### 2、类定义组件(写法二)\n\n```js\nclass Member extends React.Component{\n        render(){\n            return <h1>Welcome,{this.props.name}</h1>\n        }\n    };\n```\n\n#### 3、组合组件\n\n```js\nfunction Welcome(props) {\n        return <h1>Hello,{props.name}</h1>\n    }\n    function App() {\n        return(\n            // 组件的返回值只能有一个根元素。\n            // 这也是我们要用一个<div>来包裹所有<Welcome />元素的原因。\n            <div>\n                <Welcome name='Sara' />\n                <Welcome name='Cahal' />\n                <Welcome name='Edite' />\n            </div>\n        )\n    }\n    ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n    );\n```\n\n#### 4、提取组件\n\n**意义** :\n\n1. 可重用性\n2. 可读性\n3. 可维护性\n4. 便于调试与测试\n\n```js\n        function Avatar(props) {\n            return(\n                <img\n                    className='Avatar' \n                    src={props.user.avator} \n                    alt={props.user.name} \n                />\n            );\n        }\n        function UserInfo(props) {\n            return(\n                <div className=\"UserInfo\">\n                    <Avatar user={props.user} />\n                    <div className=\"UserInfoName\">\n                        {props.user.name}\n                    </div>\n                </div>\n            );\n        }\n        function Comment(props) { \n            return(\n                <div className=\"Comment\">\n                    <UserInfo user={props.user} /> \n                    <div className=\"CommentText\">\n                        {props.text}\n                    </div>\n                    <div className=\"CommentDate\">\n                        {props.date}\n                    </div>\n                </div>\n            ) \n        } \n        //提取Avatar组件 \n        ReactDOM.render(\n            <h1>Hello,World</h1>, \n            document.getElementById('root') \n        );\n```\n\n### (三)元素和组件的区别\n\n组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。\n\n打个不恰当的比喻，React 组件是`MyComponent`，React 元素就是`<MyComponent />`。\n\n# 三、组件的类型及其区别\n\nReact推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：\n\n1. 函数式定义的`无状态组件`\n2. es5原生方式`React.createClass`定义的组件\n3. es6形式的`extends React.Component`定义的组件\n\n虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。\n\n### (一)无状态函数式组件\n\n创建[无状态函数式组件形式](https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components)是从`React 0.14`版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的`props`来展示，不涉及到要`state`状态的操作。具体的*无状态函数式组件*，其官方指出：\n\n```\n   在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。\n```\n\n无状态函数式组件形式上表现为一个只带有一个`render`方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无`state`状态的。具体的创建形式如下：\n\n```js\nfunction HelloComponent(props, /* context */) {\n  return <div>Hello {props.name}</div>\n}\nReactDOM.render(<HelloComponent name=\"Sebastian\" />, mountNode) \n```\n\n无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：\n\n1. **组件不会被实例化，整体渲染性能得到提升**\n   因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。\n2. **组件不能访问this对象**\n   无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：`this.ref`、`this.state`等均不能访问。若想访问就不能使用这种形式来创建组件\n3. **组件无法访问生命周期的方法**\n   因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。\n4. **无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用**\n\n无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以**只要有可能，尽量使用无状态组件**。\n\n### (二)React.createClass\n\n```\n`React.createClass`是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：\n```\n\n```js\nvar InputControlES5 = React.createClass({\n    propTypes: {//定义传入props中的属性各种类型\n        initialValue: React.PropTypes.string\n    },\n    defaultProps: { //组件默认的props对象\n        initialValue: ''\n    },\n    // 设置 initial state\n    getInitialState: function() {//组件相关的状态对象\n        return {\n            text: this.props.initialValue || 'placeholder'\n        };\n    },\n    handleChange: function(event) {\n        this.setState({ //this represents react component instance\n            text: event.target.value\n        });\n    },\n    render: function() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange} value={this.state.text} />\n            </div>\n        );\n    }\n});\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n与无状态组件相比，`React.createClass`和后面要描述的`React.Component`都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，`React.createClass`形式自身的问题暴露出来：\n\n- React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。\n- React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components--HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考[无状态组件(Stateless Component) 与高阶组件](http://www.jianshu.com/p/63569386befc)。\n\n### (三)React.Component\n\n`React.Component`是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代`React.createClass`形式；相对于 `React.createClass`可以更好实现代码复用。将上面`React.createClass`的形式改为`React.Component`形式如下：\n\n```js\nclass InputControlES6 extends React.Component {\n    constructor(props) {\n        super(props);\n\n        // 设置 initial state\n        this.state = {\n            text: props.initialValue || 'placeholder'\n        };\n\n        // ES6 类中函数必须手动绑定\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(event) {\n        this.setState({\n            text: event.target.value\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange}\n               value={this.state.text} />\n            </div>\n        );\n    }\n}\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n### (四)React.createClass与React.Component区别\n\n根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。\n\n### 1、函数this自绑定\n\n`React.createClass`创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用`this.method`即可，函数中的`this`会被正确设置。\n\n```js\nconst Contacts = React.createClass({  \n  handleClick() {\n    console.log(this); // React Component instance\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n`React.Component`创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。\n\n```js\nclass Contacts extends React.Component {  \n  constructor(props) {\n    super(props);\n  }\n  handleClick() {\n    console.log(this); // null\n  }\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n```\n\n当然，`React.Component`有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用`method.bind(this)`来完成绑定，还可以使用arrow function来绑定。拿上例的`handleClick`函数来说，其绑定可以有：\n\n```js\n    constructor(props) {\n       super(props);\n       this.handleClick = this.handleClick.bind(this); //构造函数中绑定\n  }\n```\n\n```js\n    <div onClick={this.handleClick.bind(this)}></div> //使用bind来绑定\n```\n\n```js\n    <div onClick={()=>this.handleClick()}></div> //使用arrow function来绑定\n```\n\n### 2、组件属性类型propTypes及其默认props属性defaultProps配置不同\n\n`React.createClass`在创建组件时，有关组件props的属性类型及组件默认的属性会作为**组件实例的属性**来配置，其中defaultProps是使用`getDefaultProps`的方法来获取默认组件属性的\n\n```\nconst TodoItem = React.createClass({\n    propTypes: { // as an object\n        name: React.PropTypes.string\n    },\n    getDefaultProps(){   // return a object\n        return {\n            name: ''    \n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\n```\n\n`React.Component`在创建组件时配置这两个对应信息时，他们是作为**组件类的属性**，不是组件实例的属性，也就是所谓的**类的静态属性**来配置的。对应上面配置如下：\n\n```\nclass TodoItem extends React.Component {\n    static propTypes = {//类的静态属性\n        name: React.PropTypes.string\n    };\n\n    static defaultProps = {//类的静态属性\n        name: ''\n    };\n\n    ...\n}\n```\n\n### 3、组件初始状态state的配置不同\n\n`React.createClass`创建的组件，其状态state是通过`getInitialState`方法来配置组件相关的状态；\n`React.Component`创建的组件，其状态state是在`constructor`中像初始化组件属性一样声明的。\n\n```\nconst TodoItem = React.createClass({\n    // return an object\n    getInitialState(){ \n        return {\n            isEditing: false\n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\n```\n\n```\nclass TodoItem extends React.Component{\n    constructor(props){\n        super(props);\n        this.state = { // define this.state in constructor\n            isEditing: false\n        } \n    }\n    render(){\n        return <div></div>\n    }\n}\n```\n\n### 4、Mixins的支持不同\n\n[`Mixins`](https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins)(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过`Mixins`进该对象来达到代码复用。具体可以参考[React Mixin的前世今生](http://www.w3ctech.com/topic/1599)。\n\n`React.createClass`在创建组件时可以使用`mixins`属性，以数组的形式来混合类的集合。\n\n```\nvar SomeMixin = {  \n  doSomething() {\n\n  }\n};\nconst Contacts = React.createClass({  \n  mixins: [SomeMixin],\n  handleClick() {\n    this.doSomething(); // use mixin\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n但是遗憾的是`React.Component`这种形式并不支持`Mixins`，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代`Mixins`,那就是**Higher-Order Components**，具体细节可以参考[这篇文章](https://leozdgao.me/chushi-hoc/)\n\n### (五)如何选择哪种方式创建组件\n\n由于React团队[已经声明](https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html)React.createClass最终会被React.Component的类形式所取代。但是在找到`Mixins`替代方案之前是不会废弃掉`React.createClass`形式。所以：\n\n```\n能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。\n```\n\n除此之外，创建组件的形式选择还应该根据下面来决定：\n\n```\n1、只要有可能，尽量使用无状态组件创建形式。\n\n2、否则（如需要state、生命周期方法等），使用`React.Component`这种es6形式创建组件\n```\n\n**补充一点**\n\n> 无状态组件内部其实是可以使用`ref`功能的，虽然不能通过`this.refs`访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。\n\n例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：\n\n```js\nfunction TestComp(props){\n    let ref;\n    return (<div>\n        <div ref={(node) => ref = node}>\n            ...\n        </div>\n    </div>)\n}\n```\n\n### 参考文献\n\n- [React 组件构造方法: ES5 (createClass) 还是 ES6 (class)？](http://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html)\n- [React.createClass 对比 extends React.Component](http://www.peachis.me/react-createclass-versus-extends-react-component/)\n- [应该如何选择：React.createClass, ES6 Classes, 无状态函数式组件](https://medium.com/@kingzs70/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-react-createclass-es6-classes-%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-52f07dd70e75#.3m2m0t62r)\n- [React中函数式声明组件](https://segmentfault.com/a/1190000006180667)\n- [React Mixin 的前世今生](http://www.w3ctech.com/topic/1599)","slug":"React元素和组件","published":1,"updated":"2018-01-31T01:19:15.434Z","_id":"cjd2ddrd50002uqzz33ubccj4","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"http://p2oiag4fy.bkt.clouddn.com/React.jpeg\" alt=\"\"></p>\n<h1 id=\"一-、属性和状态\"><a href=\"#一-、属性和状态\" class=\"headerlink\" title=\"一 、属性和状态\"></a>一 、属性和状态</h1><h3 id=\"一-什么是属性？\"><a href=\"#一-什么是属性？\" class=\"headerlink\" title=\"(一)什么是属性？\"></a>(一)什么是属性？</h3><p>props=properties </p>\n<h4 id=\"1、属性的含义和用法\"><a href=\"#1、属性的含义和用法\" class=\"headerlink\" title=\"1、属性的含义和用法\"></a>1、属性的含义和用法</h4><p>含义 ：一个事物的性质与关系，属性往往是与生俱来的、无法自己改变的。</p>\n<p>3种用法 ：</p>\n<p>(1)键值对</p>\n<p>传入一个字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'Hello,World!'</span> 或 &#123;<span class=\"string\">'Hello,World!'</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>传入一个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;[Array1,Array2,Array3]&#125;</span><br></pre></td></tr></table></figure>\n<p>传入一个变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;variable&#125;</span><br></pre></td></tr></table></figure>\n<p>(2)展开对象形式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> props = &#123;</span><br><span class=\"line\">\tone:<span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">\ttwo:<span class=\"number\">321</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;HelloWorld &#123;...props&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p>React提供展开语法…,使用…加对象,react就会把对象中的属性和值，当成是属性的赋值。</p>\n<p>(3)setProps形式：</p>\n<p>通过组件更新属性，不能在组件内部中修改属性的，因为会违背组件设计原则（尽量避免）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/babel\"</span>&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> HelloWorld = React.createClass(&#123;</span><br><span class=\"line\">        render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &lt;p&gt;Hello, &#123;this.props.name&#125;&lt;/p&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = ReactDOM.render(&lt;HelloWorld&gt;&lt;/HelloWorld&gt;, <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#example\"</span>));</span><br><span class=\"line\">    instance.setProps(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"William\"</span>&#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>setProps接收的参数是一个对象，但是react不推荐改变组件的属性,可以通过父组件向子组件传入的方式。</p>\n<h3 id=\"二-什么是状态？\"><a href=\"#二-什么是状态？\" class=\"headerlink\" title=\"(二)什么是状态？\"></a>(二)什么是状态？</h3><p>state</p>\n<h4 id=\"1、状态的含义和用法\"><a href=\"#1、状态的含义和用法\" class=\"headerlink\" title=\"1、状态的含义和用法\"></a>1、状态的含义和用法</h4><p>含义 ：事物所处的状况。状态是由事物自行处理、不断变化的，是事物的私有属性。 </p>\n<p>用法：</p>\n<p>getInitialState:初始化每个实例特有的状态<br>setState:更新组件状态<br>使用setState——启用diff算法——有变化，更新DOM</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用状态 state，实现时钟</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Time</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//构造器函数（初始化函数）：初始化</span></span><br><span class=\"line\">       <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">           <span class=\"comment\">//初始化状态</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.state=&#123;</span><br><span class=\"line\">               date:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">//修改状态:每隔一秒，修改状态</span></span><br><span class=\"line\">           setInterval(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"string\">'定时器执行'</span>);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                   date:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\">           &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       render()&#123;</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"string\">'时间'</span>,<span class=\"keyword\">this</span>.state.date);</span><br><span class=\"line\">           <span class=\"keyword\">return</span>(</span><br><span class=\"line\">               <span class=\"comment\">//使用</span></span><br><span class=\"line\">               &lt;p&gt;当前时间:  &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">           );</span></span><br><span class=\"line\"><span class=\"regexp\">       &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">   &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">   ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">       &lt;Time /</span>&gt;,</span><br><span class=\"line\">       <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">       );</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-属性和状态对比\"><a href=\"#三-属性和状态对比\" class=\"headerlink\" title=\"(三)属性和状态对比\"></a>(三)属性和状态对比</h3><p>属性和状态作为组件之间数据流动的途径，非常容易混用，下面对属性和状态进行对比，介绍两者的相同点、不同点以及使用方法。</p>\n<h4 id=\"1、相同点\"><a href=\"#1、相同点\" class=\"headerlink\" title=\"1、相同点\"></a>1、相同点</h4><ul>\n<li>都是纯JS对象</li>\n<li>都会触发render更新</li>\n<li>都具有确定性</li>\n</ul>\n<h4 id=\"2、对比\"><a href=\"#2、对比\" class=\"headerlink\" title=\"2、对比\"></a>2、对比</h4><table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">属性( props)</th>\n<th style=\"text-align:center\">状态(state)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>能否从父组件获取初始值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否由父组件修改</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否在组件内部设置默认值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>能否在组件内部修改</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>能否设置子组件的初始值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否修改子组件的值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<p>状态只和组件本身相关，组件不能修改属性</p>\n<h4 id=\"3、区分\"><a href=\"#3、区分\" class=\"headerlink\" title=\"3、区分\"></a>3、区分</h4><ul>\n<li><p>状态和属性都会触发render更新，都是纯JS对象</p>\n</li>\n<li><p>状态：是和自己相关的，既不受父组件也不受子组件影响</p>\n</li>\n<li><p>属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性。</p>\n<p>根本的区别：组件在运行时需要去修改维护的就是状态</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"二、元素和组件\"><a href=\"#二、元素和组件\" class=\"headerlink\" title=\"二、元素和组件\"></a>二、元素和组件</h1><h3 id=\"一-、什么是元素？\"><a href=\"#一-、什么是元素？\" class=\"headerlink\" title=\"(一)、什么是元素？\"></a>(一)、什么是元素？</h3><p>元素用来描述你在屏幕上看到的内容</p>\n<p>与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。</p>\n<p>React 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &lt;div className=\"element\"&gt;I'm element&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    _context: Object,</span><br><span class=\"line\">    _owner: null,</span><br><span class=\"line\">    key: null,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">    className: 'element'，</span><br><span class=\"line\">    children: 'I'm element'</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    ref: null,</span><br><span class=\"line\">    type: \"div\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口<code>ref</code>和<code>getDOMNode()</code>。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。</p>\n<p>除了使用 JSX 语法，我们还可以使用 <code>React.createElement()</code> 和 <code>React.cloneElement()</code> 来构建 React 元素。</p>\n<h4 id=\"1、React-createElement-创建元素\"><a href=\"#1、React-createElement-创建元素\" class=\"headerlink\" title=\"1、React.createElement() 创建元素\"></a>1、React.createElement() 创建元素</h4><p>JSX 语法就是用<code>React.createElement()</code>来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如<code>div</code>、<code>span</code>，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createElement(</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    [props],</span><br><span class=\"line\">    [...children]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该方法创建并返回一个<code>ReactElement</code>对象，其参数如下：</p>\n<ul>\n<li><code>type</code>，可以是一个<code>HTML标签</code>或是一个<code>React组件</code>（<code>ReactClass</code>）</li>\n<li><code>props</code>，可选参数，表示对象的属性</li>\n<li><code>children</code>，第三个参数及其后的参数都会被认为是元素的子元素</li>\n<li>返回值：<code>ReactElement</code>对象</li>\n</ul>\n<p>示例，创建一个如下结构的组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"myClass\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>itbilu.com<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">hr</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>使用<code>createElement()</code>方法操作如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  React.createElement(<span class=\"string\">'div'</span>, &#123;<span class=\"attr\">className</span>:<span class=\"string\">'myClass'</span>&#125;,  </span><br><span class=\"line\">    React.createElement(<span class=\"string\">'h2'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'itbilu.com'</span>),</span><br><span class=\"line\">    React.createElement(<span class=\"string\">'hr'</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// itbilu.com</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2、React-cloneElement-元素克隆\"><a href=\"#2、React-cloneElement-元素克隆\" class=\"headerlink\" title=\"2、React.cloneElement() 元素克隆\"></a>2、React.cloneElement() 元素克隆</h4><p><code>React.cloneElement()</code>与<code>React.createElement()</code>相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.cloneElement(</span><br><span class=\"line\">  element,</span><br><span class=\"line\">  [props],</span><br><span class=\"line\">  [...children]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该方法会从已有的<code>ReactElement</code>中复制，并返回一个新的<code>ReactElement</code>对象，其参数如下：</p>\n<ul>\n<li><code>element</code>，一个<code>React元素</code>（<code>ReactElement</code>）</li>\n<li><code>props</code>，可选参数，表示对象的属性</li>\n<li><code>children</code>，第三个参数及其后的参数都会被认为是元素的子元素</li>\n<li>返回值：<code>ReactElement</code>对象</li>\n</ul>\n<p>示例，已有如下元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createElement(<span class=\"string\">'div'</span>);</span><br></pre></td></tr></table></figure>\n<p>使用<code>cloneElement()</code>复制这个元素，并最终生前面示例中的HTML。复制方法如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div = React.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  React.cloneElement(div, &#123;<span class=\"attr\">className</span>:<span class=\"string\">'myClass'</span>&#125;,  </span><br><span class=\"line\">    React.createElement(<span class=\"string\">'h2'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'itbilu.com'</span>),</span><br><span class=\"line\">    React.createElement(<span class=\"string\">'hr'</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-、什么是组件？\"><a href=\"#二-、什么是组件？\" class=\"headerlink\" title=\"(二)、什么是组件？\"></a>(二)、什么是组件？</h3><p>组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。</p>\n<p>组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。</p>\n<p><strong>特点 </strong>：</p>\n<ol>\n<li>组件就是函数</li>\n<li>组件编写时，首字母大写</li>\n<li>组件可以嵌套组合使用 ，遵循是W3C的规范</li>\n</ol>\n<p>定义一个组件最简单的方式是使用JavaScript函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1、函数定义组件-写法一\"><a href=\"#1、函数定义组件-写法一\" class=\"headerlink\" title=\"1、函数定义组件(写法一)\"></a>1、函数定义组件(写法一)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome,&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、类定义组件-写法二\"><a href=\"#2、类定义组件-写法二\" class=\"headerlink\" title=\"2、类定义组件(写法二)\"></a>2、类定义组件(写法二)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">        render()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome,&#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、组合组件\"><a href=\"#3、组合组件\" class=\"headerlink\" title=\"3、组合组件\"></a>3、组合组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello,&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(</span><br><span class=\"line\">            <span class=\"comment\">// 组件的返回值只能有一个根元素。</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是我们要用一个&lt;div&gt;来包裹所有&lt;Welcome /&gt;元素的原因。</span></span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Sara'</span> /&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Cahal'</span> /&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Edite'</span> /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;App /</span>&gt;,</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、提取组件\"><a href=\"#4、提取组件\" class=\"headerlink\" title=\"4、提取组件\"></a>4、提取组件</h4><p><strong>意义</strong> :</p>\n<ol>\n<li>可重用性</li>\n<li>可读性</li>\n<li>可维护性</li>\n<li>便于调试与测试</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;img</span><br><span class=\"line\">            className=<span class=\"string\">'Avatar'</span> </span><br><span class=\"line\">            src=&#123;props.user.avator&#125; </span><br><span class=\"line\">            alt=&#123;props.user.name&#125; </span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"UserInfo\"</span>&gt;</span><br><span class=\"line\">            &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"UserInfoName\"</span>&gt;</span><br><span class=\"line\">                &#123;props.user.name&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"Comment\"</span>&gt;</span><br><span class=\"line\">            &lt;UserInfo user=&#123;props.user&#125; /&gt; </span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"CommentText\"</span>&gt;</span><br><span class=\"line\">                &#123;props.text&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div className=\"CommentDate\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;props.date&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ) </span></span><br><span class=\"line\"><span class=\"regexp\">&#125; </span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/提取Avatar组件 </span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;h1&gt;Hello,World&lt;/</span>h1&gt;, </span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>) </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-元素和组件的区别\"><a href=\"#三-元素和组件的区别\" class=\"headerlink\" title=\"(三)元素和组件的区别\"></a>(三)元素和组件的区别</h3><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。</p>\n<p>打个不恰当的比喻，React 组件是<code>MyComponent</code>，React 元素就是<code>&lt;MyComponent /&gt;</code>。</p>\n<h1 id=\"三、组件的类型及其区别\"><a href=\"#三、组件的类型及其区别\" class=\"headerlink\" title=\"三、组件的类型及其区别\"></a>三、组件的类型及其区别</h1><p>React推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：</p>\n<ol>\n<li>函数式定义的<code>无状态组件</code></li>\n<li>es5原生方式<code>React.createClass</code>定义的组件</li>\n<li>es6形式的<code>extends React.Component</code>定义的组件</li>\n</ol>\n<p>虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。</p>\n<h3 id=\"一-无状态函数式组件\"><a href=\"#一-无状态函数式组件\" class=\"headerlink\" title=\"(一)无状态函数式组件\"></a>(一)无状态函数式组件</h3><p>创建<a href=\"https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components\" target=\"_blank\" rel=\"noopener\">无状态函数式组件形式</a>是从<code>React 0.14</code>版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的<code>props</code>来展示，不涉及到要<code>state</code>状态的操作。具体的<em>无状态函数式组件</em>，其官方指出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。</span><br></pre></td></tr></table></figure>\n<p>无状态函数式组件形式上表现为一个只带有一个<code>render</code>方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无<code>state</code>状态的。具体的创建形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloComponent</span>(<span class=\"params\">props, <span class=\"regexp\">/* context */</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">HelloComponent</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sebastian\"</span> /&gt;</span>, mountNode)</span></span><br></pre></td></tr></table></figure>\n<p>无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：</p>\n<ol>\n<li><strong>组件不会被实例化，整体渲染性能得到提升</strong><br>因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。</li>\n<li><strong>组件不能访问this对象</strong><br>无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：<code>this.ref</code>、<code>this.state</code>等均不能访问。若想访问就不能使用这种形式来创建组件</li>\n<li><strong>组件无法访问生命周期的方法</strong><br>因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。</li>\n<li><strong>无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用</strong></li>\n</ol>\n<p>无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以<strong>只要有可能，尽量使用无状态组件</strong>。</p>\n<h3 id=\"二-React-createClass\"><a href=\"#二-React-createClass\" class=\"headerlink\" title=\"(二)React.createClass\"></a>(二)React.createClass</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`React.createClass`是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> InputControlES5 = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123;<span class=\"comment\">//定义传入props中的属性各种类型</span></span><br><span class=\"line\">        initialValue: React.PropTypes.string</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    defaultProps: &#123; <span class=\"comment\">//组件默认的props对象</span></span><br><span class=\"line\">        initialValue: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 设置 initial state</span></span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">//组件相关的状态对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            text: <span class=\"keyword\">this</span>.props.initialValue || <span class=\"string\">'placeholder'</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; <span class=\"comment\">//this represents react component instance</span></span><br><span class=\"line\">            text: event.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Type something:</span><br><span class=\"line\">                &lt;input onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; value=&#123;<span class=\"keyword\">this</span>.state.text&#125; /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: React.PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.defaultProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: ''</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<p>与无状态组件相比，<code>React.createClass</code>和后面要描述的<code>React.Component</code>都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，<code>React.createClass</code>形式自身的问题暴露出来：</p>\n<ul>\n<li>React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。</li>\n<li>React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components–HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考<a href=\"http://www.jianshu.com/p/63569386befc\" target=\"_blank\" rel=\"noopener\">无状态组件(Stateless Component) 与高阶组件</a>。</li>\n</ul>\n<h3 id=\"三-React-Component\"><a href=\"#三-React-Component\" class=\"headerlink\" title=\"(三)React.Component\"></a>(三)React.Component</h3><p><code>React.Component</code>是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代<code>React.createClass</code>形式；相对于 <code>React.createClass</code>可以更好实现代码复用。将上面<code>React.createClass</code>的形式改为<code>React.Component</code>形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputControlES6</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置 initial state</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            text: props.initialValue || <span class=\"string\">'placeholder'</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ES6 类中函数必须手动绑定</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange(event) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            text: event.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Type something:</span><br><span class=\"line\">                &lt;input onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;</span><br><span class=\"line\">               value=&#123;<span class=\"keyword\">this</span>.state.text&#125; /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: React.PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.defaultProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: ''</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"四-React-createClass与React-Component区别\"><a href=\"#四-React-createClass与React-Component区别\" class=\"headerlink\" title=\"(四)React.createClass与React.Component区别\"></a>(四)React.createClass与React.Component区别</h3><p>根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。</p>\n<h3 id=\"1、函数this自绑定\"><a href=\"#1、函数this自绑定\" class=\"headerlink\" title=\"1、函数this自绑定\"></a>1、函数this自绑定</h3><p><code>React.createClass</code>创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用<code>this.method</code>即可，函数中的<code>this</code>会被正确设置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Contacts = React.createClass(&#123;  </span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// React Component instance</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>React.Component</code>创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Contacts</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>当然，<code>React.Component</code>有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用<code>method.bind(this)</code>来完成绑定，还可以使用arrow function来绑定。拿上例的<code>handleClick</code>函数来说，其绑定可以有：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>); <span class=\"comment\">//构造函数中绑定</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">//使用bind来绑定</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;()=&gt;<span class=\"keyword\">this</span>.handleClick()&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">//使用arrow function来绑定</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、组件属性类型propTypes及其默认props属性defaultProps配置不同\"><a href=\"#2、组件属性类型propTypes及其默认props属性defaultProps配置不同\" class=\"headerlink\" title=\"2、组件属性类型propTypes及其默认props属性defaultProps配置不同\"></a>2、组件属性类型propTypes及其默认props属性defaultProps配置不同</h3><p><code>React.createClass</code>在创建组件时，有关组件props的属性类型及组件默认的属性会作为<strong>组件实例的属性</strong>来配置，其中defaultProps是使用<code>getDefaultProps</code>的方法来获取默认组件属性的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const TodoItem = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123; // as an object</span><br><span class=\"line\">        name: React.PropTypes.string</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getDefaultProps()&#123;   // return a object</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            name: &apos;&apos;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>React.Component</code>在创建组件时配置这两个对应信息时，他们是作为<strong>组件类的属性</strong>，不是组件实例的属性，也就是所谓的<strong>类的静态属性</strong>来配置的。对应上面配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoItem extends React.Component &#123;</span><br><span class=\"line\">    static propTypes = &#123;//类的静态属性</span><br><span class=\"line\">        name: React.PropTypes.string</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    static defaultProps = &#123;//类的静态属性</span><br><span class=\"line\">        name: &apos;&apos;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、组件初始状态state的配置不同\"><a href=\"#3、组件初始状态state的配置不同\" class=\"headerlink\" title=\"3、组件初始状态state的配置不同\"></a>3、组件初始状态state的配置不同</h3><p><code>React.createClass</code>创建的组件，其状态state是通过<code>getInitialState</code>方法来配置组件相关的状态；<br><code>React.Component</code>创建的组件，其状态state是在<code>constructor</code>中像初始化组件属性一样声明的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const TodoItem = React.createClass(&#123;</span><br><span class=\"line\">    // return an object</span><br><span class=\"line\">    getInitialState()&#123; </span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            isEditing: false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoItem extends React.Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123; // define this.state in constructor</span><br><span class=\"line\">            isEditing: false</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、Mixins的支持不同\"><a href=\"#4、Mixins的支持不同\" class=\"headerlink\" title=\"4、Mixins的支持不同\"></a>4、Mixins的支持不同</h3><p><a href=\"https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins\" target=\"_blank\" rel=\"noopener\"><code>Mixins</code></a>(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过<code>Mixins</code>进该对象来达到代码复用。具体可以参考<a href=\"http://www.w3ctech.com/topic/1599\" target=\"_blank\" rel=\"noopener\">React Mixin的前世今生</a>。</p>\n<p><code>React.createClass</code>在创建组件时可以使用<code>mixins</code>属性，以数组的形式来混合类的集合。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var SomeMixin = &#123;  </span><br><span class=\"line\">  doSomething() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const Contacts = React.createClass(&#123;  </span><br><span class=\"line\">  mixins: [SomeMixin],</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    this.doSomething(); // use mixin</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>但是遗憾的是<code>React.Component</code>这种形式并不支持<code>Mixins</code>，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代<code>Mixins</code>,那就是<strong>Higher-Order Components</strong>，具体细节可以参考<a href=\"https://leozdgao.me/chushi-hoc/\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n<h3 id=\"五-如何选择哪种方式创建组件\"><a href=\"#五-如何选择哪种方式创建组件\" class=\"headerlink\" title=\"(五)如何选择哪种方式创建组件\"></a>(五)如何选择哪种方式创建组件</h3><p>由于React团队<a href=\"https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html\" target=\"_blank\" rel=\"noopener\">已经声明</a>React.createClass最终会被React.Component的类形式所取代。但是在找到<code>Mixins</code>替代方案之前是不会废弃掉<code>React.createClass</code>形式。所以：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。</span><br></pre></td></tr></table></figure>\n<p>除此之外，创建组件的形式选择还应该根据下面来决定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、只要有可能，尽量使用无状态组件创建形式。</span><br><span class=\"line\"></span><br><span class=\"line\">2、否则（如需要state、生命周期方法等），使用`React.Component`这种es6形式创建组件</span><br></pre></td></tr></table></figure>\n<p><strong>补充一点</strong></p>\n<blockquote>\n<p>无状态组件内部其实是可以使用<code>ref</code>功能的，虽然不能通过<code>this.refs</code>访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。</p>\n</blockquote>\n<p>例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">TestComp</span>(<span class=\"params\">props</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ref;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">        &lt;div ref=&#123;(node) =&gt; ref = node&#125;&gt;</span><br><span class=\"line\">            ...</span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"http://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html\" target=\"_blank\" rel=\"noopener\">React 组件构造方法: ES5 (createClass) 还是 ES6 (class)？</a></li>\n<li><a href=\"http://www.peachis.me/react-createclass-versus-extends-react-component/\" target=\"_blank\" rel=\"noopener\">React.createClass 对比 extends React.Component</a></li>\n<li><a href=\"https://medium.com/@kingzs70/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-react-createclass-es6-classes-%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-52f07dd70e75#.3m2m0t62r\" target=\"_blank\" rel=\"noopener\">应该如何选择：React.createClass, ES6 Classes, 无状态函数式组件</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006180667\" target=\"_blank\" rel=\"noopener\">React中函数式声明组件</a></li>\n<li><a href=\"http://www.w3ctech.com/topic/1599\" target=\"_blank\" rel=\"noopener\">React Mixin 的前世今生</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://p2oiag4fy.bkt.clouddn.com/React.jpeg\" alt=\"\"></p>\n<h1 id=\"一-、属性和状态\"><a href=\"#一-、属性和状态\" class=\"headerlink\" title=\"一 、属性和状态\"></a>一 、属性和状态</h1><h3 id=\"一-什么是属性？\"><a href=\"#一-什么是属性？\" class=\"headerlink\" title=\"(一)什么是属性？\"></a>(一)什么是属性？</h3><p>props=properties </p>\n<h4 id=\"1、属性的含义和用法\"><a href=\"#1、属性的含义和用法\" class=\"headerlink\" title=\"1、属性的含义和用法\"></a>1、属性的含义和用法</h4><p>含义 ：一个事物的性质与关系，属性往往是与生俱来的、无法自己改变的。</p>\n<p>3种用法 ：</p>\n<p>(1)键值对</p>\n<p>传入一个字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'Hello,World!'</span> 或 &#123;<span class=\"string\">'Hello,World!'</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>传入一个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;[Array1,Array2,Array3]&#125;</span><br></pre></td></tr></table></figure>\n<p>传入一个变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;variable&#125;</span><br></pre></td></tr></table></figure>\n<p>(2)展开对象形式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> props = &#123;</span><br><span class=\"line\">\tone:<span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">\ttwo:<span class=\"number\">321</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;HelloWorld &#123;...props&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p>React提供展开语法…,使用…加对象,react就会把对象中的属性和值，当成是属性的赋值。</p>\n<p>(3)setProps形式：</p>\n<p>通过组件更新属性，不能在组件内部中修改属性的，因为会违背组件设计原则（尽量避免）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/babel\"</span>&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> HelloWorld = React.createClass(&#123;</span><br><span class=\"line\">        render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &lt;p&gt;Hello, &#123;this.props.name&#125;&lt;/p&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = ReactDOM.render(&lt;HelloWorld&gt;&lt;/HelloWorld&gt;, <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#example\"</span>));</span><br><span class=\"line\">    instance.setProps(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"William\"</span>&#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>setProps接收的参数是一个对象，但是react不推荐改变组件的属性,可以通过父组件向子组件传入的方式。</p>\n<h3 id=\"二-什么是状态？\"><a href=\"#二-什么是状态？\" class=\"headerlink\" title=\"(二)什么是状态？\"></a>(二)什么是状态？</h3><p>state</p>\n<h4 id=\"1、状态的含义和用法\"><a href=\"#1、状态的含义和用法\" class=\"headerlink\" title=\"1、状态的含义和用法\"></a>1、状态的含义和用法</h4><p>含义 ：事物所处的状况。状态是由事物自行处理、不断变化的，是事物的私有属性。 </p>\n<p>用法：</p>\n<p>getInitialState:初始化每个实例特有的状态<br>setState:更新组件状态<br>使用setState——启用diff算法——有变化，更新DOM</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用状态 state，实现时钟</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Time</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//构造器函数（初始化函数）：初始化</span></span><br><span class=\"line\">       <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">           <span class=\"comment\">//初始化状态</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.state=&#123;</span><br><span class=\"line\">               date:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">//修改状态:每隔一秒，修改状态</span></span><br><span class=\"line\">           setInterval(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"string\">'定时器执行'</span>);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                   date:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\">           &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       render()&#123;</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"string\">'时间'</span>,<span class=\"keyword\">this</span>.state.date);</span><br><span class=\"line\">           <span class=\"keyword\">return</span>(</span><br><span class=\"line\">               <span class=\"comment\">//使用</span></span><br><span class=\"line\">               &lt;p&gt;当前时间:  &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">           );</span></span><br><span class=\"line\"><span class=\"regexp\">       &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">   &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">   ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">       &lt;Time /</span>&gt;,</span><br><span class=\"line\">       <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">       );</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-属性和状态对比\"><a href=\"#三-属性和状态对比\" class=\"headerlink\" title=\"(三)属性和状态对比\"></a>(三)属性和状态对比</h3><p>属性和状态作为组件之间数据流动的途径，非常容易混用，下面对属性和状态进行对比，介绍两者的相同点、不同点以及使用方法。</p>\n<h4 id=\"1、相同点\"><a href=\"#1、相同点\" class=\"headerlink\" title=\"1、相同点\"></a>1、相同点</h4><ul>\n<li>都是纯JS对象</li>\n<li>都会触发render更新</li>\n<li>都具有确定性</li>\n</ul>\n<h4 id=\"2、对比\"><a href=\"#2、对比\" class=\"headerlink\" title=\"2、对比\"></a>2、对比</h4><table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">属性( props)</th>\n<th style=\"text-align:center\">状态(state)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>能否从父组件获取初始值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否由父组件修改</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否在组件内部设置默认值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>能否在组件内部修改</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>能否设置子组件的初始值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否修改子组件的值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<p>状态只和组件本身相关，组件不能修改属性</p>\n<h4 id=\"3、区分\"><a href=\"#3、区分\" class=\"headerlink\" title=\"3、区分\"></a>3、区分</h4><ul>\n<li><p>状态和属性都会触发render更新，都是纯JS对象</p>\n</li>\n<li><p>状态：是和自己相关的，既不受父组件也不受子组件影响</p>\n</li>\n<li><p>属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性。</p>\n<p>根本的区别：组件在运行时需要去修改维护的就是状态</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"二、元素和组件\"><a href=\"#二、元素和组件\" class=\"headerlink\" title=\"二、元素和组件\"></a>二、元素和组件</h1><h3 id=\"一-、什么是元素？\"><a href=\"#一-、什么是元素？\" class=\"headerlink\" title=\"(一)、什么是元素？\"></a>(一)、什么是元素？</h3><p>元素用来描述你在屏幕上看到的内容</p>\n<p>与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。</p>\n<p>React 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &lt;div className=\"element\"&gt;I'm element&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    _context: Object,</span><br><span class=\"line\">    _owner: null,</span><br><span class=\"line\">    key: null,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">    className: 'element'，</span><br><span class=\"line\">    children: 'I'm element'</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    ref: null,</span><br><span class=\"line\">    type: \"div\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口<code>ref</code>和<code>getDOMNode()</code>。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。</p>\n<p>除了使用 JSX 语法，我们还可以使用 <code>React.createElement()</code> 和 <code>React.cloneElement()</code> 来构建 React 元素。</p>\n<h4 id=\"1、React-createElement-创建元素\"><a href=\"#1、React-createElement-创建元素\" class=\"headerlink\" title=\"1、React.createElement() 创建元素\"></a>1、React.createElement() 创建元素</h4><p>JSX 语法就是用<code>React.createElement()</code>来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如<code>div</code>、<code>span</code>，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createElement(</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    [props],</span><br><span class=\"line\">    [...children]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该方法创建并返回一个<code>ReactElement</code>对象，其参数如下：</p>\n<ul>\n<li><code>type</code>，可以是一个<code>HTML标签</code>或是一个<code>React组件</code>（<code>ReactClass</code>）</li>\n<li><code>props</code>，可选参数，表示对象的属性</li>\n<li><code>children</code>，第三个参数及其后的参数都会被认为是元素的子元素</li>\n<li>返回值：<code>ReactElement</code>对象</li>\n</ul>\n<p>示例，创建一个如下结构的组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"myClass\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>itbilu.com<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">hr</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>使用<code>createElement()</code>方法操作如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  React.createElement(<span class=\"string\">'div'</span>, &#123;<span class=\"attr\">className</span>:<span class=\"string\">'myClass'</span>&#125;,  </span><br><span class=\"line\">    React.createElement(<span class=\"string\">'h2'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'itbilu.com'</span>),</span><br><span class=\"line\">    React.createElement(<span class=\"string\">'hr'</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// itbilu.com</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2、React-cloneElement-元素克隆\"><a href=\"#2、React-cloneElement-元素克隆\" class=\"headerlink\" title=\"2、React.cloneElement() 元素克隆\"></a>2、React.cloneElement() 元素克隆</h4><p><code>React.cloneElement()</code>与<code>React.createElement()</code>相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.cloneElement(</span><br><span class=\"line\">  element,</span><br><span class=\"line\">  [props],</span><br><span class=\"line\">  [...children]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该方法会从已有的<code>ReactElement</code>中复制，并返回一个新的<code>ReactElement</code>对象，其参数如下：</p>\n<ul>\n<li><code>element</code>，一个<code>React元素</code>（<code>ReactElement</code>）</li>\n<li><code>props</code>，可选参数，表示对象的属性</li>\n<li><code>children</code>，第三个参数及其后的参数都会被认为是元素的子元素</li>\n<li>返回值：<code>ReactElement</code>对象</li>\n</ul>\n<p>示例，已有如下元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createElement(<span class=\"string\">'div'</span>);</span><br></pre></td></tr></table></figure>\n<p>使用<code>cloneElement()</code>复制这个元素，并最终生前面示例中的HTML。复制方法如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div = React.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  React.cloneElement(div, &#123;<span class=\"attr\">className</span>:<span class=\"string\">'myClass'</span>&#125;,  </span><br><span class=\"line\">    React.createElement(<span class=\"string\">'h2'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'itbilu.com'</span>),</span><br><span class=\"line\">    React.createElement(<span class=\"string\">'hr'</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-、什么是组件？\"><a href=\"#二-、什么是组件？\" class=\"headerlink\" title=\"(二)、什么是组件？\"></a>(二)、什么是组件？</h3><p>组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。</p>\n<p>组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。</p>\n<p><strong>特点 </strong>：</p>\n<ol>\n<li>组件就是函数</li>\n<li>组件编写时，首字母大写</li>\n<li>组件可以嵌套组合使用 ，遵循是W3C的规范</li>\n</ol>\n<p>定义一个组件最简单的方式是使用JavaScript函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1、函数定义组件-写法一\"><a href=\"#1、函数定义组件-写法一\" class=\"headerlink\" title=\"1、函数定义组件(写法一)\"></a>1、函数定义组件(写法一)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome,&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、类定义组件-写法二\"><a href=\"#2、类定义组件-写法二\" class=\"headerlink\" title=\"2、类定义组件(写法二)\"></a>2、类定义组件(写法二)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">        render()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome,&#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、组合组件\"><a href=\"#3、组合组件\" class=\"headerlink\" title=\"3、组合组件\"></a>3、组合组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello,&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(</span><br><span class=\"line\">            <span class=\"comment\">// 组件的返回值只能有一个根元素。</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是我们要用一个&lt;div&gt;来包裹所有&lt;Welcome /&gt;元素的原因。</span></span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Sara'</span> /&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Cahal'</span> /&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Edite'</span> /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;App /</span>&gt;,</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、提取组件\"><a href=\"#4、提取组件\" class=\"headerlink\" title=\"4、提取组件\"></a>4、提取组件</h4><p><strong>意义</strong> :</p>\n<ol>\n<li>可重用性</li>\n<li>可读性</li>\n<li>可维护性</li>\n<li>便于调试与测试</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;img</span><br><span class=\"line\">            className=<span class=\"string\">'Avatar'</span> </span><br><span class=\"line\">            src=&#123;props.user.avator&#125; </span><br><span class=\"line\">            alt=&#123;props.user.name&#125; </span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"UserInfo\"</span>&gt;</span><br><span class=\"line\">            &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"UserInfoName\"</span>&gt;</span><br><span class=\"line\">                &#123;props.user.name&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"Comment\"</span>&gt;</span><br><span class=\"line\">            &lt;UserInfo user=&#123;props.user&#125; /&gt; </span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"CommentText\"</span>&gt;</span><br><span class=\"line\">                &#123;props.text&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div className=\"CommentDate\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;props.date&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ) </span></span><br><span class=\"line\"><span class=\"regexp\">&#125; </span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/提取Avatar组件 </span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;h1&gt;Hello,World&lt;/</span>h1&gt;, </span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>) </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-元素和组件的区别\"><a href=\"#三-元素和组件的区别\" class=\"headerlink\" title=\"(三)元素和组件的区别\"></a>(三)元素和组件的区别</h3><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。</p>\n<p>打个不恰当的比喻，React 组件是<code>MyComponent</code>，React 元素就是<code>&lt;MyComponent /&gt;</code>。</p>\n<h1 id=\"三、组件的类型及其区别\"><a href=\"#三、组件的类型及其区别\" class=\"headerlink\" title=\"三、组件的类型及其区别\"></a>三、组件的类型及其区别</h1><p>React推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：</p>\n<ol>\n<li>函数式定义的<code>无状态组件</code></li>\n<li>es5原生方式<code>React.createClass</code>定义的组件</li>\n<li>es6形式的<code>extends React.Component</code>定义的组件</li>\n</ol>\n<p>虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。</p>\n<h3 id=\"一-无状态函数式组件\"><a href=\"#一-无状态函数式组件\" class=\"headerlink\" title=\"(一)无状态函数式组件\"></a>(一)无状态函数式组件</h3><p>创建<a href=\"https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components\" target=\"_blank\" rel=\"noopener\">无状态函数式组件形式</a>是从<code>React 0.14</code>版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的<code>props</code>来展示，不涉及到要<code>state</code>状态的操作。具体的<em>无状态函数式组件</em>，其官方指出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。</span><br></pre></td></tr></table></figure>\n<p>无状态函数式组件形式上表现为一个只带有一个<code>render</code>方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无<code>state</code>状态的。具体的创建形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloComponent</span>(<span class=\"params\">props, <span class=\"regexp\">/* context */</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">HelloComponent</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sebastian\"</span> /&gt;</span>, mountNode)</span></span><br></pre></td></tr></table></figure>\n<p>无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：</p>\n<ol>\n<li><strong>组件不会被实例化，整体渲染性能得到提升</strong><br>因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。</li>\n<li><strong>组件不能访问this对象</strong><br>无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：<code>this.ref</code>、<code>this.state</code>等均不能访问。若想访问就不能使用这种形式来创建组件</li>\n<li><strong>组件无法访问生命周期的方法</strong><br>因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。</li>\n<li><strong>无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用</strong></li>\n</ol>\n<p>无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以<strong>只要有可能，尽量使用无状态组件</strong>。</p>\n<h3 id=\"二-React-createClass\"><a href=\"#二-React-createClass\" class=\"headerlink\" title=\"(二)React.createClass\"></a>(二)React.createClass</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`React.createClass`是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> InputControlES5 = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123;<span class=\"comment\">//定义传入props中的属性各种类型</span></span><br><span class=\"line\">        initialValue: React.PropTypes.string</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    defaultProps: &#123; <span class=\"comment\">//组件默认的props对象</span></span><br><span class=\"line\">        initialValue: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 设置 initial state</span></span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">//组件相关的状态对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            text: <span class=\"keyword\">this</span>.props.initialValue || <span class=\"string\">'placeholder'</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; <span class=\"comment\">//this represents react component instance</span></span><br><span class=\"line\">            text: event.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Type something:</span><br><span class=\"line\">                &lt;input onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; value=&#123;<span class=\"keyword\">this</span>.state.text&#125; /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: React.PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.defaultProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: ''</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<p>与无状态组件相比，<code>React.createClass</code>和后面要描述的<code>React.Component</code>都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，<code>React.createClass</code>形式自身的问题暴露出来：</p>\n<ul>\n<li>React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。</li>\n<li>React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components–HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考<a href=\"http://www.jianshu.com/p/63569386befc\" target=\"_blank\" rel=\"noopener\">无状态组件(Stateless Component) 与高阶组件</a>。</li>\n</ul>\n<h3 id=\"三-React-Component\"><a href=\"#三-React-Component\" class=\"headerlink\" title=\"(三)React.Component\"></a>(三)React.Component</h3><p><code>React.Component</code>是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代<code>React.createClass</code>形式；相对于 <code>React.createClass</code>可以更好实现代码复用。将上面<code>React.createClass</code>的形式改为<code>React.Component</code>形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputControlES6</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置 initial state</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            text: props.initialValue || <span class=\"string\">'placeholder'</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ES6 类中函数必须手动绑定</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange(event) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            text: event.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Type something:</span><br><span class=\"line\">                &lt;input onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;</span><br><span class=\"line\">               value=&#123;<span class=\"keyword\">this</span>.state.text&#125; /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: React.PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.defaultProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: ''</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"四-React-createClass与React-Component区别\"><a href=\"#四-React-createClass与React-Component区别\" class=\"headerlink\" title=\"(四)React.createClass与React.Component区别\"></a>(四)React.createClass与React.Component区别</h3><p>根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。</p>\n<h3 id=\"1、函数this自绑定\"><a href=\"#1、函数this自绑定\" class=\"headerlink\" title=\"1、函数this自绑定\"></a>1、函数this自绑定</h3><p><code>React.createClass</code>创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用<code>this.method</code>即可，函数中的<code>this</code>会被正确设置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Contacts = React.createClass(&#123;  </span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// React Component instance</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>React.Component</code>创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Contacts</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>当然，<code>React.Component</code>有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用<code>method.bind(this)</code>来完成绑定，还可以使用arrow function来绑定。拿上例的<code>handleClick</code>函数来说，其绑定可以有：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>); <span class=\"comment\">//构造函数中绑定</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">//使用bind来绑定</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;()=&gt;<span class=\"keyword\">this</span>.handleClick()&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">//使用arrow function来绑定</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、组件属性类型propTypes及其默认props属性defaultProps配置不同\"><a href=\"#2、组件属性类型propTypes及其默认props属性defaultProps配置不同\" class=\"headerlink\" title=\"2、组件属性类型propTypes及其默认props属性defaultProps配置不同\"></a>2、组件属性类型propTypes及其默认props属性defaultProps配置不同</h3><p><code>React.createClass</code>在创建组件时，有关组件props的属性类型及组件默认的属性会作为<strong>组件实例的属性</strong>来配置，其中defaultProps是使用<code>getDefaultProps</code>的方法来获取默认组件属性的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const TodoItem = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123; // as an object</span><br><span class=\"line\">        name: React.PropTypes.string</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getDefaultProps()&#123;   // return a object</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            name: &apos;&apos;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>React.Component</code>在创建组件时配置这两个对应信息时，他们是作为<strong>组件类的属性</strong>，不是组件实例的属性，也就是所谓的<strong>类的静态属性</strong>来配置的。对应上面配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoItem extends React.Component &#123;</span><br><span class=\"line\">    static propTypes = &#123;//类的静态属性</span><br><span class=\"line\">        name: React.PropTypes.string</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    static defaultProps = &#123;//类的静态属性</span><br><span class=\"line\">        name: &apos;&apos;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、组件初始状态state的配置不同\"><a href=\"#3、组件初始状态state的配置不同\" class=\"headerlink\" title=\"3、组件初始状态state的配置不同\"></a>3、组件初始状态state的配置不同</h3><p><code>React.createClass</code>创建的组件，其状态state是通过<code>getInitialState</code>方法来配置组件相关的状态；<br><code>React.Component</code>创建的组件，其状态state是在<code>constructor</code>中像初始化组件属性一样声明的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const TodoItem = React.createClass(&#123;</span><br><span class=\"line\">    // return an object</span><br><span class=\"line\">    getInitialState()&#123; </span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            isEditing: false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoItem extends React.Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123; // define this.state in constructor</span><br><span class=\"line\">            isEditing: false</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、Mixins的支持不同\"><a href=\"#4、Mixins的支持不同\" class=\"headerlink\" title=\"4、Mixins的支持不同\"></a>4、Mixins的支持不同</h3><p><a href=\"https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins\" target=\"_blank\" rel=\"noopener\"><code>Mixins</code></a>(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过<code>Mixins</code>进该对象来达到代码复用。具体可以参考<a href=\"http://www.w3ctech.com/topic/1599\" target=\"_blank\" rel=\"noopener\">React Mixin的前世今生</a>。</p>\n<p><code>React.createClass</code>在创建组件时可以使用<code>mixins</code>属性，以数组的形式来混合类的集合。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var SomeMixin = &#123;  </span><br><span class=\"line\">  doSomething() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const Contacts = React.createClass(&#123;  </span><br><span class=\"line\">  mixins: [SomeMixin],</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    this.doSomething(); // use mixin</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>但是遗憾的是<code>React.Component</code>这种形式并不支持<code>Mixins</code>，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代<code>Mixins</code>,那就是<strong>Higher-Order Components</strong>，具体细节可以参考<a href=\"https://leozdgao.me/chushi-hoc/\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n<h3 id=\"五-如何选择哪种方式创建组件\"><a href=\"#五-如何选择哪种方式创建组件\" class=\"headerlink\" title=\"(五)如何选择哪种方式创建组件\"></a>(五)如何选择哪种方式创建组件</h3><p>由于React团队<a href=\"https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html\" target=\"_blank\" rel=\"noopener\">已经声明</a>React.createClass最终会被React.Component的类形式所取代。但是在找到<code>Mixins</code>替代方案之前是不会废弃掉<code>React.createClass</code>形式。所以：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。</span><br></pre></td></tr></table></figure>\n<p>除此之外，创建组件的形式选择还应该根据下面来决定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、只要有可能，尽量使用无状态组件创建形式。</span><br><span class=\"line\"></span><br><span class=\"line\">2、否则（如需要state、生命周期方法等），使用`React.Component`这种es6形式创建组件</span><br></pre></td></tr></table></figure>\n<p><strong>补充一点</strong></p>\n<blockquote>\n<p>无状态组件内部其实是可以使用<code>ref</code>功能的，虽然不能通过<code>this.refs</code>访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。</p>\n</blockquote>\n<p>例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">TestComp</span>(<span class=\"params\">props</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ref;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">        &lt;div ref=&#123;(node) =&gt; ref = node&#125;&gt;</span><br><span class=\"line\">            ...</span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"http://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html\" target=\"_blank\" rel=\"noopener\">React 组件构造方法: ES5 (createClass) 还是 ES6 (class)？</a></li>\n<li><a href=\"http://www.peachis.me/react-createclass-versus-extends-react-component/\" target=\"_blank\" rel=\"noopener\">React.createClass 对比 extends React.Component</a></li>\n<li><a href=\"https://medium.com/@kingzs70/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-react-createclass-es6-classes-%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-52f07dd70e75#.3m2m0t62r\" target=\"_blank\" rel=\"noopener\">应该如何选择：React.createClass, ES6 Classes, 无状态函数式组件</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006180667\" target=\"_blank\" rel=\"noopener\">React中函数式声明组件</a></li>\n<li><a href=\"http://www.w3ctech.com/topic/1599\" target=\"_blank\" rel=\"noopener\">React Mixin 的前世今生</a></li>\n</ul>\n"},{"title":"关于puppeteer","date":"2018-01-20T07:23:24.000Z","_content":"\n### 介绍一下Puppeteer\n\n>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API（默认headless也就是无UI的chrome，也可以配置为有UI</br>有点类似于PhantomJS，但Puppeteer是Chrome官方团队进行维护的，前景更好。</br>使用Puppeteer，相当于同时具有Linux和Chrome的能力，应用场景会非常多。就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关\n\n#### [详情请看Puppeteer官方文档](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser)\n\n阅读以下内容，可以实现爬取[片刻网](http://pianke.me)的首页数据。\n\n#### Puppeteer 几个重要功能\n* 可以抓取网站内容\n* 可以自动化表单提交、搜索网络内容、UI测试等\n* 获取网页生成的PDF、图片、视频等资源\n\n接下来的操作基于 Node 环境\n\n```\nmkdir test && cd test\nnpm init\nnpm install puppeteer\n```\n\n<!--上述命令墙内用户可能会有问题，建议科学上网-->\n\n#### Puppeteer 基本用法\n\n1.使用`puppeteer.launch()`运行puppeteer，他会return一个promise，使用then方法获取browser实例，[Browser API](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser).\n\n2.拿到browser实例后，通过`browser.newPage()`方法，可以得到一个page实例，[Page API](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-page).\n\n3.使用`page.goto()`方法，[跳转至ES6标准入门](http://es6.ruanyifeng.com/#README).\n\n4.在`page.evaluate()`方法中注册回调函数，并分析dom结构，从下图可以进行详细分析，并通过`document.querySelectorAll('ol li a')`拿到想要获取的内容.\n\n#### 具体代码\n\n[点我查看详细代码](https://github.com/easy261925/Puppeteer)\n\n或 `git clone git@github.com:easy261925/Puppeteer.git`\n\n#### 说一下我遇到坑吧\n\n1. 在配置环境的时候由于网络的原因，在安装 Puppetee 的时候可能会无法安装,[ node_modules 百度云下载地址 ](https://pan.baidu.com/s/1dIMKjk) 密码: bxhy. 不需要 `npm i`了, 下载完后直接使用`node getData.js`即可.\n2. 代码的实现过程, 在看过网上很多关于 Puppeteer 技术文章和同学大力帮助之后，也算把想要的结果得到了，但是关于 async Promise await 等函数以及 ES6 Array\n的新用法还不是特别清楚， 本人打算学习[ 阮一峰老师的ES6 ](http://es6.ruanyifeng.com/#README)之后, 在来详细补充其原理.\n3. 爬取到的数据是通过 class 名，找到里面元素的 src/style/innerText，但是获取到的数据格式为:` img:['1.jpg','2.jpg'];title:[ 'AAAAAAA','BBBBBBB'] ` 为了使用方便，我们对数据做了一些调整，让它变为`[{item1:['1.jpg','AAAAAAA']},{item1:['2.jpg','BBBBBBB']}]`,这样我们在铺到页面上时使用更加方便了.( 经历此过程也体验了一回写 API 接口的感觉 全是眼泪啊~~~ )\n\n\n### 结语\n由于能力有限,存在的问题还有很多，请看到此文的人不吝赐教，感激不尽。\n\n特别鸣谢:[QC-L老师](https://github.com/QC-L)，[marryyan ](https://github.com/marryyan)的帮助.\n\n### 未完待续。。。\n\n##### 参考文章:[https://segmentfault.com/a/1190000010736797](https://segmentfault.com/a/1190000010736797)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/关于puppeteer.md","raw":"---\ntitle: 关于puppeteer\ndate: 2018-01-20 15:23:24\ntags: puppeteer\ncategories: Node\n---\n\n### 介绍一下Puppeteer\n\n>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API（默认headless也就是无UI的chrome，也可以配置为有UI</br>有点类似于PhantomJS，但Puppeteer是Chrome官方团队进行维护的，前景更好。</br>使用Puppeteer，相当于同时具有Linux和Chrome的能力，应用场景会非常多。就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关\n\n#### [详情请看Puppeteer官方文档](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser)\n\n阅读以下内容，可以实现爬取[片刻网](http://pianke.me)的首页数据。\n\n#### Puppeteer 几个重要功能\n* 可以抓取网站内容\n* 可以自动化表单提交、搜索网络内容、UI测试等\n* 获取网页生成的PDF、图片、视频等资源\n\n接下来的操作基于 Node 环境\n\n```\nmkdir test && cd test\nnpm init\nnpm install puppeteer\n```\n\n<!--上述命令墙内用户可能会有问题，建议科学上网-->\n\n#### Puppeteer 基本用法\n\n1.使用`puppeteer.launch()`运行puppeteer，他会return一个promise，使用then方法获取browser实例，[Browser API](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser).\n\n2.拿到browser实例后，通过`browser.newPage()`方法，可以得到一个page实例，[Page API](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-page).\n\n3.使用`page.goto()`方法，[跳转至ES6标准入门](http://es6.ruanyifeng.com/#README).\n\n4.在`page.evaluate()`方法中注册回调函数，并分析dom结构，从下图可以进行详细分析，并通过`document.querySelectorAll('ol li a')`拿到想要获取的内容.\n\n#### 具体代码\n\n[点我查看详细代码](https://github.com/easy261925/Puppeteer)\n\n或 `git clone git@github.com:easy261925/Puppeteer.git`\n\n#### 说一下我遇到坑吧\n\n1. 在配置环境的时候由于网络的原因，在安装 Puppetee 的时候可能会无法安装,[ node_modules 百度云下载地址 ](https://pan.baidu.com/s/1dIMKjk) 密码: bxhy. 不需要 `npm i`了, 下载完后直接使用`node getData.js`即可.\n2. 代码的实现过程, 在看过网上很多关于 Puppeteer 技术文章和同学大力帮助之后，也算把想要的结果得到了，但是关于 async Promise await 等函数以及 ES6 Array\n的新用法还不是特别清楚， 本人打算学习[ 阮一峰老师的ES6 ](http://es6.ruanyifeng.com/#README)之后, 在来详细补充其原理.\n3. 爬取到的数据是通过 class 名，找到里面元素的 src/style/innerText，但是获取到的数据格式为:` img:['1.jpg','2.jpg'];title:[ 'AAAAAAA','BBBBBBB'] ` 为了使用方便，我们对数据做了一些调整，让它变为`[{item1:['1.jpg','AAAAAAA']},{item1:['2.jpg','BBBBBBB']}]`,这样我们在铺到页面上时使用更加方便了.( 经历此过程也体验了一回写 API 接口的感觉 全是眼泪啊~~~ )\n\n\n### 结语\n由于能力有限,存在的问题还有很多，请看到此文的人不吝赐教，感激不尽。\n\n特别鸣谢:[QC-L老师](https://github.com/QC-L)，[marryyan ](https://github.com/marryyan)的帮助.\n\n### 未完待续。。。\n\n##### 参考文章:[https://segmentfault.com/a/1190000010736797](https://segmentfault.com/a/1190000010736797)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"关于puppeteer","published":1,"updated":"2018-01-22T02:03:33.903Z","_id":"cjd2ddrd90003uqzzepar7z4r","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"介绍一下Puppeteer\"><a href=\"#介绍一下Puppeteer\" class=\"headerlink\" title=\"介绍一下Puppeteer\"></a>介绍一下Puppeteer</h3><blockquote>\n<p>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API（默认headless也就是无UI的chrome，也可以配置为有UI<br>有点类似于PhantomJS，但Puppeteer是Chrome官方团队进行维护的，前景更好。<br>使用Puppeteer，相当于同时具有Linux和Chrome的能力，应用场景会非常多。就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关</p>\n</blockquote>\n<h4 id=\"详情请看Puppeteer官方文档\"><a href=\"#详情请看Puppeteer官方文档\" class=\"headerlink\" title=\"详情请看Puppeteer官方文档\"></a><a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser\" target=\"_blank\" rel=\"noopener\">详情请看Puppeteer官方文档</a></h4><p>阅读以下内容，可以实现爬取<a href=\"http://pianke.me\" target=\"_blank\" rel=\"noopener\">片刻网</a>的首页数据。</p>\n<h4 id=\"Puppeteer-几个重要功能\"><a href=\"#Puppeteer-几个重要功能\" class=\"headerlink\" title=\"Puppeteer 几个重要功能\"></a>Puppeteer 几个重要功能</h4><ul>\n<li>可以抓取网站内容</li>\n<li>可以自动化表单提交、搜索网络内容、UI测试等</li>\n<li>获取网页生成的PDF、图片、视频等资源</li>\n</ul>\n<p>接下来的操作基于 Node 环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir test &amp;&amp; cd test</span><br><span class=\"line\">npm init</span><br><span class=\"line\">npm install puppeteer</span><br></pre></td></tr></table></figure>\n<!--上述命令墙内用户可能会有问题，建议科学上网-->\n<h4 id=\"Puppeteer-基本用法\"><a href=\"#Puppeteer-基本用法\" class=\"headerlink\" title=\"Puppeteer 基本用法\"></a>Puppeteer 基本用法</h4><p>1.使用<code>puppeteer.launch()</code>运行puppeteer，他会return一个promise，使用then方法获取browser实例，<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser\" target=\"_blank\" rel=\"noopener\">Browser API</a>.</p>\n<p>2.拿到browser实例后，通过<code>browser.newPage()</code>方法，可以得到一个page实例，<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-page\" target=\"_blank\" rel=\"noopener\">Page API</a>.</p>\n<p>3.使用<code>page.goto()</code>方法，<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">跳转至ES6标准入门</a>.</p>\n<p>4.在<code>page.evaluate()</code>方法中注册回调函数，并分析dom结构，从下图可以进行详细分析，并通过<code>document.querySelectorAll(&#39;ol li a&#39;)</code>拿到想要获取的内容.</p>\n<h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><p><a href=\"https://github.com/easy261925/Puppeteer\" target=\"_blank\" rel=\"noopener\">点我查看详细代码</a></p>\n<p>或 <code>git clone git@github.com:easy261925/Puppeteer.git</code></p>\n<h4 id=\"说一下我遇到坑吧\"><a href=\"#说一下我遇到坑吧\" class=\"headerlink\" title=\"说一下我遇到坑吧\"></a>说一下我遇到坑吧</h4><ol>\n<li>在配置环境的时候由于网络的原因，在安装 Puppetee 的时候可能会无法安装,<a href=\"https://pan.baidu.com/s/1dIMKjk\" target=\"_blank\" rel=\"noopener\"> node_modules 百度云下载地址 </a> 密码: bxhy. 不需要 <code>npm i</code>了, 下载完后直接使用<code>node getData.js</code>即可.</li>\n<li>代码的实现过程, 在看过网上很多关于 Puppeteer 技术文章和同学大力帮助之后，也算把想要的结果得到了，但是关于 async Promise await 等函数以及 ES6 Array<br>的新用法还不是特别清楚， 本人打算学习<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\"> 阮一峰老师的ES6 </a>之后, 在来详细补充其原理.</li>\n<li>爬取到的数据是通过 class 名，找到里面元素的 src/style/innerText，但是获取到的数据格式为:<code>img:[&#39;1.jpg&#39;,&#39;2.jpg&#39;];title:[ &#39;AAAAAAA&#39;,&#39;BBBBBBB&#39;]</code> 为了使用方便，我们对数据做了一些调整，让它变为<code>[{item1:[&#39;1.jpg&#39;,&#39;AAAAAAA&#39;]},{item1:[&#39;2.jpg&#39;,&#39;BBBBBBB&#39;]}]</code>,这样我们在铺到页面上时使用更加方便了.( 经历此过程也体验了一回写 API 接口的感觉 全是眼泪啊~~~ )</li>\n</ol>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>由于能力有限,存在的问题还有很多，请看到此文的人不吝赐教，感激不尽。</p>\n<p>特别鸣谢:<a href=\"https://github.com/QC-L\" target=\"_blank\" rel=\"noopener\">QC-L老师</a>，<a href=\"https://github.com/marryyan\" target=\"_blank\" rel=\"noopener\">marryyan </a>的帮助.</p>\n<h3 id=\"未完待续。。。\"><a href=\"#未完待续。。。\" class=\"headerlink\" title=\"未完待续。。。\"></a>未完待续。。。</h3><h5 id=\"参考文章-https-segmentfault-com-a-1190000010736797\"><a href=\"#参考文章-https-segmentfault-com-a-1190000010736797\" class=\"headerlink\" title=\"参考文章:https://segmentfault.com/a/1190000010736797\"></a>参考文章:<a href=\"https://segmentfault.com/a/1190000010736797\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000010736797</a></h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"介绍一下Puppeteer\"><a href=\"#介绍一下Puppeteer\" class=\"headerlink\" title=\"介绍一下Puppeteer\"></a>介绍一下Puppeteer</h3><blockquote>\n<p>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API（默认headless也就是无UI的chrome，也可以配置为有UI<br>有点类似于PhantomJS，但Puppeteer是Chrome官方团队进行维护的，前景更好。<br>使用Puppeteer，相当于同时具有Linux和Chrome的能力，应用场景会非常多。就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关</p>\n</blockquote>\n<h4 id=\"详情请看Puppeteer官方文档\"><a href=\"#详情请看Puppeteer官方文档\" class=\"headerlink\" title=\"详情请看Puppeteer官方文档\"></a><a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser\" target=\"_blank\" rel=\"noopener\">详情请看Puppeteer官方文档</a></h4><p>阅读以下内容，可以实现爬取<a href=\"http://pianke.me\" target=\"_blank\" rel=\"noopener\">片刻网</a>的首页数据。</p>\n<h4 id=\"Puppeteer-几个重要功能\"><a href=\"#Puppeteer-几个重要功能\" class=\"headerlink\" title=\"Puppeteer 几个重要功能\"></a>Puppeteer 几个重要功能</h4><ul>\n<li>可以抓取网站内容</li>\n<li>可以自动化表单提交、搜索网络内容、UI测试等</li>\n<li>获取网页生成的PDF、图片、视频等资源</li>\n</ul>\n<p>接下来的操作基于 Node 环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir test &amp;&amp; cd test</span><br><span class=\"line\">npm init</span><br><span class=\"line\">npm install puppeteer</span><br></pre></td></tr></table></figure>\n<!--上述命令墙内用户可能会有问题，建议科学上网-->\n<h4 id=\"Puppeteer-基本用法\"><a href=\"#Puppeteer-基本用法\" class=\"headerlink\" title=\"Puppeteer 基本用法\"></a>Puppeteer 基本用法</h4><p>1.使用<code>puppeteer.launch()</code>运行puppeteer，他会return一个promise，使用then方法获取browser实例，<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser\" target=\"_blank\" rel=\"noopener\">Browser API</a>.</p>\n<p>2.拿到browser实例后，通过<code>browser.newPage()</code>方法，可以得到一个page实例，<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-page\" target=\"_blank\" rel=\"noopener\">Page API</a>.</p>\n<p>3.使用<code>page.goto()</code>方法，<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">跳转至ES6标准入门</a>.</p>\n<p>4.在<code>page.evaluate()</code>方法中注册回调函数，并分析dom结构，从下图可以进行详细分析，并通过<code>document.querySelectorAll(&#39;ol li a&#39;)</code>拿到想要获取的内容.</p>\n<h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><p><a href=\"https://github.com/easy261925/Puppeteer\" target=\"_blank\" rel=\"noopener\">点我查看详细代码</a></p>\n<p>或 <code>git clone git@github.com:easy261925/Puppeteer.git</code></p>\n<h4 id=\"说一下我遇到坑吧\"><a href=\"#说一下我遇到坑吧\" class=\"headerlink\" title=\"说一下我遇到坑吧\"></a>说一下我遇到坑吧</h4><ol>\n<li>在配置环境的时候由于网络的原因，在安装 Puppetee 的时候可能会无法安装,<a href=\"https://pan.baidu.com/s/1dIMKjk\" target=\"_blank\" rel=\"noopener\"> node_modules 百度云下载地址 </a> 密码: bxhy. 不需要 <code>npm i</code>了, 下载完后直接使用<code>node getData.js</code>即可.</li>\n<li>代码的实现过程, 在看过网上很多关于 Puppeteer 技术文章和同学大力帮助之后，也算把想要的结果得到了，但是关于 async Promise await 等函数以及 ES6 Array<br>的新用法还不是特别清楚， 本人打算学习<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\"> 阮一峰老师的ES6 </a>之后, 在来详细补充其原理.</li>\n<li>爬取到的数据是通过 class 名，找到里面元素的 src/style/innerText，但是获取到的数据格式为:<code>img:[&#39;1.jpg&#39;,&#39;2.jpg&#39;];title:[ &#39;AAAAAAA&#39;,&#39;BBBBBBB&#39;]</code> 为了使用方便，我们对数据做了一些调整，让它变为<code>[{item1:[&#39;1.jpg&#39;,&#39;AAAAAAA&#39;]},{item1:[&#39;2.jpg&#39;,&#39;BBBBBBB&#39;]}]</code>,这样我们在铺到页面上时使用更加方便了.( 经历此过程也体验了一回写 API 接口的感觉 全是眼泪啊~~~ )</li>\n</ol>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>由于能力有限,存在的问题还有很多，请看到此文的人不吝赐教，感激不尽。</p>\n<p>特别鸣谢:<a href=\"https://github.com/QC-L\" target=\"_blank\" rel=\"noopener\">QC-L老师</a>，<a href=\"https://github.com/marryyan\" target=\"_blank\" rel=\"noopener\">marryyan </a>的帮助.</p>\n<h3 id=\"未完待续。。。\"><a href=\"#未完待续。。。\" class=\"headerlink\" title=\"未完待续。。。\"></a>未完待续。。。</h3><h5 id=\"参考文章-https-segmentfault-com-a-1190000010736797\"><a href=\"#参考文章-https-segmentfault-com-a-1190000010736797\" class=\"headerlink\" title=\"参考文章:https://segmentfault.com/a/1190000010736797\"></a>参考文章:<a href=\"https://segmentfault.com/a/1190000010736797\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000010736797</a></h5>"},{"title":"关于Array的ES5部分方法的实现","date":"2018-01-13T05:30:47.000Z","_content":"# 关于Array的ES5部分方法的实现\n\n> forEach\n\n```js\nif (typeof Array.prototype.forEach !== &quot;function&quot;) {\n    Array.prototype.myForEach = function (fn) {\n        for (var i = 0; i &lt; this.length; i++) {\n            // console.log(Object.prototype);\n            // console.log(Object.prototype.hasOwnProperty.call(this, i))\n            if (typeof fn === &quot;function&quot;) {\n                if (Object.prototype.hasOwnProperty.call(this, i)) {\n                    fn.call(this,this[i], i, this);\n                }\n            }\n            else {\n                throw new Error(fn + &quot; is not a function&quot;);\n            }\n        }\n    }\n }\nvar array = [1, 2, 3, 4, 5, 6];\narray.myForEach(function (value, index, array) {\n    console.log(value);\n    console.log(index);\n    console.log(array);\n})\n```\n> map\n\n```js\nif (typeof Array.prototype.map !== &quot;function&quot;) {\nArray.prototype.myMap = function (fn) {\n        var temp = [];\n        for (var i = 0; i &lt; this.length; i++) {\n            if (typeof fn === &quot;function&quot;) {\n                if (Object.prototype.hasOwnProperty.call(this, i)) {\n                    temp.push(fn.call(this, this[i], i, this));\n                }\n            } else {\n                throw new Error(fn + &quot; is not a function&quot;);\n            }\n        }\n        return temp;\n    }\n}\nvar arr1 = [1, 2, 3, 4, 5, 6];\nvar arr2 = arr1.myMap(function (value) {\n    return value * 2;\n})\nconsole.log(arr2);\n```\n\n> filter\n\n```js\nif(typeof Array.prototype.filter !== &quot;function&quot;){\n\tArray.prototype.myFilter = function(fn){\n        var temp = [];\n        for(var i=0;i&lt;this.length;i++){\n            if(typeof fn === &quot;function&quot;){\n                if(Object.prototype.hasOwnProperty.call(this,i)){\n                    if(fn.call(this,this[i])){\n                        temp.push(this[i]);\n                    }\n                }\n            }\n        }\n        return temp;\n    }\n }\nvar arr1 = [1,2,3,4,45,89,123,45,8,10];\nvar arr2 = arr1.myFilter(function(value){\n    return value &lt; 5;\n})\nconsole.log(arr2);\n```\n\n","source":"_posts/关于Array的ES5部分方法的实现.md","raw":"---\ntitle: 关于Array的ES5部分方法的实现\ndate: 2018-01-13 13:30:47\ntags:\n---\n# 关于Array的ES5部分方法的实现\n\n> forEach\n\n```js\nif (typeof Array.prototype.forEach !== &quot;function&quot;) {\n    Array.prototype.myForEach = function (fn) {\n        for (var i = 0; i &lt; this.length; i++) {\n            // console.log(Object.prototype);\n            // console.log(Object.prototype.hasOwnProperty.call(this, i))\n            if (typeof fn === &quot;function&quot;) {\n                if (Object.prototype.hasOwnProperty.call(this, i)) {\n                    fn.call(this,this[i], i, this);\n                }\n            }\n            else {\n                throw new Error(fn + &quot; is not a function&quot;);\n            }\n        }\n    }\n }\nvar array = [1, 2, 3, 4, 5, 6];\narray.myForEach(function (value, index, array) {\n    console.log(value);\n    console.log(index);\n    console.log(array);\n})\n```\n> map\n\n```js\nif (typeof Array.prototype.map !== &quot;function&quot;) {\nArray.prototype.myMap = function (fn) {\n        var temp = [];\n        for (var i = 0; i &lt; this.length; i++) {\n            if (typeof fn === &quot;function&quot;) {\n                if (Object.prototype.hasOwnProperty.call(this, i)) {\n                    temp.push(fn.call(this, this[i], i, this));\n                }\n            } else {\n                throw new Error(fn + &quot; is not a function&quot;);\n            }\n        }\n        return temp;\n    }\n}\nvar arr1 = [1, 2, 3, 4, 5, 6];\nvar arr2 = arr1.myMap(function (value) {\n    return value * 2;\n})\nconsole.log(arr2);\n```\n\n> filter\n\n```js\nif(typeof Array.prototype.filter !== &quot;function&quot;){\n\tArray.prototype.myFilter = function(fn){\n        var temp = [];\n        for(var i=0;i&lt;this.length;i++){\n            if(typeof fn === &quot;function&quot;){\n                if(Object.prototype.hasOwnProperty.call(this,i)){\n                    if(fn.call(this,this[i])){\n                        temp.push(this[i]);\n                    }\n                }\n            }\n        }\n        return temp;\n    }\n }\nvar arr1 = [1,2,3,4,45,89,123,45,8,10];\nvar arr2 = arr1.myFilter(function(value){\n    return value &lt; 5;\n})\nconsole.log(arr2);\n```\n\n","slug":"关于Array的ES5部分方法的实现","published":1,"updated":"2018-01-31T12:55:27.943Z","_id":"cjd2ddrdb0004uqzzfuu5omdb","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"关于Array的ES5部分方法的实现\"><a href=\"#关于Array的ES5部分方法的实现\" class=\"headerlink\" title=\"关于Array的ES5部分方法的实现\"></a>关于Array的ES5部分方法的实现</h1><blockquote>\n<p>forEach</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.forEach !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.myForEach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// console.log(Object.prototype);</span></span><br><span class=\"line\">            <span class=\"comment\">// console.log(Object.prototype.hasOwnProperty.call(this, i))</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>, i)) &#123;</span><br><span class=\"line\">                    fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i], i, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(fn + &amp;quot; is not a <span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;);</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\"> &#125;</span></span><br><span class=\"line\">var array = [1, 2, 3, 4, 5, 6];</span><br><span class=\"line\">array.myForEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, index, array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>map</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.map !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.myMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>, i)) &#123;</span><br><span class=\"line\">                    temp.push(fn.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>[i], i, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(fn + &amp;quot; is not a <span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;);</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">return</span> <span class=\"title\">temp</span>;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\">var arr1 = [1, 2, 3, 4, 5, 6];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.myMap(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>filter</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.filter !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.myFilter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&amp;lt;<span class=\"keyword\">this</span>.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>,i))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i]))&#123;</span><br><span class=\"line\">                        temp.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">45</span>,<span class=\"number\">89</span>,<span class=\"number\">123</span>,<span class=\"number\">45</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.myFilter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value &amp;lt; <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于Array的ES5部分方法的实现\"><a href=\"#关于Array的ES5部分方法的实现\" class=\"headerlink\" title=\"关于Array的ES5部分方法的实现\"></a>关于Array的ES5部分方法的实现</h1><blockquote>\n<p>forEach</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.forEach !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.myForEach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// console.log(Object.prototype);</span></span><br><span class=\"line\">            <span class=\"comment\">// console.log(Object.prototype.hasOwnProperty.call(this, i))</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>, i)) &#123;</span><br><span class=\"line\">                    fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i], i, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(fn + &amp;quot; is not a <span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;);</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\"> &#125;</span></span><br><span class=\"line\">var array = [1, 2, 3, 4, 5, 6];</span><br><span class=\"line\">array.myForEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, index, array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>map</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.map !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.myMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>, i)) &#123;</span><br><span class=\"line\">                    temp.push(fn.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>[i], i, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(fn + &amp;quot; is not a <span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;);</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">return</span> <span class=\"title\">temp</span>;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\">var arr1 = [1, 2, 3, 4, 5, 6];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.myMap(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>filter</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.filter !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.myFilter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&amp;lt;<span class=\"keyword\">this</span>.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>,i))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i]))&#123;</span><br><span class=\"line\">                        temp.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">45</span>,<span class=\"number\">89</span>,<span class=\"number\">123</span>,<span class=\"number\">45</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.myFilter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value &amp;lt; <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>\n"},{"title":"WebSocket：5分钟从入门到精通","date":"2018-01-12T00:47:35.000Z","_content":"一、内容概览\nWebSocket的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了WebSocket如何建立连接、交换数据的细节，以及数据帧的格式。此外，还简要介绍了针对WebSocket的安全攻击，以及协议是如何抵御类似攻击的。\n\n二、什么是WebSocket\nHTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。\n\n对大部分web开发者来说，上面这段描述有点枯燥，其实只要记住几点：\n\nWebSocket可以在浏览器里使用\n支持双向通信\n使用很简单\n1、有哪些优点\n说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。\n\n支持双向通信，实时性更强。\n更好的二进制支持。\n较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。\n支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）\n对于后面两点，没有研究过WebSocket协议规范的同学可能理解起来不够直观，但不影响对WebSocket的学习和使用。\n\n2、需要学习哪些东西\n对网络应用层协议的学习来说，最重要的往往就是连接建立过程、数据交换教程。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。\n\n下文主要围绕下面几点展开：\n\n如何建立连接\n如何交换数据\n数据帧格式\n如何维持连接\n三、入门例子\n在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了WebSocket服务端、WebSocket客户端（网页端）。完整代码可以在 这里 找到。\n\n这里服务端用了ws这个库。相比大家熟悉的socket.io，ws实现更轻量，更适合学习的目的。\n\n1、服务端\n代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。\n\nvar app = require('express')();\nvar server = require('http').Server(app);\nvar WebSocket = require('ws');\n\nvar wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n    console.log('server: receive connection.');\n    \n    ws.on('message', function incoming(message) {\n        console.log('server: received: %s', message);\n    });\n\n    ws.send('world');\n});\n\napp.get('/', function (req, res) {\n  res.sendfile(__dirname + '/index.html');\n});\n\napp.listen(3000);\n2、客户端\n代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。\n\n<script>\n  var ws = new WebSocket('ws://localhost:8080');\n  ws.onopen = function () {\n    console.log('ws onopen');\n    ws.send('from client: hello');\n  };\n  ws.onmessage = function (e) {\n    console.log('ws onmessage');\n    console.log('from server: ' + e.data);\n  };\n</script>\n3、运行结果\n可分别查看服务端、客户端的日志，这里不展开。\n\n服务端输出：\n\nserver: receive connection.\nserver: received hello\n客户端输出：\n\nclient: ws connection is open\nclient: received world\n四、如何建立连接\n前面提到，WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。\n\n1、客户端：申请协议升级\n首先，客户端发起协议升级请求。可以看到，采用的是标准的HTTP报文格式，且只支持GET方法。\n\nGET / HTTP/1.1\nHost: localhost:8080\nOrigin: http://127.0.0.1:3000\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Version: 13\nSec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==\n重点请求首部意义如下：\n\nConnection: Upgrade：表示要升级协议\nUpgrade: websocket：表示要升级到websocket协议。\nSec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。\nSec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。\n注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。\n\n2、服务端：响应协议升级\n服务端返回内容如下，状态代码101表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。\n\nHTTP/1.1 101 Switching Protocols\nConnection:Upgrade\nUpgrade: websocket\nSec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=\n\n备注：每个header都以\\r\\n结尾，并且最后一行加上一个额外的空行\\r\\n。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。\n\n3、Sec-WebSocket-Accept的计算\nSec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。\n\n计算公式为：\n\n将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。\n通过SHA1计算出摘要，并转成base64字符串。\n伪代码如下：\n\n>toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )\n验证下前面的返回结果：\n\nconst crypto = require('crypto');\nconst magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\nconst secWebSocketKey = 'w4v7O6xFTi36lq3RNcgctw==';\n\nlet secWebSocketAccept = crypto.createHash('sha1')\n\t.update(secWebSocketKey + magic)\n\t.digest('base64');\n\nconsole.log(secWebSocketAccept);\n// Oy4NRAQ13jhfONC7bP8dTKb4PTU=\n五、数据帧格式\n客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。\n\nWebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。\n\n发送端：将消息切割成多个帧，并发送给服务端；\n接收端：接收消息帧，并将关联的帧重新组装成完整的消息；\n本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455 5.2节 。\n\n1、数据帧格式概览\n下面给出了WebSocket数据帧的统一格式。熟悉TCP/IP协议的同学对这样的图应该不陌生。\n\n从左到右，单位是比特。比如FIN、RSV1各占据1比特，opcode占据4比特。\n内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）\n 2、数据帧格式详解\n针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。\n\nFIN：1个比特。\n\n如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。\n\nRSV1, RSV2, RSV3：各占1个比特。\n\n一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。\n\nOpcode: 4个比特。\n\n操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：\n\n%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。\n%x1：表示这是一个文本帧（frame）\n%x2：表示这是一个二进制帧（frame）\n%x3-7：保留的操作代码，用于后续定义的非控制帧。\n%x8：表示连接断开。\n%x9：表示这是一个ping操作。\n%xA：表示这是一个pong操作。\n%xB-F：保留的操作代码，用于后续定义的控制帧。\nMask: 1个比特。\n\n表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。\n\n如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。\n\n如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。\n\n掩码的算法、用途在下一小节讲解。\n\nPayload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。\n\n假设数Payload length === x，如果\n\nx为0~126：数据的长度为x字节。\nx为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。\nx为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。\n此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。\n\nMasking-key：0或4字节（32位）\n\n所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。\n\n备注：载荷数据的长度，不包括mask key的长度。\n\nPayload data：(x+y) 字节\n\n载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。\n\n扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。\n\n应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。\n\n3、掩码算法\n掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：\n\n首先，假设：\n\noriginal-octet-i：为原始数据的第i字节。\ntransformed-octet-i：为转换后的数据的第i字节。\nj：为i mod 4的结果。\nmasking-key-octet-j：为mask key第j字节。\n算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。\n\nj = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j\n\n六、数据传递\n一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。\n\nWebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。\n\n1、数据分片\nWebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。\n\nFIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。\n\n此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。\n\n2、数据分片例子\n直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。\n\n第一条消息\n\nFIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。\n\n第二条消息\n\nFIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。\nFIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。\nFIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。\nClient: FIN=1, opcode=0x1, msg=\"hello\"\nServer: (process complete message immediately) Hi.\nClient: FIN=0, opcode=0x1, msg=\"and a\"\nServer: (listening, new message containing text started)\nClient: FIN=0, opcode=0x0, msg=\"happy new\"\nServer: (listening, payload concatenated to previous message)\nClient: FIN=1, opcode=0x0, msg=\"year!\"\nServer: (process complete message) Happy new year to you too!\n七、连接保持+心跳\nWebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。\n\n但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。\n\n发送方->接收方：ping\n接收方->发送方：pong\nping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。\n\n举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）\n\nws.ping('', false, true);\n八、Sec-WebSocket-Key/Accept的作用\n前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。\n\n作用大致归纳如下：\n\n避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）\n确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）\n用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）\n可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。\nSec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。\n强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。\n\n九、数据掩码的作用\nWebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。\n\n那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。\n\n答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。\n\n1、代理缓存污染攻击\n下面摘自2010年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。\n\n“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”\n\n[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, \"Talking to Yourself for Fun and Profit\", 2010,\n\n在正式描述攻击步骤之前，我们假设有如下参与者：\n\n攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）\n受害者、受害者想要访问的资源（简称“正义资源”）\n受害者实际想要访问的服务器（简称“正义服务器”）\n中间代理服务器\n攻击步骤一：\n\n攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。\n协议升级请求 实际到达 代理服务器。\n代理服务器 将协议升级请求转发到 邪恶服务器。\n邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。\n由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。\n\n攻击步骤二：\n\n攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）\n请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。\n代理服务器 向 邪恶服务器 请求 邪恶资源。\n邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。\n到这里，受害者可以登场了：\n\n受害者 通过 代理服务器 访问 正义服务器 的 正义资源。\n代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。\n代理服务器 将 邪恶资源 返回给 受害者。\n受害者 卒。\n附：前面提到的精心构造的“HTTP请求报文”。\n\nClient → Server:\nPOST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: <connection-key>\nServer → Client:\nHTTP/1.1 200 OK\nSec-WebSocket-Accept: <connection-key>\n2、当前解决方案\n最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。\n\n需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。\n\n但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。\n\n十、写在后面\nWebSocket可写的东西还挺多，比如WebSocket扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。\n\n篇幅所限，这里先不展开，感兴趣的同学可以留言交流。文章如有错漏，敬请指出","source":"_posts/WebSocket：5分钟从入门到精通.md","raw":"---\ntitle: WebSocket：5分钟从入门到精通\ndate: 2018-01-12 08:47:35\ntags:\n---\n一、内容概览\nWebSocket的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了WebSocket如何建立连接、交换数据的细节，以及数据帧的格式。此外，还简要介绍了针对WebSocket的安全攻击，以及协议是如何抵御类似攻击的。\n\n二、什么是WebSocket\nHTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。\n\n对大部分web开发者来说，上面这段描述有点枯燥，其实只要记住几点：\n\nWebSocket可以在浏览器里使用\n支持双向通信\n使用很简单\n1、有哪些优点\n说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。\n\n支持双向通信，实时性更强。\n更好的二进制支持。\n较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。\n支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）\n对于后面两点，没有研究过WebSocket协议规范的同学可能理解起来不够直观，但不影响对WebSocket的学习和使用。\n\n2、需要学习哪些东西\n对网络应用层协议的学习来说，最重要的往往就是连接建立过程、数据交换教程。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。\n\n下文主要围绕下面几点展开：\n\n如何建立连接\n如何交换数据\n数据帧格式\n如何维持连接\n三、入门例子\n在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了WebSocket服务端、WebSocket客户端（网页端）。完整代码可以在 这里 找到。\n\n这里服务端用了ws这个库。相比大家熟悉的socket.io，ws实现更轻量，更适合学习的目的。\n\n1、服务端\n代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。\n\nvar app = require('express')();\nvar server = require('http').Server(app);\nvar WebSocket = require('ws');\n\nvar wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n    console.log('server: receive connection.');\n    \n    ws.on('message', function incoming(message) {\n        console.log('server: received: %s', message);\n    });\n\n    ws.send('world');\n});\n\napp.get('/', function (req, res) {\n  res.sendfile(__dirname + '/index.html');\n});\n\napp.listen(3000);\n2、客户端\n代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。\n\n<script>\n  var ws = new WebSocket('ws://localhost:8080');\n  ws.onopen = function () {\n    console.log('ws onopen');\n    ws.send('from client: hello');\n  };\n  ws.onmessage = function (e) {\n    console.log('ws onmessage');\n    console.log('from server: ' + e.data);\n  };\n</script>\n3、运行结果\n可分别查看服务端、客户端的日志，这里不展开。\n\n服务端输出：\n\nserver: receive connection.\nserver: received hello\n客户端输出：\n\nclient: ws connection is open\nclient: received world\n四、如何建立连接\n前面提到，WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。\n\n1、客户端：申请协议升级\n首先，客户端发起协议升级请求。可以看到，采用的是标准的HTTP报文格式，且只支持GET方法。\n\nGET / HTTP/1.1\nHost: localhost:8080\nOrigin: http://127.0.0.1:3000\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Version: 13\nSec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==\n重点请求首部意义如下：\n\nConnection: Upgrade：表示要升级协议\nUpgrade: websocket：表示要升级到websocket协议。\nSec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。\nSec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。\n注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。\n\n2、服务端：响应协议升级\n服务端返回内容如下，状态代码101表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。\n\nHTTP/1.1 101 Switching Protocols\nConnection:Upgrade\nUpgrade: websocket\nSec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=\n\n备注：每个header都以\\r\\n结尾，并且最后一行加上一个额外的空行\\r\\n。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。\n\n3、Sec-WebSocket-Accept的计算\nSec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。\n\n计算公式为：\n\n将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。\n通过SHA1计算出摘要，并转成base64字符串。\n伪代码如下：\n\n>toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )\n验证下前面的返回结果：\n\nconst crypto = require('crypto');\nconst magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\nconst secWebSocketKey = 'w4v7O6xFTi36lq3RNcgctw==';\n\nlet secWebSocketAccept = crypto.createHash('sha1')\n\t.update(secWebSocketKey + magic)\n\t.digest('base64');\n\nconsole.log(secWebSocketAccept);\n// Oy4NRAQ13jhfONC7bP8dTKb4PTU=\n五、数据帧格式\n客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。\n\nWebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。\n\n发送端：将消息切割成多个帧，并发送给服务端；\n接收端：接收消息帧，并将关联的帧重新组装成完整的消息；\n本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455 5.2节 。\n\n1、数据帧格式概览\n下面给出了WebSocket数据帧的统一格式。熟悉TCP/IP协议的同学对这样的图应该不陌生。\n\n从左到右，单位是比特。比如FIN、RSV1各占据1比特，opcode占据4比特。\n内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）\n 2、数据帧格式详解\n针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。\n\nFIN：1个比特。\n\n如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。\n\nRSV1, RSV2, RSV3：各占1个比特。\n\n一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。\n\nOpcode: 4个比特。\n\n操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：\n\n%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。\n%x1：表示这是一个文本帧（frame）\n%x2：表示这是一个二进制帧（frame）\n%x3-7：保留的操作代码，用于后续定义的非控制帧。\n%x8：表示连接断开。\n%x9：表示这是一个ping操作。\n%xA：表示这是一个pong操作。\n%xB-F：保留的操作代码，用于后续定义的控制帧。\nMask: 1个比特。\n\n表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。\n\n如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。\n\n如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。\n\n掩码的算法、用途在下一小节讲解。\n\nPayload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。\n\n假设数Payload length === x，如果\n\nx为0~126：数据的长度为x字节。\nx为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。\nx为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。\n此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。\n\nMasking-key：0或4字节（32位）\n\n所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。\n\n备注：载荷数据的长度，不包括mask key的长度。\n\nPayload data：(x+y) 字节\n\n载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。\n\n扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。\n\n应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。\n\n3、掩码算法\n掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：\n\n首先，假设：\n\noriginal-octet-i：为原始数据的第i字节。\ntransformed-octet-i：为转换后的数据的第i字节。\nj：为i mod 4的结果。\nmasking-key-octet-j：为mask key第j字节。\n算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。\n\nj = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j\n\n六、数据传递\n一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。\n\nWebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。\n\n1、数据分片\nWebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。\n\nFIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。\n\n此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。\n\n2、数据分片例子\n直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。\n\n第一条消息\n\nFIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。\n\n第二条消息\n\nFIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。\nFIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。\nFIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。\nClient: FIN=1, opcode=0x1, msg=\"hello\"\nServer: (process complete message immediately) Hi.\nClient: FIN=0, opcode=0x1, msg=\"and a\"\nServer: (listening, new message containing text started)\nClient: FIN=0, opcode=0x0, msg=\"happy new\"\nServer: (listening, payload concatenated to previous message)\nClient: FIN=1, opcode=0x0, msg=\"year!\"\nServer: (process complete message) Happy new year to you too!\n七、连接保持+心跳\nWebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。\n\n但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。\n\n发送方->接收方：ping\n接收方->发送方：pong\nping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。\n\n举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）\n\nws.ping('', false, true);\n八、Sec-WebSocket-Key/Accept的作用\n前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。\n\n作用大致归纳如下：\n\n避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）\n确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）\n用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）\n可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。\nSec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。\n强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。\n\n九、数据掩码的作用\nWebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。\n\n那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。\n\n答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。\n\n1、代理缓存污染攻击\n下面摘自2010年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。\n\n“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”\n\n[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, \"Talking to Yourself for Fun and Profit\", 2010,\n\n在正式描述攻击步骤之前，我们假设有如下参与者：\n\n攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）\n受害者、受害者想要访问的资源（简称“正义资源”）\n受害者实际想要访问的服务器（简称“正义服务器”）\n中间代理服务器\n攻击步骤一：\n\n攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。\n协议升级请求 实际到达 代理服务器。\n代理服务器 将协议升级请求转发到 邪恶服务器。\n邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。\n由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。\n\n攻击步骤二：\n\n攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）\n请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。\n代理服务器 向 邪恶服务器 请求 邪恶资源。\n邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。\n到这里，受害者可以登场了：\n\n受害者 通过 代理服务器 访问 正义服务器 的 正义资源。\n代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。\n代理服务器 将 邪恶资源 返回给 受害者。\n受害者 卒。\n附：前面提到的精心构造的“HTTP请求报文”。\n\nClient → Server:\nPOST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: <connection-key>\nServer → Client:\nHTTP/1.1 200 OK\nSec-WebSocket-Accept: <connection-key>\n2、当前解决方案\n最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。\n\n需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。\n\n但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。\n\n十、写在后面\nWebSocket可写的东西还挺多，比如WebSocket扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。\n\n篇幅所限，这里先不展开，感兴趣的同学可以留言交流。文章如有错漏，敬请指出","slug":"WebSocket：5分钟从入门到精通","published":1,"updated":"2018-01-12T05:06:25.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd2ddrdg0007uqzzes4sqawn","content":"<p>一、内容概览<br>WebSocket的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了WebSocket如何建立连接、交换数据的细节，以及数据帧的格式。此外，还简要介绍了针对WebSocket的安全攻击，以及协议是如何抵御类似攻击的。</p>\n<p>二、什么是WebSocket<br>HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。</p>\n<p>对大部分web开发者来说，上面这段描述有点枯燥，其实只要记住几点：</p>\n<p>WebSocket可以在浏览器里使用<br>支持双向通信<br>使用很简单<br>1、有哪些优点<br>说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。</p>\n<p>支持双向通信，实时性更强。<br>更好的二进制支持。<br>较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。<br>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）<br>对于后面两点，没有研究过WebSocket协议规范的同学可能理解起来不够直观，但不影响对WebSocket的学习和使用。</p>\n<p>2、需要学习哪些东西<br>对网络应用层协议的学习来说，最重要的往往就是连接建立过程、数据交换教程。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。</p>\n<p>下文主要围绕下面几点展开：</p>\n<p>如何建立连接<br>如何交换数据<br>数据帧格式<br>如何维持连接<br>三、入门例子<br>在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了WebSocket服务端、WebSocket客户端（网页端）。完整代码可以在 这里 找到。</p>\n<p>这里服务端用了ws这个库。相比大家熟悉的socket.io，ws实现更轻量，更适合学习的目的。</p>\n<p>1、服务端<br>代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。</p>\n<p>var app = require(‘express’)();<br>var server = require(‘http’).Server(app);<br>var WebSocket = require(‘ws’);</p>\n<p>var wss = new WebSocket.Server({ port: 8080 });</p>\n<p>wss.on(‘connection’, function connection(ws) {<br>    console.log(‘server: receive connection.’);</p>\n<pre><code>ws.on(&apos;message&apos;, function incoming(message) {\n    console.log(&apos;server: received: %s&apos;, message);\n});\n\nws.send(&apos;world&apos;);\n</code></pre><p>});</p>\n<p>app.get(‘/‘, function (req, res) {<br>  res.sendfile(__dirname + ‘/index.html’);<br>});</p>\n<p>app.listen(3000);<br>2、客户端<br>代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。</p>\n<p><script><br>  var ws = new WebSocket(‘ws://localhost:8080’);<br>  ws.onopen = function () {<br>    console.log(‘ws onopen’);<br>    ws.send(‘from client: hello’);<br>  };<br>  ws.onmessage = function (e) {<br>    console.log(‘ws onmessage’);<br>    console.log(‘from server: ‘ + e.data);<br>  };<br></script><br>3、运行结果<br>可分别查看服务端、客户端的日志，这里不展开。</p>\n<p>服务端输出：</p>\n<p>server: receive connection.<br>server: received hello<br>客户端输出：</p>\n<p>client: ws connection is open<br>client: received world<br>四、如何建立连接<br>前面提到，WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。</p>\n<p>1、客户端：申请协议升级<br>首先，客户端发起协议升级请求。可以看到，采用的是标准的HTTP报文格式，且只支持GET方法。</p>\n<p>GET / HTTP/1.1<br>Host: localhost:8080<br>Origin: <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a><br>Connection: Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Version: 13<br>Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==<br>重点请求首部意义如下：</p>\n<p>Connection: Upgrade：表示要升级协议<br>Upgrade: websocket：表示要升级到websocket协议。<br>Sec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。<br>Sec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。<br>注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。</p>\n<p>2、服务端：响应协议升级<br>服务端返回内容如下，状态代码101表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p>\n<p>HTTP/1.1 101 Switching Protocols<br>Connection:Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</p>\n<p>备注：每个header都以\\r\\n结尾，并且最后一行加上一个额外的空行\\r\\n。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。</p>\n<p>3、Sec-WebSocket-Accept的计算<br>Sec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。</p>\n<p>计算公式为：</p>\n<p>将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。<br>通过SHA1计算出摘要，并转成base64字符串。<br>伪代码如下：</p>\n<blockquote>\n<p>toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )<br>验证下前面的返回结果：</p>\n</blockquote>\n<p>const crypto = require(‘crypto’);<br>const magic = ‘258EAFA5-E914-47DA-95CA-C5AB0DC85B11’;<br>const secWebSocketKey = ‘w4v7O6xFTi36lq3RNcgctw==’;</p>\n<p>let secWebSocketAccept = crypto.createHash(‘sha1’)<br>    .update(secWebSocketKey + magic)<br>    .digest(‘base64’);</p>\n<p>console.log(secWebSocketAccept);<br>// Oy4NRAQ13jhfONC7bP8dTKb4PTU=<br>五、数据帧格式<br>客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。</p>\n<p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p>\n<p>发送端：将消息切割成多个帧，并发送给服务端；<br>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；<br>本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455 5.2节 。</p>\n<p>1、数据帧格式概览<br>下面给出了WebSocket数据帧的统一格式。熟悉TCP/IP协议的同学对这样的图应该不陌生。</p>\n<p>从左到右，单位是比特。比如FIN、RSV1各占据1比特，opcode占据4比特。<br>内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）<br> 2、数据帧格式详解<br>针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。</p>\n<p>FIN：1个比特。</p>\n<p>如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>\n<p>RSV1, RSV2, RSV3：各占1个比特。</p>\n<p>一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p>\n<p>Opcode: 4个比特。</p>\n<p>操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p>\n<p>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。<br>%x1：表示这是一个文本帧（frame）<br>%x2：表示这是一个二进制帧（frame）<br>%x3-7：保留的操作代码，用于后续定义的非控制帧。<br>%x8：表示连接断开。<br>%x9：表示这是一个ping操作。<br>%xA：表示这是一个pong操作。<br>%xB-F：保留的操作代码，用于后续定义的控制帧。<br>Mask: 1个比特。</p>\n<p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p>\n<p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p>\n<p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p>\n<p>掩码的算法、用途在下一小节讲解。</p>\n<p>Payload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。</p>\n<p>假设数Payload length === x，如果</p>\n<p>x为0~126：数据的长度为x字节。<br>x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。<br>x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。<br>此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p>\n<p>Masking-key：0或4字节（32位）</p>\n<p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p>\n<p>备注：载荷数据的长度，不包括mask key的长度。</p>\n<p>Payload data：(x+y) 字节</p>\n<p>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</p>\n<p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p>\n<p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p>\n<p>3、掩码算法<br>掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p>\n<p>首先，假设：</p>\n<p>original-octet-i：为原始数据的第i字节。<br>transformed-octet-i：为转换后的数据的第i字节。<br>j：为i mod 4的结果。<br>masking-key-octet-j：为mask key第j字节。<br>算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>\n<p>j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j</p>\n<p>六、数据传递<br>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p>\n<p>WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>\n<p>1、数据分片<br>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。</p>\n<p>FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p>\n<p>此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>\n<p>2、数据分片例子<br>直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>\n<p>第一条消息</p>\n<p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p>\n<p>第二条消息</p>\n<p>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。<br>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。<br>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。<br>Client: FIN=1, opcode=0x1, msg=”hello”<br>Server: (process complete message immediately) Hi.<br>Client: FIN=0, opcode=0x1, msg=”and a”<br>Server: (listening, new message containing text started)<br>Client: FIN=0, opcode=0x0, msg=”happy new”<br>Server: (listening, payload concatenated to previous message)<br>Client: FIN=1, opcode=0x0, msg=”year!”<br>Server: (process complete message) Happy new year to you too!<br>七、连接保持+心跳<br>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p>\n<p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>\n<p>发送方-&gt;接收方：ping<br>接收方-&gt;发送方：pong<br>ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。</p>\n<p>举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）</p>\n<p>ws.ping(‘’, false, true);<br>八、Sec-WebSocket-Key/Accept的作用<br>前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p>\n<p>作用大致归纳如下：</p>\n<p>避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）<br>确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）<br>用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）<br>可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。<br>Sec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。<br>强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。</p>\n<p>九、数据掩码的作用<br>WebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p>\n<p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p>\n<p>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p>\n<p>1、代理缓存污染攻击<br>下面摘自2010年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。</p>\n<p>“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”</p>\n<p>[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, “Talking to Yourself for Fun and Profit”, 2010,</p>\n<p>在正式描述攻击步骤之前，我们假设有如下参与者：</p>\n<p>攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）<br>受害者、受害者想要访问的资源（简称“正义资源”）<br>受害者实际想要访问的服务器（简称“正义服务器”）<br>中间代理服务器<br>攻击步骤一：</p>\n<p>攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。<br>协议升级请求 实际到达 代理服务器。<br>代理服务器 将协议升级请求转发到 邪恶服务器。<br>邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。<br>由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。</p>\n<p>攻击步骤二：</p>\n<p>攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）<br>请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。<br>代理服务器 向 邪恶服务器 请求 邪恶资源。<br>邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。<br>到这里，受害者可以登场了：</p>\n<p>受害者 通过 代理服务器 访问 正义服务器 的 正义资源。<br>代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。<br>代理服务器 将 邪恶资源 返回给 受害者。<br>受害者 卒。<br>附：前面提到的精心构造的“HTTP请求报文”。</p>\n<p>Client → Server:<br>POST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: <connection-key><br>Server → Client:<br>HTTP/1.1 200 OK<br>Sec-WebSocket-Accept: <connection-key><br>2、当前解决方案<br>最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。</connection-key></connection-key></p>\n<p>需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。</p>\n<p>但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。</p>\n<p>十、写在后面<br>WebSocket可写的东西还挺多，比如WebSocket扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。</p>\n<p>篇幅所限，这里先不展开，感兴趣的同学可以留言交流。文章如有错漏，敬请指出</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、内容概览<br>WebSocket的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了WebSocket如何建立连接、交换数据的细节，以及数据帧的格式。此外，还简要介绍了针对WebSocket的安全攻击，以及协议是如何抵御类似攻击的。</p>\n<p>二、什么是WebSocket<br>HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。</p>\n<p>对大部分web开发者来说，上面这段描述有点枯燥，其实只要记住几点：</p>\n<p>WebSocket可以在浏览器里使用<br>支持双向通信<br>使用很简单<br>1、有哪些优点<br>说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。</p>\n<p>支持双向通信，实时性更强。<br>更好的二进制支持。<br>较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。<br>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）<br>对于后面两点，没有研究过WebSocket协议规范的同学可能理解起来不够直观，但不影响对WebSocket的学习和使用。</p>\n<p>2、需要学习哪些东西<br>对网络应用层协议的学习来说，最重要的往往就是连接建立过程、数据交换教程。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。</p>\n<p>下文主要围绕下面几点展开：</p>\n<p>如何建立连接<br>如何交换数据<br>数据帧格式<br>如何维持连接<br>三、入门例子<br>在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了WebSocket服务端、WebSocket客户端（网页端）。完整代码可以在 这里 找到。</p>\n<p>这里服务端用了ws这个库。相比大家熟悉的socket.io，ws实现更轻量，更适合学习的目的。</p>\n<p>1、服务端<br>代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。</p>\n<p>var app = require(‘express’)();<br>var server = require(‘http’).Server(app);<br>var WebSocket = require(‘ws’);</p>\n<p>var wss = new WebSocket.Server({ port: 8080 });</p>\n<p>wss.on(‘connection’, function connection(ws) {<br>    console.log(‘server: receive connection.’);</p>\n<pre><code>ws.on(&apos;message&apos;, function incoming(message) {\n    console.log(&apos;server: received: %s&apos;, message);\n});\n\nws.send(&apos;world&apos;);\n</code></pre><p>});</p>\n<p>app.get(‘/‘, function (req, res) {<br>  res.sendfile(__dirname + ‘/index.html’);<br>});</p>\n<p>app.listen(3000);<br>2、客户端<br>代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。</p>\n<p><script><br>  var ws = new WebSocket(‘ws://localhost:8080’);<br>  ws.onopen = function () {<br>    console.log(‘ws onopen’);<br>    ws.send(‘from client: hello’);<br>  };<br>  ws.onmessage = function (e) {<br>    console.log(‘ws onmessage’);<br>    console.log(‘from server: ‘ + e.data);<br>  };<br></script><br>3、运行结果<br>可分别查看服务端、客户端的日志，这里不展开。</p>\n<p>服务端输出：</p>\n<p>server: receive connection.<br>server: received hello<br>客户端输出：</p>\n<p>client: ws connection is open<br>client: received world<br>四、如何建立连接<br>前面提到，WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。</p>\n<p>1、客户端：申请协议升级<br>首先，客户端发起协议升级请求。可以看到，采用的是标准的HTTP报文格式，且只支持GET方法。</p>\n<p>GET / HTTP/1.1<br>Host: localhost:8080<br>Origin: <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a><br>Connection: Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Version: 13<br>Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==<br>重点请求首部意义如下：</p>\n<p>Connection: Upgrade：表示要升级协议<br>Upgrade: websocket：表示要升级到websocket协议。<br>Sec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。<br>Sec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。<br>注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。</p>\n<p>2、服务端：响应协议升级<br>服务端返回内容如下，状态代码101表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p>\n<p>HTTP/1.1 101 Switching Protocols<br>Connection:Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</p>\n<p>备注：每个header都以\\r\\n结尾，并且最后一行加上一个额外的空行\\r\\n。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。</p>\n<p>3、Sec-WebSocket-Accept的计算<br>Sec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。</p>\n<p>计算公式为：</p>\n<p>将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。<br>通过SHA1计算出摘要，并转成base64字符串。<br>伪代码如下：</p>\n<blockquote>\n<p>toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )<br>验证下前面的返回结果：</p>\n</blockquote>\n<p>const crypto = require(‘crypto’);<br>const magic = ‘258EAFA5-E914-47DA-95CA-C5AB0DC85B11’;<br>const secWebSocketKey = ‘w4v7O6xFTi36lq3RNcgctw==’;</p>\n<p>let secWebSocketAccept = crypto.createHash(‘sha1’)<br>    .update(secWebSocketKey + magic)<br>    .digest(‘base64’);</p>\n<p>console.log(secWebSocketAccept);<br>// Oy4NRAQ13jhfONC7bP8dTKb4PTU=<br>五、数据帧格式<br>客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。</p>\n<p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p>\n<p>发送端：将消息切割成多个帧，并发送给服务端；<br>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；<br>本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455 5.2节 。</p>\n<p>1、数据帧格式概览<br>下面给出了WebSocket数据帧的统一格式。熟悉TCP/IP协议的同学对这样的图应该不陌生。</p>\n<p>从左到右，单位是比特。比如FIN、RSV1各占据1比特，opcode占据4比特。<br>内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）<br> 2、数据帧格式详解<br>针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。</p>\n<p>FIN：1个比特。</p>\n<p>如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>\n<p>RSV1, RSV2, RSV3：各占1个比特。</p>\n<p>一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p>\n<p>Opcode: 4个比特。</p>\n<p>操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p>\n<p>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。<br>%x1：表示这是一个文本帧（frame）<br>%x2：表示这是一个二进制帧（frame）<br>%x3-7：保留的操作代码，用于后续定义的非控制帧。<br>%x8：表示连接断开。<br>%x9：表示这是一个ping操作。<br>%xA：表示这是一个pong操作。<br>%xB-F：保留的操作代码，用于后续定义的控制帧。<br>Mask: 1个比特。</p>\n<p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p>\n<p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p>\n<p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p>\n<p>掩码的算法、用途在下一小节讲解。</p>\n<p>Payload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。</p>\n<p>假设数Payload length === x，如果</p>\n<p>x为0~126：数据的长度为x字节。<br>x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。<br>x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。<br>此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p>\n<p>Masking-key：0或4字节（32位）</p>\n<p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p>\n<p>备注：载荷数据的长度，不包括mask key的长度。</p>\n<p>Payload data：(x+y) 字节</p>\n<p>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</p>\n<p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p>\n<p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p>\n<p>3、掩码算法<br>掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p>\n<p>首先，假设：</p>\n<p>original-octet-i：为原始数据的第i字节。<br>transformed-octet-i：为转换后的数据的第i字节。<br>j：为i mod 4的结果。<br>masking-key-octet-j：为mask key第j字节。<br>算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>\n<p>j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j</p>\n<p>六、数据传递<br>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p>\n<p>WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>\n<p>1、数据分片<br>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。</p>\n<p>FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p>\n<p>此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>\n<p>2、数据分片例子<br>直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>\n<p>第一条消息</p>\n<p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p>\n<p>第二条消息</p>\n<p>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。<br>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。<br>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。<br>Client: FIN=1, opcode=0x1, msg=”hello”<br>Server: (process complete message immediately) Hi.<br>Client: FIN=0, opcode=0x1, msg=”and a”<br>Server: (listening, new message containing text started)<br>Client: FIN=0, opcode=0x0, msg=”happy new”<br>Server: (listening, payload concatenated to previous message)<br>Client: FIN=1, opcode=0x0, msg=”year!”<br>Server: (process complete message) Happy new year to you too!<br>七、连接保持+心跳<br>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p>\n<p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>\n<p>发送方-&gt;接收方：ping<br>接收方-&gt;发送方：pong<br>ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。</p>\n<p>举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）</p>\n<p>ws.ping(‘’, false, true);<br>八、Sec-WebSocket-Key/Accept的作用<br>前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p>\n<p>作用大致归纳如下：</p>\n<p>避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）<br>确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）<br>用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）<br>可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。<br>Sec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。<br>强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。</p>\n<p>九、数据掩码的作用<br>WebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p>\n<p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p>\n<p>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p>\n<p>1、代理缓存污染攻击<br>下面摘自2010年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。</p>\n<p>“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”</p>\n<p>[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, “Talking to Yourself for Fun and Profit”, 2010,</p>\n<p>在正式描述攻击步骤之前，我们假设有如下参与者：</p>\n<p>攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）<br>受害者、受害者想要访问的资源（简称“正义资源”）<br>受害者实际想要访问的服务器（简称“正义服务器”）<br>中间代理服务器<br>攻击步骤一：</p>\n<p>攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。<br>协议升级请求 实际到达 代理服务器。<br>代理服务器 将协议升级请求转发到 邪恶服务器。<br>邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。<br>由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。</p>\n<p>攻击步骤二：</p>\n<p>攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）<br>请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。<br>代理服务器 向 邪恶服务器 请求 邪恶资源。<br>邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。<br>到这里，受害者可以登场了：</p>\n<p>受害者 通过 代理服务器 访问 正义服务器 的 正义资源。<br>代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。<br>代理服务器 将 邪恶资源 返回给 受害者。<br>受害者 卒。<br>附：前面提到的精心构造的“HTTP请求报文”。</p>\n<p>Client → Server:<br>POST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: <connection-key><br>Server → Client:<br>HTTP/1.1 200 OK<br>Sec-WebSocket-Accept: <connection-key><br>2、当前解决方案<br>最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。</connection-key></connection-key></p>\n<p>需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。</p>\n<p>但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。</p>\n<p>十、写在后面<br>WebSocket可写的东西还挺多，比如WebSocket扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。</p>\n<p>篇幅所限，这里先不展开，感兴趣的同学可以留言交流。文章如有错漏，敬请指出</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjd2ddrd90003uqzzepar7z4r","category_id":"cjd2ddrdc0005uqzz2qe70in6","_id":"cjd2ddrdj0009uqzz4ii14r9q"},{"post_id":"cjd2ddrd50002uqzz33ubccj4","category_id":"cjd2djcf600009rzzcmtrypdn","_id":"cjd2djcf700019rzzpgoinsti"}],"PostTag":[{"post_id":"cjd2ddrd90003uqzzepar7z4r","tag_id":"cjd2ddrdf0006uqzzjb4g35c7","_id":"cjd2ddrdi0008uqzzvwox6sc5"},{"post_id":"cjd2ddrd50002uqzz33ubccj4","tag_id":"cjd2di0io000092zzjewcxjzy","_id":"cjd2di0it000192zz27e8b6wd"}],"Tag":[{"name":"puppeteer","_id":"cjd2ddrdf0006uqzzjb4g35c7"},{"name":"React","_id":"cjd2di0io000092zzjewcxjzy"}]}}
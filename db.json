{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/clean-blog/source/css/article.styl","path":"css/article.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/mixins.styl","path":"css/mixins.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/variables.styl","path":"css/variables.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"22f078646eb223d92f744fcb8963c576805b4e2d","modified":1515935168000},{"_id":"themes/clean-blog/LICENSE","hash":"8726b416df4f067cff579e859f05c4b594b8be09","modified":1542259328857},{"_id":"themes/clean-blog/README.md","hash":"861dd2f959ab75d121226f4f3e2f61f4bc95fddb","modified":1542259328857},{"_id":"themes/clean-blog/_config.yml","hash":"87b863c11b80ad1899b1469cd8f6a904edaf5146","modified":1542259867505},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1521348688000},{"_id":"source/_posts/2018前端面试题总结.md","hash":"c2a27f8fdf4f91c6bbe5cc29941f477ee1abc6f3","modified":1515737336000},{"_id":"source/_posts/NodeJS-学习之路.md","hash":"9dd181f0508c420911cb52d19764c227a1f332d9","modified":1515814954000},{"_id":"source/_posts/React-Fiber架构.md","hash":"e3d0896b251452ef625e6b9e67b67ecbf5a2a594","modified":1517845108000},{"_id":"source/_posts/React元素和组件.md","hash":"3abc018acb00447bf6b98901417bbb9bcb662389","modified":1517361554000},{"_id":"source/_posts/WebSocket：5分钟从入门到精通.md","hash":"4c98516e6bc6a6388f6ca466170bea8a0e6d83df","modified":1515733584000},{"_id":"source/_posts/react-native 踩坑及心得体会.md","hash":"fe2000843b0a53626edecf70ac7aa4ebb848f212","modified":1542256931073},{"_id":"source/_posts/svn基本操作.md","hash":"613da0a195526513d73222cc7523e13f081e16fb","modified":1535423576000},{"_id":"source/_posts/关于Array的ES5部分方法的实现.md","hash":"75933e9ec4fe620377ca5be083bf1f41873c55b3","modified":1517403326000},{"_id":"source/_posts/关于puppeteer.md","hash":"4a4a472a5abf789bf0c634a7103d09bf892286e3","modified":1516586612000},{"_id":"source/_posts/实战项目总结一 (to8to项目基础配置).md","hash":"f4122bb9269b8c7102af22d3dae443aa9b6e3284","modified":1521389782000},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1517361752000},{"_id":"themes/clean-blog/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1542259328845},{"_id":"themes/clean-blog/.git/config","hash":"0037ed70f19e4933b19020ad514d8e9e049174f1","modified":1542259328849},{"_id":"themes/clean-blog/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1542259324250},{"_id":"themes/clean-blog/.git/index","hash":"f9e1bbc7336f257e61d76e6e564f19af673ef533","modified":1542259328867},{"_id":"themes/clean-blog/.git/packed-refs","hash":"8016e03c8557f5d8379a32ee7618d8d3a714d76c","modified":1542259328843},{"_id":"themes/clean-blog/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1542259328858},{"_id":"themes/clean-blog/languages/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1542259328858},{"_id":"themes/clean-blog/languages/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1542259328858},{"_id":"themes/clean-blog/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1542259328858},{"_id":"themes/clean-blog/languages/fr.yml","hash":"e9e6f7cb362ebb7997f11027498a2748fe3bac95","modified":1542259328858},{"_id":"themes/clean-blog/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1542259328858},{"_id":"themes/clean-blog/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1542259328859},{"_id":"themes/clean-blog/languages/pt.yml","hash":"1d0c3689eb32fe13f37f8f6f303af7624ebfbaf0","modified":1542259328859},{"_id":"themes/clean-blog/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1542259328859},{"_id":"themes/clean-blog/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1542259328859},{"_id":"themes/clean-blog/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1542259328859},{"_id":"themes/clean-blog/layout/archive.ejs","hash":"f2ef73afc3d275333329bb30b9369b82e119da76","modified":1542259328862},{"_id":"themes/clean-blog/layout/index.ejs","hash":"87995288ca6f95a04add641727aedd3f6afa55eb","modified":1542259328862},{"_id":"themes/clean-blog/layout/layout.ejs","hash":"da2f9018047924ddaf376aee5996c7ddc06cebc1","modified":1542259328862},{"_id":"themes/clean-blog/layout/page.ejs","hash":"591af587e1aae962950de7e79bd25c1f060c69ac","modified":1542259328863},{"_id":"themes/clean-blog/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1542259328863},{"_id":"themes/clean-blog/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1542259324253},{"_id":"themes/clean-blog/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1542259324251},{"_id":"themes/clean-blog/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1542259324254},{"_id":"themes/clean-blog/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1542259324256},{"_id":"themes/clean-blog/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1542259324257},{"_id":"themes/clean-blog/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1542259324253},{"_id":"themes/clean-blog/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1542259324257},{"_id":"themes/clean-blog/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1542259324252},{"_id":"themes/clean-blog/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1542259324255},{"_id":"themes/clean-blog/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1542259324257},{"_id":"themes/clean-blog/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1542259324256},{"_id":"themes/clean-blog/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1542259324249},{"_id":"themes/clean-blog/.git/logs/HEAD","hash":"f52433cf00cf650320516fc00fd311fb097a9610","modified":1542259328846},{"_id":"themes/clean-blog/layout/_partial/after-footer.ejs","hash":"80970a6cfbf9b1abe0c472636b321a9be08fdc43","modified":1542259328859},{"_id":"themes/clean-blog/layout/_partial/article-archive.ejs","hash":"3d8d98c6545b8332a6d6ed4f8b00327df03ea945","modified":1542259328860},{"_id":"themes/clean-blog/layout/_partial/article-categories.ejs","hash":"5a0bf5a20f670621d8013c9b9d7976b45c8aa80f","modified":1542259328860},{"_id":"themes/clean-blog/layout/_partial/article-full.ejs","hash":"0e7aa9da47f29b2312d9d3165c067576ebca77cf","modified":1542259328860},{"_id":"themes/clean-blog/layout/_partial/article-index.ejs","hash":"e433df4e245e2d4c628052c6e59966563542d94d","modified":1542259328860},{"_id":"themes/clean-blog/layout/_partial/article-tags.ejs","hash":"6136434be09056c1466149cecb3cc2e80d107999","modified":1542259328861},{"_id":"themes/clean-blog/layout/_partial/comments.ejs","hash":"3fedb75436439d1d6979b7e4d20d48a593e12be4","modified":1542259328861},{"_id":"themes/clean-blog/layout/_partial/footer.ejs","hash":"d252fb1a41890e6481bb054f9cc4ceec3c0b0ed9","modified":1542259328861},{"_id":"themes/clean-blog/layout/_partial/gallery.ejs","hash":"21e4f28909f4a79ff7d9f10bdfef6a8cb11632bf","modified":1542259328861},{"_id":"themes/clean-blog/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1542259328861},{"_id":"themes/clean-blog/layout/_partial/head.ejs","hash":"3ccfc84e3ed67415fe71a1767d5e77a6b1f84a7a","modified":1542259328861},{"_id":"themes/clean-blog/layout/_partial/menu.ejs","hash":"ba299316400499e9ede154e9627cafb7ce411888","modified":1542259328862},{"_id":"themes/clean-blog/layout/_partial/tag-category-index.ejs","hash":"10cdc1b7866999c714a666557c150d2c79c1fba9","modified":1542259328862},{"_id":"themes/clean-blog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1542259328862},{"_id":"themes/clean-blog/source/css/article.styl","hash":"f5294d7a3d6127fcb287de3ff0c12aebb1766c7b","modified":1542259328863},{"_id":"themes/clean-blog/source/css/base.styl","hash":"0b54825903d08b5f7f7fe95ef4261c90e980abdb","modified":1542259328863},{"_id":"themes/clean-blog/source/css/mixins.styl","hash":"892f55e8a71f2e23a52e48e217dad3303bbad913","modified":1542259328864},{"_id":"themes/clean-blog/source/css/style.styl","hash":"c40dc495a41007d21c59f342ee42b2d31d7b5ff4","modified":1542259328864},{"_id":"themes/clean-blog/source/css/variables.styl","hash":"cd82df5ca8dfbcfec12d833f01adfac00878e835","modified":1542259328864},{"_id":"themes/clean-blog/source/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1542259328864},{"_id":"themes/clean-blog/.git/objects/pack/pack-1fedb8c657ee40822f109137f5c20ebf056ae733.idx","hash":"13a16af70ac2bb94f597356ad4227c5d410de3dc","modified":1542259328823},{"_id":"themes/clean-blog/.git/refs/heads/master","hash":"5b03e8d3541ba4616fb93e621cc6e33bf615621d","modified":1542259328846},{"_id":"themes/clean-blog/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1542259328867},{"_id":"themes/clean-blog/.git/logs/refs/heads/master","hash":"f52433cf00cf650320516fc00fd311fb097a9610","modified":1542259328847},{"_id":"themes/clean-blog/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1542259328844},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1542259328866},{"_id":"themes/clean-blog/.git/logs/refs/remotes/origin/HEAD","hash":"f52433cf00cf650320516fc00fd311fb097a9610","modified":1542259328844},{"_id":"themes/clean-blog/.git/objects/pack/pack-1fedb8c657ee40822f109137f5c20ebf056ae733.pack","hash":"79ec9046cefa31291af8324cbc7d46af6e3de8b5","modified":1542259328822}],"Category":[{"name":"React","_id":"cjoi5wzz90004f7krqzddqzjd"},{"name":"Node","_id":"cjoi5wzzs000if7kriswnte25"},{"name":"React webpack","_id":"cjoi5wzzu000mf7kr8712wn7w"}],"Data":[],"Page":[],"Post":[{"title":"2018前端面试题总结","date":"2018-01-12T11:48:25.000Z","_content":"![title](http://onh0umlhz.bkt.clouddn.com/0524themetitle.PNG)\n\n## 计算机网络\n\n### 一、HTTP协议头含有哪些重要的部分，HTTP状态码\n\n#### Request Headers (请求头)\n\nAccept : 浏览器可以接受的媒体类型\n\nAccept-Encoding :  浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）\n\nAccept-Language : 浏览器申明自己接收的语言。 \n\nUser-Agent : 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.\n\nAccept-Charset : 浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）\n\nConnection :\n\n1. Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接\n2. Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。\n\nCookie: :  最重要的header, 将cookie的值发送给HTTP 服务器\n\nHost : 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的\n\nReferer : 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。\n\n### Response Header (响应头)\n\n#### Cache : \n\nDate : 生成消息的具体时间和日期\n\nExpires : 浏览器会在指定过期时间内使用本地缓存\n\nContent-Encoding : WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。\n\nContent-Length : 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。\n\nContent-Type : WEB服务器告诉浏览器自己响应的对象的类型和字符集,\n\n### HTTP状态码\n\n#### 常见\n\n- 200 - 请求成功\n- 301 - 资源（网页等）被永久转移到其它URL\n- 404 - 请求的资源（网页等）不存在\n- 500 - 内部服务器错误\n\n1XX : 信息，服务器收到请求，需要请求者继续执行操作\n\n2XX : 成功，操作被成功接收并处理\n\n3XX : 重定向，需要进一步的操作以完成请求\n\n4XX : 客户端错误，请求包含语法错误或无法完成请求\n\n5XX : 服务器错误，服务器在处理请求的过程中发生了错误\n\n","source":"_posts/2018前端面试题总结.md","raw":"---\ntitle: 2018前端面试题总结\ndate: 2018-01-12 19:48:25\ntags:\n---\n![title](http://onh0umlhz.bkt.clouddn.com/0524themetitle.PNG)\n\n## 计算机网络\n\n### 一、HTTP协议头含有哪些重要的部分，HTTP状态码\n\n#### Request Headers (请求头)\n\nAccept : 浏览器可以接受的媒体类型\n\nAccept-Encoding :  浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）\n\nAccept-Language : 浏览器申明自己接收的语言。 \n\nUser-Agent : 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.\n\nAccept-Charset : 浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）\n\nConnection :\n\n1. Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接\n2. Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。\n\nCookie: :  最重要的header, 将cookie的值发送给HTTP 服务器\n\nHost : 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的\n\nReferer : 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。\n\n### Response Header (响应头)\n\n#### Cache : \n\nDate : 生成消息的具体时间和日期\n\nExpires : 浏览器会在指定过期时间内使用本地缓存\n\nContent-Encoding : WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。\n\nContent-Length : 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。\n\nContent-Type : WEB服务器告诉浏览器自己响应的对象的类型和字符集,\n\n### HTTP状态码\n\n#### 常见\n\n- 200 - 请求成功\n- 301 - 资源（网页等）被永久转移到其它URL\n- 404 - 请求的资源（网页等）不存在\n- 500 - 内部服务器错误\n\n1XX : 信息，服务器收到请求，需要请求者继续执行操作\n\n2XX : 成功，操作被成功接收并处理\n\n3XX : 重定向，需要进一步的操作以完成请求\n\n4XX : 客户端错误，请求包含语法错误或无法完成请求\n\n5XX : 服务器错误，服务器在处理请求的过程中发生了错误\n\n","slug":"2018前端面试题总结","published":1,"updated":"2018-01-12T06:08:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzyy0000f7krpkfxt0jc","content":"<p><img src=\"http://onh0umlhz.bkt.clouddn.com/0524themetitle.PNG\" alt=\"title\"></p>\n<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><h3 id=\"一、HTTP协议头含有哪些重要的部分，HTTP状态码\"><a href=\"#一、HTTP协议头含有哪些重要的部分，HTTP状态码\" class=\"headerlink\" title=\"一、HTTP协议头含有哪些重要的部分，HTTP状态码\"></a>一、HTTP协议头含有哪些重要的部分，HTTP状态码</h3><h4 id=\"Request-Headers-请求头\"><a href=\"#Request-Headers-请求头\" class=\"headerlink\" title=\"Request Headers (请求头)\"></a>Request Headers (请求头)</h4><p>Accept : 浏览器可以接受的媒体类型</p>\n<p>Accept-Encoding :  浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）</p>\n<p>Accept-Language : 浏览器申明自己接收的语言。 </p>\n<p>User-Agent : 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>\n<p>Accept-Charset : 浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）</p>\n<p>Connection :</p>\n<ol>\n<li>Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</li>\n<li>Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li>\n</ol>\n<p>Cookie: :  最重要的header, 将cookie的值发送给HTTP 服务器</p>\n<p>Host : 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p>\n<p>Referer : 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>\n<h3 id=\"Response-Header-响应头\"><a href=\"#Response-Header-响应头\" class=\"headerlink\" title=\"Response Header (响应头)\"></a>Response Header (响应头)</h3><h4 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache :\"></a>Cache :</h4><p>Date : 生成消息的具体时间和日期</p>\n<p>Expires : 浏览器会在指定过期时间内使用本地缓存</p>\n<p>Content-Encoding : WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p>\n<p>Content-Length : 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>\n<p>Content-Type : WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><h4 id=\"常见\"><a href=\"#常见\" class=\"headerlink\" title=\"常见\"></a>常见</h4><ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n<p>1XX : 信息，服务器收到请求，需要请求者继续执行操作</p>\n<p>2XX : 成功，操作被成功接收并处理</p>\n<p>3XX : 重定向，需要进一步的操作以完成请求</p>\n<p>4XX : 客户端错误，请求包含语法错误或无法完成请求</p>\n<p>5XX : 服务器错误，服务器在处理请求的过程中发生了错误</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://onh0umlhz.bkt.clouddn.com/0524themetitle.PNG\" alt=\"title\"></p>\n<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><h3 id=\"一、HTTP协议头含有哪些重要的部分，HTTP状态码\"><a href=\"#一、HTTP协议头含有哪些重要的部分，HTTP状态码\" class=\"headerlink\" title=\"一、HTTP协议头含有哪些重要的部分，HTTP状态码\"></a>一、HTTP协议头含有哪些重要的部分，HTTP状态码</h3><h4 id=\"Request-Headers-请求头\"><a href=\"#Request-Headers-请求头\" class=\"headerlink\" title=\"Request Headers (请求头)\"></a>Request Headers (请求头)</h4><p>Accept : 浏览器可以接受的媒体类型</p>\n<p>Accept-Encoding :  浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）</p>\n<p>Accept-Language : 浏览器申明自己接收的语言。 </p>\n<p>User-Agent : 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>\n<p>Accept-Charset : 浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）</p>\n<p>Connection :</p>\n<ol>\n<li>Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</li>\n<li>Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li>\n</ol>\n<p>Cookie: :  最重要的header, 将cookie的值发送给HTTP 服务器</p>\n<p>Host : 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p>\n<p>Referer : 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>\n<h3 id=\"Response-Header-响应头\"><a href=\"#Response-Header-响应头\" class=\"headerlink\" title=\"Response Header (响应头)\"></a>Response Header (响应头)</h3><h4 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache :\"></a>Cache :</h4><p>Date : 生成消息的具体时间和日期</p>\n<p>Expires : 浏览器会在指定过期时间内使用本地缓存</p>\n<p>Content-Encoding : WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p>\n<p>Content-Length : 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>\n<p>Content-Type : WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><h4 id=\"常见\"><a href=\"#常见\" class=\"headerlink\" title=\"常见\"></a>常见</h4><ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n<p>1XX : 信息，服务器收到请求，需要请求者继续执行操作</p>\n<p>2XX : 成功，操作被成功接收并处理</p>\n<p>3XX : 重定向，需要进一步的操作以完成请求</p>\n<p>4XX : 客户端错误，请求包含语法错误或无法完成请求</p>\n<p>5XX : 服务器错误，服务器在处理请求的过程中发生了错误</p>\n"},{"title":"NodeJS 学习之路","date":"2018-01-13T03:42:34.000Z","_content":"","source":"_posts/NodeJS-学习之路.md","raw":"---\ntitle: NodeJS 学习之路\ndate: 2018-01-13 11:42:34\ntags:\n---\n","slug":"NodeJS-学习之路","published":1,"updated":"2018-01-13T03:42:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzz20001f7krymi37e85","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"React Fiber架构","date":"2018-02-05T15:36:27.000Z","_content":"# React Fiber架构\n\n## 引言\n\nReact Fiber是React核心算法的重写，目前还在开发中。它是React团队过去两年研究的高峰。\n\nReact Fiber的目标是增强对于某些领域的适应性，比如动画、布局和手势等。它的重要特性是**增量渲染**：将渲染事务（work）分块并分布到多个帧去完成的能力。\n\n其他关键特性包括有新的更新时，暂停、终止或重用事务的功能；为不同类型的更新设置优先级的功能；还有新的并发原语（concurrency primitives）。\n\n### 关于本文档\n\nFiber引入了几个新颖的概念，单单看代码是很难理解的。本文档起初是React项目在逐步实现Fiber的时候记的笔记集，随着慢慢扩充，我发现这对于其他人来说可能也是很实用的资源。\n\n我会尽可能的使用简单的语言，通过显式的定义一些术语来避免行话。如果可能，我也会尽可能链接到外部资源。\n\n注意我并不在React团队里面，不代表任何官方的发言。**这不是官方文档**。不过我请教了React团队的一些成员来检查文档的准确性。\n\n这也是一项进行中的工作。**Fiber也是一个开发中的项目，在完成之前有可能还会有重大的重构**。所以我在此为它的设计写的文档也是进行中的。非常欢迎提出优化和建议。\n\n我的目标是读完这篇文档后，你能够理解Fiber足够深来读懂[它的实现](https://github.com/facebook/react/commits/master/src/renderers/shared/fiber)，最终甚至能够返回来给React做一些贡献。\n\n### 必要的知识\n\n我强烈建议在继续看本文档之前，你先熟悉一下以下资源：\n\n- [React组件，元素和实例](https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html)：“组件”是经常提起的术语。对这些术语有坚实的认知是非常重要的。\n- [协调算法](https://facebook.github.io/react/docs/reconciliation.html)：React协调算法的高阶阐述。\n- [React基本理论概念](https://github.com/reactjs/react-basic)：不带实现细节的React理论模型阐述。其中一些内容可能在第一次阅读时没什么意义，但随着时间推移会证明非常有用。\n- [React设计原则](https://facebook.github.io/react/contributing/design-principles.html)：特别注意其中的Scheduling环节，它很好的诠释了React Fiber诞生的原因。\n\n## 回顾\n\n如果你还没阅读“必要的知识”环节，请确认阅读一下。\n\n在我们学习新的东西前，我们回顾一些概念。\n\n### 什么是协调算法\n\n- 协调算法(reconciliation)\n\n  React用以比较两棵树的算法，其决定哪些部分需要更改。\n\n- 更新(update)\n\n  即渲染React app的数据发生的一个改变。通常是`setState`的结果。最终会导致重新渲染。\n\nReact API的核心思想是让更新能引发整个app及时的重新渲染。这将允许开发者作出声明式的推断，而不用担心app如何有效的从一个状态切换到另一个状态（A到B，B到C，C到A等等）。\n\n实际上，对于每一次改变都重新渲染app只对一些小型应用有用；现实中，这是极度浪费性能的。React使用了一些优化，能够达到类似重新渲染整个app的效果，同时保持高性能。这些优化就是**协调算法**的一部分。\n\n协调算法是基于通常被称为“虚拟DOM”技术的。一个高阶的描述是：当你渲染一个React app的时候，会生成app描述的节点树并保存在内存中。然后这个树被输出到渲染环境——比如，在浏览器应用中，它被翻译为一堆DOM操作。当一个app更新时（一般是通过`setState`），就产生了一棵新树。新树和旧树会进行比较，计算需要哪些操作来更新app。\n\n虽然Fiber是协调算法的推倒重写，关于[React文档](https://facebook.github.io/react/docs/reconciliation.html)中的高阶知识还是一致的。主要的两点是：\n\n- 不同类型的组件很大程度上将会产生不同的树。React将不会比较他们，而是直接用新的完全替代旧的。\n- 列表的diff使用key。Key应当是稳定、可预测、并且唯一的。\n\n### 协调算法 vs 渲染\n\nDOM只是React可以输出的渲染环境之一，其他的一些主要目标包括通过React Native输出到原生的iOS和Android视图。（这也就是为什么“虚拟DOM”是有点用词不当的）。\n\nReact支持这么多目标的原因是因为它将协调算法和渲染设计成了不同的阶段。协调算法负责计算一棵树哪些部分更改了；渲染器则利用该信息来实际更新app。\n\n这个分离意味着React DOM和React Native能共享React核心提供的协调算法，而使用它们各自的渲染器。\n\nFiber重构了协调器。Fiber不是渲染需要首要考虑的，但渲染器需要改变来支持（并且利用）新的架构。\n\n### 调度(Scheduling)\n\n- 调度(scheduling)\n\n  决定事务什么时候执行的过程。\n\n- 事务(work)\n\n  必须执行的计算。事务一般是由update引起的（比如`setState`）。\n\nReact的[设计原则文档](https://facebook.github.io/react/contributing/design-principles.html#scheduling)在这方面写的很好，我引用如下：\n\n> 在当前的实现中，React递归遍历节点树，在一个tick内调用整棵新树的渲染函数。但是未来有可能推迟一些更新来避免掉帧。\n>\n> 这是React设计的一个常见主题。一些流行的库采用\"push\"方法，在新的数据就绪的时候就执行计算。React仍然使用\"pull\"方法，计算可以推迟到需要的时候才执行。\n>\n> React不是通用的数据处理库。它是用以建立用户界面的库。我们认为在一个app中，知道计算是相关还是不相关的是独一无二的重要。\n>\n> 如果某些东西超出了屏幕显示，我们可以延迟它相关的所有逻辑。如果数据到达的比帧率要快，我们可以合并和批处理更新。我们可以优先处理用户交互的事务（比如点击按钮引起的动画），次要处理没那么重要的背景事务（比如渲染刚从网络上返回的数据）来避免掉帧。\n\n关键点在于：\n\n- 在用户界面中，没必要每一个更新都立即执行；实际上这样做是很浪费的，导致掉帧，降低用户体验。\n- 不同类型的更新具有不同的优先级——一个动画更新需要比数据源的更新更快的完成。\n- 一个基于push的app需要应用（你，程序员）来决定怎么调度事务。基于pull的app允许框架(React)变得智能化，帮你完成这些决策。\n\nReact现在没有很重要地利用调度；一个更新会引发整个子树被立即重新渲染。革新React的核心算法来充分利用调度是Fiber背后的驱动想法。\n\n------\n\n现在我们已经准备好了深入Fiber的实现。下一节比我们前面讨论的都要更偏技术一点。继续之前，确认你学习好了前面的知识点。\n\n## 什么是Fiber？\n\n我们将要讨论React Fiber架构的核心部分。Fibers是比应用开发者通常思考的部分要低很多的底层抽象。如果你发现很难理解它，不要丧气。多尝试几次，最终你就能理解。（如果你最后懂了，请提些建议来改进这节内容。）\n\n出发！\n\n------\n\n我们前面已经确定了Fiber的主要目标是使React能够充分利用调度。详细来说，我们需要能够：\n\n- 暂停事务，在一段时间后再接着执行。\n- 分配不同类型事务的优先级。\n- 复用之前已完成的事务。\n- 当事务不再需要时，终止该事务。\n\n为了实现上面的任意一个功能，首先我们需要分解事务为若干单元的方法。在某种意义上那就是一个fiber。一个fiber代表了事务的一个单元。\n\n更进一步之前，我们重温一下[React组件是数据的函数](https://github.com/reactjs/react-basic#transformation)的概念，通常表达为：\n\n```\nv = f(d)\n\n```\n\n它表明渲染一个React app类似于调用一个函数，这个函数体里面包含了对其他函数的调用，以此类推。这个类比在思考fiber的时候很有帮助。\n\n计算机跟踪一个程序执行的方式是[调用栈（call stack）](https://en.wikipedia.org/wiki/Call_stack)。当一个函数执行的时候，栈上面就会添加一个新的堆栈结构。这个堆栈结构代表了那个函数执行的事务。\n\n处理用户界面时，问题是如果太多的事务同时执行，它可能导致动画掉帧，看起来卡顿。还有，其中的一些事务是不需要的，因为它可能被最近的更新取代了。这就是UI组件和函数不同的地方，因为通常组件比函数有更特殊的关注点。\n\n最新的浏览器（和React Native）实现了API来定位这个问题：`requestIdleCallback`调度一个低优先级的函数在空闲阶段执行，`requestAnimationFrame`调度一个高优先级的函数在下一个动画帧执行。问题在于，要使用这些API，你需要将渲染事务分解为增量单元的方法。如果你仅依赖于调用栈，它将会一直工作直到栈变空。\n\n如果我们能自定义调用栈的行为来优化UI渲染该多好啊？如果我们能主动中断调用栈，手动操作堆栈结构该多好啊？\n\n这就是React Fiber的目的。Fiber是专门为React组件实现的堆栈重构。你可以把单个fiber当做一个**虚拟的堆栈结构(virtual stack frame)**。\n\n重构堆栈的好处是你能[保存堆栈结构在内存里](https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/)，然后用你想要的方式和时机去执行它。这点对于实现我们要的调度功能非常重要。\n\n除了调度，手动操作堆栈结构也使的一些潜在特性变得可能，比如并发和错误边界。我们将会在未来的章节讨论这些话题。\n\n下一节，我们将讨论更多关于fiber的结构。\n\n### 一个fiber的结构\n\n**注意：随着我们讨论更多的实现细节，某些东西被改变的概率也会上升。如果你发现了任何错误或过时的信息，请帮忙提交一下PR。**\n\n具体来说，一个fiber是包含了一个组件及其输入、输出信息的JavaScript对象。\n\n一个fiber对应了一个堆栈结构，同时它也对应了一个组件实例。\n\n下面是fiber的一些重要字段。（这个列表不是完全的。）\n\n#### `type`和`key`\n\nFiber的`type`和`key`的作用和React元素一样。（实际上，一个fiber从组件创建时，这两个字段会直接复制过来）。\n\nFiber的`type`描述了它对应的组件。对于复合组件，`type`就是复合函数或组件的class。对于宿主组件（`div`, `span`等），`type`是一个字符串。\n\n从概念上来说，`type`是执行会被堆栈结构跟踪的函数（即在`v = f(d)`里面的）。\n\n除了`type`之外，`key`是在协调算法中用来决定fiber是否可以重用的字段。\n\n#### `child`和`sibling`\n\n这些字段指向其他的fiber，描述的是fiber的递归树结构。\n\n子fiber(child fiber)指的是组件的`render`方法返回来的值。比如在下面的样例中`Parent`的子fiber就是`Child`。\n\n```\nfunction Parent() {\n  return <Child />\n}\n\n```\n\n兄弟fiber(`sibling` fiber)指代的是`render`方法返回多个子节点的情况（Fiber中的新特性！）：\n\n```\nfunction Parent() {\n  return [<Child1 />, <Child2 />]\n}\n\n```\n\n兄弟fiber形成一个单链表，链表头就是第一个子节点。在上面的例子中，`Parent`的子节点是`Child1`，`Child1`的兄弟节点是`Child2`。\n\n回顾我们前面的函数类比，你可以把子fiber当做是一个[尾调用函数](https://en.wikipedia.org/wiki/Tail_call)。\n\n#### `return`\n\n返回fiber(`return` fiber)是指程序处理完当前的fiber后应当处理的下一个fiber。理论上和一个堆栈结构的返回地址一样。也可以认为是父fiber。\n\n如果一个fiber有多个子fiber，每个子fiber的返回fiber都是它的父fiber。所以在我们上一个例子中，`Child1`和`Child2`的返回fiber都是`Parent`。\n\n#### `pendingProps`和`memoizedProps`\n\n概念上来说，props就是一个函数的参数。一个fiber的`pendingProps`会在它开始执行处设置，`memoizedProps`则会在执行结尾处设置。\n\n当到来的`pendingProps`和上一个`memoizedProps`相等时，它意味着fiber的上一次输出可以重用，避免不必要的事务。\n\n#### `pendingWorkPriority`\n\n指示fiber代表的事务优先级的一个数字。[React优先级](https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js)模块列举了不同的优先级和它们代表的意义。\n\n除了用0表示`NoWork`之外，越大的数字代表了越低的优先级。例如，你可以用下面的函数来检查一个fiber的优先级是不是不低于给定的等级：\n\n```\nfunction matchesPriority(fiber, priority) {\n  return fiber.pendingWorkPriority !== 0 && fiber.pendingWorkPriority <= priority\n}\n\n```\n\n这个函数仅仅是作说明用，它实际上不属于React Fiber代码库。\n\n调度器使用这个优先级字段来搜索下一个要执行的事务。搜索算法会在将来的章节讨论。\n\n#### `alternate`\n\n- `flush`\n\n  冲洗一个fiber就是渲染输出结果到屏幕上。\n\n- `work-in-progress`\n\n  进行中的fiber代表一个未处理完毕的fiber，概念上来说就是一个还未返回的堆栈结构。\n\n在任意一个时刻，一个组件实例最多有两个fiber对应着它：当前fiber（冲洗的fiber）和进行中的fiber。\n\n当前fiber的替代(`alternate`)就是进行中的fiber，进行中的fiber的替代就是当前fiber。\n\n一个fiber的替代是通过`cloneFiber`函数懒创建的。`cloneFiber`会尝试重用fiber的替代（如果存在）来最小化分配空间，而不是总创建新的对象。\n\n你应当把`alternate`当做是一个实现细节，但它在代码里面出现了很多次，所以值得在这里讨论。\n\n#### `output`\n\n- `host component`\n\n  宿主组件(`host component`)是React应用的叶节点。它们是跟特定的渲染环境相关的（比如，在浏览器应用中，宿主组件是指`div`, `span`等）。在JSX中，它们是用小写字母的tag名称表示的。\n\n概念上来说，一个fiber的输出结果就是一个函数的返回值。\n\n每个fiber最终都会有输出结果，但是输出结果是仅由叶节点的**宿主组件**创建的。然后输出结果会向上转移到整个树。\n\n输出结果就是最终交给渲染器的东西，然后渲染器能够将更改冲洗到渲染环境。定义输出结果怎么样创建和更新就是渲染器的职责了。\n\n## 未来的章节\n\n上面就是至今为止的内容了，但是这个文档还远未接近完成。未来的章节将会描述贯穿整个生命周期和更新使用的算法。将覆盖的主题包括：\n\n- 调度器怎么样找到下一个要执行的事务单元\n- 整个fiber树的优先级怎么跟踪和传播\n- 调度器怎么样知道什么时候暂停和继续事务\n- 事务是怎么冲洗和标记为完成的\n- 附带后果（比如声明周期方法）是怎么样工作的\n- 什么是协同程序，和它是怎么样用来实现一些特性比如上下文(context)和布局(layout)的\n\n## 相关视频\n\n- [What's Next for React (ReactNext 2016)](https://www.youtube.com/watch?v=crM1iRVGpGQ)\n\n## [原文链接](https://swenyang.gitbooks.io/yapn/content/react-fiber/)","source":"_posts/React-Fiber架构.md","raw":"---\ntitle: React Fiber架构\ndate: 2018-02-05 23:36:27\ntags: React\ncategories: React\n---\n# React Fiber架构\n\n## 引言\n\nReact Fiber是React核心算法的重写，目前还在开发中。它是React团队过去两年研究的高峰。\n\nReact Fiber的目标是增强对于某些领域的适应性，比如动画、布局和手势等。它的重要特性是**增量渲染**：将渲染事务（work）分块并分布到多个帧去完成的能力。\n\n其他关键特性包括有新的更新时，暂停、终止或重用事务的功能；为不同类型的更新设置优先级的功能；还有新的并发原语（concurrency primitives）。\n\n### 关于本文档\n\nFiber引入了几个新颖的概念，单单看代码是很难理解的。本文档起初是React项目在逐步实现Fiber的时候记的笔记集，随着慢慢扩充，我发现这对于其他人来说可能也是很实用的资源。\n\n我会尽可能的使用简单的语言，通过显式的定义一些术语来避免行话。如果可能，我也会尽可能链接到外部资源。\n\n注意我并不在React团队里面，不代表任何官方的发言。**这不是官方文档**。不过我请教了React团队的一些成员来检查文档的准确性。\n\n这也是一项进行中的工作。**Fiber也是一个开发中的项目，在完成之前有可能还会有重大的重构**。所以我在此为它的设计写的文档也是进行中的。非常欢迎提出优化和建议。\n\n我的目标是读完这篇文档后，你能够理解Fiber足够深来读懂[它的实现](https://github.com/facebook/react/commits/master/src/renderers/shared/fiber)，最终甚至能够返回来给React做一些贡献。\n\n### 必要的知识\n\n我强烈建议在继续看本文档之前，你先熟悉一下以下资源：\n\n- [React组件，元素和实例](https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html)：“组件”是经常提起的术语。对这些术语有坚实的认知是非常重要的。\n- [协调算法](https://facebook.github.io/react/docs/reconciliation.html)：React协调算法的高阶阐述。\n- [React基本理论概念](https://github.com/reactjs/react-basic)：不带实现细节的React理论模型阐述。其中一些内容可能在第一次阅读时没什么意义，但随着时间推移会证明非常有用。\n- [React设计原则](https://facebook.github.io/react/contributing/design-principles.html)：特别注意其中的Scheduling环节，它很好的诠释了React Fiber诞生的原因。\n\n## 回顾\n\n如果你还没阅读“必要的知识”环节，请确认阅读一下。\n\n在我们学习新的东西前，我们回顾一些概念。\n\n### 什么是协调算法\n\n- 协调算法(reconciliation)\n\n  React用以比较两棵树的算法，其决定哪些部分需要更改。\n\n- 更新(update)\n\n  即渲染React app的数据发生的一个改变。通常是`setState`的结果。最终会导致重新渲染。\n\nReact API的核心思想是让更新能引发整个app及时的重新渲染。这将允许开发者作出声明式的推断，而不用担心app如何有效的从一个状态切换到另一个状态（A到B，B到C，C到A等等）。\n\n实际上，对于每一次改变都重新渲染app只对一些小型应用有用；现实中，这是极度浪费性能的。React使用了一些优化，能够达到类似重新渲染整个app的效果，同时保持高性能。这些优化就是**协调算法**的一部分。\n\n协调算法是基于通常被称为“虚拟DOM”技术的。一个高阶的描述是：当你渲染一个React app的时候，会生成app描述的节点树并保存在内存中。然后这个树被输出到渲染环境——比如，在浏览器应用中，它被翻译为一堆DOM操作。当一个app更新时（一般是通过`setState`），就产生了一棵新树。新树和旧树会进行比较，计算需要哪些操作来更新app。\n\n虽然Fiber是协调算法的推倒重写，关于[React文档](https://facebook.github.io/react/docs/reconciliation.html)中的高阶知识还是一致的。主要的两点是：\n\n- 不同类型的组件很大程度上将会产生不同的树。React将不会比较他们，而是直接用新的完全替代旧的。\n- 列表的diff使用key。Key应当是稳定、可预测、并且唯一的。\n\n### 协调算法 vs 渲染\n\nDOM只是React可以输出的渲染环境之一，其他的一些主要目标包括通过React Native输出到原生的iOS和Android视图。（这也就是为什么“虚拟DOM”是有点用词不当的）。\n\nReact支持这么多目标的原因是因为它将协调算法和渲染设计成了不同的阶段。协调算法负责计算一棵树哪些部分更改了；渲染器则利用该信息来实际更新app。\n\n这个分离意味着React DOM和React Native能共享React核心提供的协调算法，而使用它们各自的渲染器。\n\nFiber重构了协调器。Fiber不是渲染需要首要考虑的，但渲染器需要改变来支持（并且利用）新的架构。\n\n### 调度(Scheduling)\n\n- 调度(scheduling)\n\n  决定事务什么时候执行的过程。\n\n- 事务(work)\n\n  必须执行的计算。事务一般是由update引起的（比如`setState`）。\n\nReact的[设计原则文档](https://facebook.github.io/react/contributing/design-principles.html#scheduling)在这方面写的很好，我引用如下：\n\n> 在当前的实现中，React递归遍历节点树，在一个tick内调用整棵新树的渲染函数。但是未来有可能推迟一些更新来避免掉帧。\n>\n> 这是React设计的一个常见主题。一些流行的库采用\"push\"方法，在新的数据就绪的时候就执行计算。React仍然使用\"pull\"方法，计算可以推迟到需要的时候才执行。\n>\n> React不是通用的数据处理库。它是用以建立用户界面的库。我们认为在一个app中，知道计算是相关还是不相关的是独一无二的重要。\n>\n> 如果某些东西超出了屏幕显示，我们可以延迟它相关的所有逻辑。如果数据到达的比帧率要快，我们可以合并和批处理更新。我们可以优先处理用户交互的事务（比如点击按钮引起的动画），次要处理没那么重要的背景事务（比如渲染刚从网络上返回的数据）来避免掉帧。\n\n关键点在于：\n\n- 在用户界面中，没必要每一个更新都立即执行；实际上这样做是很浪费的，导致掉帧，降低用户体验。\n- 不同类型的更新具有不同的优先级——一个动画更新需要比数据源的更新更快的完成。\n- 一个基于push的app需要应用（你，程序员）来决定怎么调度事务。基于pull的app允许框架(React)变得智能化，帮你完成这些决策。\n\nReact现在没有很重要地利用调度；一个更新会引发整个子树被立即重新渲染。革新React的核心算法来充分利用调度是Fiber背后的驱动想法。\n\n------\n\n现在我们已经准备好了深入Fiber的实现。下一节比我们前面讨论的都要更偏技术一点。继续之前，确认你学习好了前面的知识点。\n\n## 什么是Fiber？\n\n我们将要讨论React Fiber架构的核心部分。Fibers是比应用开发者通常思考的部分要低很多的底层抽象。如果你发现很难理解它，不要丧气。多尝试几次，最终你就能理解。（如果你最后懂了，请提些建议来改进这节内容。）\n\n出发！\n\n------\n\n我们前面已经确定了Fiber的主要目标是使React能够充分利用调度。详细来说，我们需要能够：\n\n- 暂停事务，在一段时间后再接着执行。\n- 分配不同类型事务的优先级。\n- 复用之前已完成的事务。\n- 当事务不再需要时，终止该事务。\n\n为了实现上面的任意一个功能，首先我们需要分解事务为若干单元的方法。在某种意义上那就是一个fiber。一个fiber代表了事务的一个单元。\n\n更进一步之前，我们重温一下[React组件是数据的函数](https://github.com/reactjs/react-basic#transformation)的概念，通常表达为：\n\n```\nv = f(d)\n\n```\n\n它表明渲染一个React app类似于调用一个函数，这个函数体里面包含了对其他函数的调用，以此类推。这个类比在思考fiber的时候很有帮助。\n\n计算机跟踪一个程序执行的方式是[调用栈（call stack）](https://en.wikipedia.org/wiki/Call_stack)。当一个函数执行的时候，栈上面就会添加一个新的堆栈结构。这个堆栈结构代表了那个函数执行的事务。\n\n处理用户界面时，问题是如果太多的事务同时执行，它可能导致动画掉帧，看起来卡顿。还有，其中的一些事务是不需要的，因为它可能被最近的更新取代了。这就是UI组件和函数不同的地方，因为通常组件比函数有更特殊的关注点。\n\n最新的浏览器（和React Native）实现了API来定位这个问题：`requestIdleCallback`调度一个低优先级的函数在空闲阶段执行，`requestAnimationFrame`调度一个高优先级的函数在下一个动画帧执行。问题在于，要使用这些API，你需要将渲染事务分解为增量单元的方法。如果你仅依赖于调用栈，它将会一直工作直到栈变空。\n\n如果我们能自定义调用栈的行为来优化UI渲染该多好啊？如果我们能主动中断调用栈，手动操作堆栈结构该多好啊？\n\n这就是React Fiber的目的。Fiber是专门为React组件实现的堆栈重构。你可以把单个fiber当做一个**虚拟的堆栈结构(virtual stack frame)**。\n\n重构堆栈的好处是你能[保存堆栈结构在内存里](https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/)，然后用你想要的方式和时机去执行它。这点对于实现我们要的调度功能非常重要。\n\n除了调度，手动操作堆栈结构也使的一些潜在特性变得可能，比如并发和错误边界。我们将会在未来的章节讨论这些话题。\n\n下一节，我们将讨论更多关于fiber的结构。\n\n### 一个fiber的结构\n\n**注意：随着我们讨论更多的实现细节，某些东西被改变的概率也会上升。如果你发现了任何错误或过时的信息，请帮忙提交一下PR。**\n\n具体来说，一个fiber是包含了一个组件及其输入、输出信息的JavaScript对象。\n\n一个fiber对应了一个堆栈结构，同时它也对应了一个组件实例。\n\n下面是fiber的一些重要字段。（这个列表不是完全的。）\n\n#### `type`和`key`\n\nFiber的`type`和`key`的作用和React元素一样。（实际上，一个fiber从组件创建时，这两个字段会直接复制过来）。\n\nFiber的`type`描述了它对应的组件。对于复合组件，`type`就是复合函数或组件的class。对于宿主组件（`div`, `span`等），`type`是一个字符串。\n\n从概念上来说，`type`是执行会被堆栈结构跟踪的函数（即在`v = f(d)`里面的）。\n\n除了`type`之外，`key`是在协调算法中用来决定fiber是否可以重用的字段。\n\n#### `child`和`sibling`\n\n这些字段指向其他的fiber，描述的是fiber的递归树结构。\n\n子fiber(child fiber)指的是组件的`render`方法返回来的值。比如在下面的样例中`Parent`的子fiber就是`Child`。\n\n```\nfunction Parent() {\n  return <Child />\n}\n\n```\n\n兄弟fiber(`sibling` fiber)指代的是`render`方法返回多个子节点的情况（Fiber中的新特性！）：\n\n```\nfunction Parent() {\n  return [<Child1 />, <Child2 />]\n}\n\n```\n\n兄弟fiber形成一个单链表，链表头就是第一个子节点。在上面的例子中，`Parent`的子节点是`Child1`，`Child1`的兄弟节点是`Child2`。\n\n回顾我们前面的函数类比，你可以把子fiber当做是一个[尾调用函数](https://en.wikipedia.org/wiki/Tail_call)。\n\n#### `return`\n\n返回fiber(`return` fiber)是指程序处理完当前的fiber后应当处理的下一个fiber。理论上和一个堆栈结构的返回地址一样。也可以认为是父fiber。\n\n如果一个fiber有多个子fiber，每个子fiber的返回fiber都是它的父fiber。所以在我们上一个例子中，`Child1`和`Child2`的返回fiber都是`Parent`。\n\n#### `pendingProps`和`memoizedProps`\n\n概念上来说，props就是一个函数的参数。一个fiber的`pendingProps`会在它开始执行处设置，`memoizedProps`则会在执行结尾处设置。\n\n当到来的`pendingProps`和上一个`memoizedProps`相等时，它意味着fiber的上一次输出可以重用，避免不必要的事务。\n\n#### `pendingWorkPriority`\n\n指示fiber代表的事务优先级的一个数字。[React优先级](https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js)模块列举了不同的优先级和它们代表的意义。\n\n除了用0表示`NoWork`之外，越大的数字代表了越低的优先级。例如，你可以用下面的函数来检查一个fiber的优先级是不是不低于给定的等级：\n\n```\nfunction matchesPriority(fiber, priority) {\n  return fiber.pendingWorkPriority !== 0 && fiber.pendingWorkPriority <= priority\n}\n\n```\n\n这个函数仅仅是作说明用，它实际上不属于React Fiber代码库。\n\n调度器使用这个优先级字段来搜索下一个要执行的事务。搜索算法会在将来的章节讨论。\n\n#### `alternate`\n\n- `flush`\n\n  冲洗一个fiber就是渲染输出结果到屏幕上。\n\n- `work-in-progress`\n\n  进行中的fiber代表一个未处理完毕的fiber，概念上来说就是一个还未返回的堆栈结构。\n\n在任意一个时刻，一个组件实例最多有两个fiber对应着它：当前fiber（冲洗的fiber）和进行中的fiber。\n\n当前fiber的替代(`alternate`)就是进行中的fiber，进行中的fiber的替代就是当前fiber。\n\n一个fiber的替代是通过`cloneFiber`函数懒创建的。`cloneFiber`会尝试重用fiber的替代（如果存在）来最小化分配空间，而不是总创建新的对象。\n\n你应当把`alternate`当做是一个实现细节，但它在代码里面出现了很多次，所以值得在这里讨论。\n\n#### `output`\n\n- `host component`\n\n  宿主组件(`host component`)是React应用的叶节点。它们是跟特定的渲染环境相关的（比如，在浏览器应用中，宿主组件是指`div`, `span`等）。在JSX中，它们是用小写字母的tag名称表示的。\n\n概念上来说，一个fiber的输出结果就是一个函数的返回值。\n\n每个fiber最终都会有输出结果，但是输出结果是仅由叶节点的**宿主组件**创建的。然后输出结果会向上转移到整个树。\n\n输出结果就是最终交给渲染器的东西，然后渲染器能够将更改冲洗到渲染环境。定义输出结果怎么样创建和更新就是渲染器的职责了。\n\n## 未来的章节\n\n上面就是至今为止的内容了，但是这个文档还远未接近完成。未来的章节将会描述贯穿整个生命周期和更新使用的算法。将覆盖的主题包括：\n\n- 调度器怎么样找到下一个要执行的事务单元\n- 整个fiber树的优先级怎么跟踪和传播\n- 调度器怎么样知道什么时候暂停和继续事务\n- 事务是怎么冲洗和标记为完成的\n- 附带后果（比如声明周期方法）是怎么样工作的\n- 什么是协同程序，和它是怎么样用来实现一些特性比如上下文(context)和布局(layout)的\n\n## 相关视频\n\n- [What's Next for React (ReactNext 2016)](https://www.youtube.com/watch?v=crM1iRVGpGQ)\n\n## [原文链接](https://swenyang.gitbooks.io/yapn/content/react-fiber/)","slug":"React-Fiber架构","published":1,"updated":"2018-02-05T15:38:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzz50002f7kr0eq9xp7h","content":"<h1 id=\"React-Fiber架构\"><a href=\"#React-Fiber架构\" class=\"headerlink\" title=\"React Fiber架构\"></a>React Fiber架构</h1><h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>React Fiber是React核心算法的重写，目前还在开发中。它是React团队过去两年研究的高峰。</p>\n<p>React Fiber的目标是增强对于某些领域的适应性，比如动画、布局和手势等。它的重要特性是<strong>增量渲染</strong>：将渲染事务（work）分块并分布到多个帧去完成的能力。</p>\n<p>其他关键特性包括有新的更新时，暂停、终止或重用事务的功能；为不同类型的更新设置优先级的功能；还有新的并发原语（concurrency primitives）。</p>\n<h3 id=\"关于本文档\"><a href=\"#关于本文档\" class=\"headerlink\" title=\"关于本文档\"></a>关于本文档</h3><p>Fiber引入了几个新颖的概念，单单看代码是很难理解的。本文档起初是React项目在逐步实现Fiber的时候记的笔记集，随着慢慢扩充，我发现这对于其他人来说可能也是很实用的资源。</p>\n<p>我会尽可能的使用简单的语言，通过显式的定义一些术语来避免行话。如果可能，我也会尽可能链接到外部资源。</p>\n<p>注意我并不在React团队里面，不代表任何官方的发言。<strong>这不是官方文档</strong>。不过我请教了React团队的一些成员来检查文档的准确性。</p>\n<p>这也是一项进行中的工作。<strong>Fiber也是一个开发中的项目，在完成之前有可能还会有重大的重构</strong>。所以我在此为它的设计写的文档也是进行中的。非常欢迎提出优化和建议。</p>\n<p>我的目标是读完这篇文档后，你能够理解Fiber足够深来读懂<a href=\"https://github.com/facebook/react/commits/master/src/renderers/shared/fiber\" target=\"_blank\" rel=\"noopener\">它的实现</a>，最终甚至能够返回来给React做一些贡献。</p>\n<h3 id=\"必要的知识\"><a href=\"#必要的知识\" class=\"headerlink\" title=\"必要的知识\"></a>必要的知识</h3><p>我强烈建议在继续看本文档之前，你先熟悉一下以下资源：</p>\n<ul>\n<li><a href=\"https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html\" target=\"_blank\" rel=\"noopener\">React组件，元素和实例</a>：“组件”是经常提起的术语。对这些术语有坚实的认知是非常重要的。</li>\n<li><a href=\"https://facebook.github.io/react/docs/reconciliation.html\" target=\"_blank\" rel=\"noopener\">协调算法</a>：React协调算法的高阶阐述。</li>\n<li><a href=\"https://github.com/reactjs/react-basic\" target=\"_blank\" rel=\"noopener\">React基本理论概念</a>：不带实现细节的React理论模型阐述。其中一些内容可能在第一次阅读时没什么意义，但随着时间推移会证明非常有用。</li>\n<li><a href=\"https://facebook.github.io/react/contributing/design-principles.html\" target=\"_blank\" rel=\"noopener\">React设计原则</a>：特别注意其中的Scheduling环节，它很好的诠释了React Fiber诞生的原因。</li>\n</ul>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>如果你还没阅读“必要的知识”环节，请确认阅读一下。</p>\n<p>在我们学习新的东西前，我们回顾一些概念。</p>\n<h3 id=\"什么是协调算法\"><a href=\"#什么是协调算法\" class=\"headerlink\" title=\"什么是协调算法\"></a>什么是协调算法</h3><ul>\n<li><p>协调算法(reconciliation)</p>\n<p>React用以比较两棵树的算法，其决定哪些部分需要更改。</p>\n</li>\n<li><p>更新(update)</p>\n<p>即渲染React app的数据发生的一个改变。通常是<code>setState</code>的结果。最终会导致重新渲染。</p>\n</li>\n</ul>\n<p>React API的核心思想是让更新能引发整个app及时的重新渲染。这将允许开发者作出声明式的推断，而不用担心app如何有效的从一个状态切换到另一个状态（A到B，B到C，C到A等等）。</p>\n<p>实际上，对于每一次改变都重新渲染app只对一些小型应用有用；现实中，这是极度浪费性能的。React使用了一些优化，能够达到类似重新渲染整个app的效果，同时保持高性能。这些优化就是<strong>协调算法</strong>的一部分。</p>\n<p>协调算法是基于通常被称为“虚拟DOM”技术的。一个高阶的描述是：当你渲染一个React app的时候，会生成app描述的节点树并保存在内存中。然后这个树被输出到渲染环境——比如，在浏览器应用中，它被翻译为一堆DOM操作。当一个app更新时（一般是通过<code>setState</code>），就产生了一棵新树。新树和旧树会进行比较，计算需要哪些操作来更新app。</p>\n<p>虽然Fiber是协调算法的推倒重写，关于<a href=\"https://facebook.github.io/react/docs/reconciliation.html\" target=\"_blank\" rel=\"noopener\">React文档</a>中的高阶知识还是一致的。主要的两点是：</p>\n<ul>\n<li>不同类型的组件很大程度上将会产生不同的树。React将不会比较他们，而是直接用新的完全替代旧的。</li>\n<li>列表的diff使用key。Key应当是稳定、可预测、并且唯一的。</li>\n</ul>\n<h3 id=\"协调算法-vs-渲染\"><a href=\"#协调算法-vs-渲染\" class=\"headerlink\" title=\"协调算法 vs 渲染\"></a>协调算法 vs 渲染</h3><p>DOM只是React可以输出的渲染环境之一，其他的一些主要目标包括通过React Native输出到原生的iOS和Android视图。（这也就是为什么“虚拟DOM”是有点用词不当的）。</p>\n<p>React支持这么多目标的原因是因为它将协调算法和渲染设计成了不同的阶段。协调算法负责计算一棵树哪些部分更改了；渲染器则利用该信息来实际更新app。</p>\n<p>这个分离意味着React DOM和React Native能共享React核心提供的协调算法，而使用它们各自的渲染器。</p>\n<p>Fiber重构了协调器。Fiber不是渲染需要首要考虑的，但渲染器需要改变来支持（并且利用）新的架构。</p>\n<h3 id=\"调度-Scheduling\"><a href=\"#调度-Scheduling\" class=\"headerlink\" title=\"调度(Scheduling)\"></a>调度(Scheduling)</h3><ul>\n<li><p>调度(scheduling)</p>\n<p>决定事务什么时候执行的过程。</p>\n</li>\n<li><p>事务(work)</p>\n<p>必须执行的计算。事务一般是由update引起的（比如<code>setState</code>）。</p>\n</li>\n</ul>\n<p>React的<a href=\"https://facebook.github.io/react/contributing/design-principles.html#scheduling\" target=\"_blank\" rel=\"noopener\">设计原则文档</a>在这方面写的很好，我引用如下：</p>\n<blockquote>\n<p>在当前的实现中，React递归遍历节点树，在一个tick内调用整棵新树的渲染函数。但是未来有可能推迟一些更新来避免掉帧。</p>\n<p>这是React设计的一个常见主题。一些流行的库采用”push”方法，在新的数据就绪的时候就执行计算。React仍然使用”pull”方法，计算可以推迟到需要的时候才执行。</p>\n<p>React不是通用的数据处理库。它是用以建立用户界面的库。我们认为在一个app中，知道计算是相关还是不相关的是独一无二的重要。</p>\n<p>如果某些东西超出了屏幕显示，我们可以延迟它相关的所有逻辑。如果数据到达的比帧率要快，我们可以合并和批处理更新。我们可以优先处理用户交互的事务（比如点击按钮引起的动画），次要处理没那么重要的背景事务（比如渲染刚从网络上返回的数据）来避免掉帧。</p>\n</blockquote>\n<p>关键点在于：</p>\n<ul>\n<li>在用户界面中，没必要每一个更新都立即执行；实际上这样做是很浪费的，导致掉帧，降低用户体验。</li>\n<li>不同类型的更新具有不同的优先级——一个动画更新需要比数据源的更新更快的完成。</li>\n<li>一个基于push的app需要应用（你，程序员）来决定怎么调度事务。基于pull的app允许框架(React)变得智能化，帮你完成这些决策。</li>\n</ul>\n<p>React现在没有很重要地利用调度；一个更新会引发整个子树被立即重新渲染。革新React的核心算法来充分利用调度是Fiber背后的驱动想法。</p>\n<hr>\n<p>现在我们已经准备好了深入Fiber的实现。下一节比我们前面讨论的都要更偏技术一点。继续之前，确认你学习好了前面的知识点。</p>\n<h2 id=\"什么是Fiber？\"><a href=\"#什么是Fiber？\" class=\"headerlink\" title=\"什么是Fiber？\"></a>什么是Fiber？</h2><p>我们将要讨论React Fiber架构的核心部分。Fibers是比应用开发者通常思考的部分要低很多的底层抽象。如果你发现很难理解它，不要丧气。多尝试几次，最终你就能理解。（如果你最后懂了，请提些建议来改进这节内容。）</p>\n<p>出发！</p>\n<hr>\n<p>我们前面已经确定了Fiber的主要目标是使React能够充分利用调度。详细来说，我们需要能够：</p>\n<ul>\n<li>暂停事务，在一段时间后再接着执行。</li>\n<li>分配不同类型事务的优先级。</li>\n<li>复用之前已完成的事务。</li>\n<li>当事务不再需要时，终止该事务。</li>\n</ul>\n<p>为了实现上面的任意一个功能，首先我们需要分解事务为若干单元的方法。在某种意义上那就是一个fiber。一个fiber代表了事务的一个单元。</p>\n<p>更进一步之前，我们重温一下<a href=\"https://github.com/reactjs/react-basic#transformation\" target=\"_blank\" rel=\"noopener\">React组件是数据的函数</a>的概念，通常表达为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v = f(d)</span><br></pre></td></tr></table></figure>\n<p>它表明渲染一个React app类似于调用一个函数，这个函数体里面包含了对其他函数的调用，以此类推。这个类比在思考fiber的时候很有帮助。</p>\n<p>计算机跟踪一个程序执行的方式是<a href=\"https://en.wikipedia.org/wiki/Call_stack\" target=\"_blank\" rel=\"noopener\">调用栈（call stack）</a>。当一个函数执行的时候，栈上面就会添加一个新的堆栈结构。这个堆栈结构代表了那个函数执行的事务。</p>\n<p>处理用户界面时，问题是如果太多的事务同时执行，它可能导致动画掉帧，看起来卡顿。还有，其中的一些事务是不需要的，因为它可能被最近的更新取代了。这就是UI组件和函数不同的地方，因为通常组件比函数有更特殊的关注点。</p>\n<p>最新的浏览器（和React Native）实现了API来定位这个问题：<code>requestIdleCallback</code>调度一个低优先级的函数在空闲阶段执行，<code>requestAnimationFrame</code>调度一个高优先级的函数在下一个动画帧执行。问题在于，要使用这些API，你需要将渲染事务分解为增量单元的方法。如果你仅依赖于调用栈，它将会一直工作直到栈变空。</p>\n<p>如果我们能自定义调用栈的行为来优化UI渲染该多好啊？如果我们能主动中断调用栈，手动操作堆栈结构该多好啊？</p>\n<p>这就是React Fiber的目的。Fiber是专门为React组件实现的堆栈重构。你可以把单个fiber当做一个<strong>虚拟的堆栈结构(virtual stack frame)</strong>。</p>\n<p>重构堆栈的好处是你能<a href=\"https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/\" target=\"_blank\" rel=\"noopener\">保存堆栈结构在内存里</a>，然后用你想要的方式和时机去执行它。这点对于实现我们要的调度功能非常重要。</p>\n<p>除了调度，手动操作堆栈结构也使的一些潜在特性变得可能，比如并发和错误边界。我们将会在未来的章节讨论这些话题。</p>\n<p>下一节，我们将讨论更多关于fiber的结构。</p>\n<h3 id=\"一个fiber的结构\"><a href=\"#一个fiber的结构\" class=\"headerlink\" title=\"一个fiber的结构\"></a>一个fiber的结构</h3><p><strong>注意：随着我们讨论更多的实现细节，某些东西被改变的概率也会上升。如果你发现了任何错误或过时的信息，请帮忙提交一下PR。</strong></p>\n<p>具体来说，一个fiber是包含了一个组件及其输入、输出信息的JavaScript对象。</p>\n<p>一个fiber对应了一个堆栈结构，同时它也对应了一个组件实例。</p>\n<p>下面是fiber的一些重要字段。（这个列表不是完全的。）</p>\n<h4 id=\"type和key\"><a href=\"#type和key\" class=\"headerlink\" title=\"type和key\"></a><code>type</code>和<code>key</code></h4><p>Fiber的<code>type</code>和<code>key</code>的作用和React元素一样。（实际上，一个fiber从组件创建时，这两个字段会直接复制过来）。</p>\n<p>Fiber的<code>type</code>描述了它对应的组件。对于复合组件，<code>type</code>就是复合函数或组件的class。对于宿主组件（<code>div</code>, <code>span</code>等），<code>type</code>是一个字符串。</p>\n<p>从概念上来说，<code>type</code>是执行会被堆栈结构跟踪的函数（即在<code>v = f(d)</code>里面的）。</p>\n<p>除了<code>type</code>之外，<code>key</code>是在协调算法中用来决定fiber是否可以重用的字段。</p>\n<h4 id=\"child和sibling\"><a href=\"#child和sibling\" class=\"headerlink\" title=\"child和sibling\"></a><code>child</code>和<code>sibling</code></h4><p>这些字段指向其他的fiber，描述的是fiber的递归树结构。</p>\n<p>子fiber(child fiber)指的是组件的<code>render</code>方法返回来的值。比如在下面的样例中<code>Parent</code>的子fiber就是<code>Child</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">  return &lt;Child /&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>兄弟fiber(<code>sibling</code> fiber)指代的是<code>render</code>方法返回多个子节点的情况（Fiber中的新特性！）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">  return [&lt;Child1 /&gt;, &lt;Child2 /&gt;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>兄弟fiber形成一个单链表，链表头就是第一个子节点。在上面的例子中，<code>Parent</code>的子节点是<code>Child1</code>，<code>Child1</code>的兄弟节点是<code>Child2</code>。</p>\n<p>回顾我们前面的函数类比，你可以把子fiber当做是一个<a href=\"https://en.wikipedia.org/wiki/Tail_call\" target=\"_blank\" rel=\"noopener\">尾调用函数</a>。</p>\n<h4 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a><code>return</code></h4><p>返回fiber(<code>return</code> fiber)是指程序处理完当前的fiber后应当处理的下一个fiber。理论上和一个堆栈结构的返回地址一样。也可以认为是父fiber。</p>\n<p>如果一个fiber有多个子fiber，每个子fiber的返回fiber都是它的父fiber。所以在我们上一个例子中，<code>Child1</code>和<code>Child2</code>的返回fiber都是<code>Parent</code>。</p>\n<h4 id=\"pendingProps和memoizedProps\"><a href=\"#pendingProps和memoizedProps\" class=\"headerlink\" title=\"pendingProps和memoizedProps\"></a><code>pendingProps</code>和<code>memoizedProps</code></h4><p>概念上来说，props就是一个函数的参数。一个fiber的<code>pendingProps</code>会在它开始执行处设置，<code>memoizedProps</code>则会在执行结尾处设置。</p>\n<p>当到来的<code>pendingProps</code>和上一个<code>memoizedProps</code>相等时，它意味着fiber的上一次输出可以重用，避免不必要的事务。</p>\n<h4 id=\"pendingWorkPriority\"><a href=\"#pendingWorkPriority\" class=\"headerlink\" title=\"pendingWorkPriority\"></a><code>pendingWorkPriority</code></h4><p>指示fiber代表的事务优先级的一个数字。<a href=\"https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js\" target=\"_blank\" rel=\"noopener\">React优先级</a>模块列举了不同的优先级和它们代表的意义。</p>\n<p>除了用0表示<code>NoWork</code>之外，越大的数字代表了越低的优先级。例如，你可以用下面的函数来检查一个fiber的优先级是不是不低于给定的等级：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function matchesPriority(fiber, priority) &#123;</span><br><span class=\"line\">  return fiber.pendingWorkPriority !== 0 &amp;&amp; fiber.pendingWorkPriority &lt;= priority</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数仅仅是作说明用，它实际上不属于React Fiber代码库。</p>\n<p>调度器使用这个优先级字段来搜索下一个要执行的事务。搜索算法会在将来的章节讨论。</p>\n<h4 id=\"alternate\"><a href=\"#alternate\" class=\"headerlink\" title=\"alternate\"></a><code>alternate</code></h4><ul>\n<li><p><code>flush</code></p>\n<p>冲洗一个fiber就是渲染输出结果到屏幕上。</p>\n</li>\n<li><p><code>work-in-progress</code></p>\n<p>进行中的fiber代表一个未处理完毕的fiber，概念上来说就是一个还未返回的堆栈结构。</p>\n</li>\n</ul>\n<p>在任意一个时刻，一个组件实例最多有两个fiber对应着它：当前fiber（冲洗的fiber）和进行中的fiber。</p>\n<p>当前fiber的替代(<code>alternate</code>)就是进行中的fiber，进行中的fiber的替代就是当前fiber。</p>\n<p>一个fiber的替代是通过<code>cloneFiber</code>函数懒创建的。<code>cloneFiber</code>会尝试重用fiber的替代（如果存在）来最小化分配空间，而不是总创建新的对象。</p>\n<p>你应当把<code>alternate</code>当做是一个实现细节，但它在代码里面出现了很多次，所以值得在这里讨论。</p>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a><code>output</code></h4><ul>\n<li><p><code>host component</code></p>\n<p>宿主组件(<code>host component</code>)是React应用的叶节点。它们是跟特定的渲染环境相关的（比如，在浏览器应用中，宿主组件是指<code>div</code>, <code>span</code>等）。在JSX中，它们是用小写字母的tag名称表示的。</p>\n</li>\n</ul>\n<p>概念上来说，一个fiber的输出结果就是一个函数的返回值。</p>\n<p>每个fiber最终都会有输出结果，但是输出结果是仅由叶节点的<strong>宿主组件</strong>创建的。然后输出结果会向上转移到整个树。</p>\n<p>输出结果就是最终交给渲染器的东西，然后渲染器能够将更改冲洗到渲染环境。定义输出结果怎么样创建和更新就是渲染器的职责了。</p>\n<h2 id=\"未来的章节\"><a href=\"#未来的章节\" class=\"headerlink\" title=\"未来的章节\"></a>未来的章节</h2><p>上面就是至今为止的内容了，但是这个文档还远未接近完成。未来的章节将会描述贯穿整个生命周期和更新使用的算法。将覆盖的主题包括：</p>\n<ul>\n<li>调度器怎么样找到下一个要执行的事务单元</li>\n<li>整个fiber树的优先级怎么跟踪和传播</li>\n<li>调度器怎么样知道什么时候暂停和继续事务</li>\n<li>事务是怎么冲洗和标记为完成的</li>\n<li>附带后果（比如声明周期方法）是怎么样工作的</li>\n<li>什么是协同程序，和它是怎么样用来实现一些特性比如上下文(context)和布局(layout)的</li>\n</ul>\n<h2 id=\"相关视频\"><a href=\"#相关视频\" class=\"headerlink\" title=\"相关视频\"></a>相关视频</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=crM1iRVGpGQ\" target=\"_blank\" rel=\"noopener\">What’s Next for React (ReactNext 2016)</a></li>\n</ul>\n<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a><a href=\"https://swenyang.gitbooks.io/yapn/content/react-fiber/\" target=\"_blank\" rel=\"noopener\">原文链接</a></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React-Fiber架构\"><a href=\"#React-Fiber架构\" class=\"headerlink\" title=\"React Fiber架构\"></a>React Fiber架构</h1><h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>React Fiber是React核心算法的重写，目前还在开发中。它是React团队过去两年研究的高峰。</p>\n<p>React Fiber的目标是增强对于某些领域的适应性，比如动画、布局和手势等。它的重要特性是<strong>增量渲染</strong>：将渲染事务（work）分块并分布到多个帧去完成的能力。</p>\n<p>其他关键特性包括有新的更新时，暂停、终止或重用事务的功能；为不同类型的更新设置优先级的功能；还有新的并发原语（concurrency primitives）。</p>\n<h3 id=\"关于本文档\"><a href=\"#关于本文档\" class=\"headerlink\" title=\"关于本文档\"></a>关于本文档</h3><p>Fiber引入了几个新颖的概念，单单看代码是很难理解的。本文档起初是React项目在逐步实现Fiber的时候记的笔记集，随着慢慢扩充，我发现这对于其他人来说可能也是很实用的资源。</p>\n<p>我会尽可能的使用简单的语言，通过显式的定义一些术语来避免行话。如果可能，我也会尽可能链接到外部资源。</p>\n<p>注意我并不在React团队里面，不代表任何官方的发言。<strong>这不是官方文档</strong>。不过我请教了React团队的一些成员来检查文档的准确性。</p>\n<p>这也是一项进行中的工作。<strong>Fiber也是一个开发中的项目，在完成之前有可能还会有重大的重构</strong>。所以我在此为它的设计写的文档也是进行中的。非常欢迎提出优化和建议。</p>\n<p>我的目标是读完这篇文档后，你能够理解Fiber足够深来读懂<a href=\"https://github.com/facebook/react/commits/master/src/renderers/shared/fiber\" target=\"_blank\" rel=\"noopener\">它的实现</a>，最终甚至能够返回来给React做一些贡献。</p>\n<h3 id=\"必要的知识\"><a href=\"#必要的知识\" class=\"headerlink\" title=\"必要的知识\"></a>必要的知识</h3><p>我强烈建议在继续看本文档之前，你先熟悉一下以下资源：</p>\n<ul>\n<li><a href=\"https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html\" target=\"_blank\" rel=\"noopener\">React组件，元素和实例</a>：“组件”是经常提起的术语。对这些术语有坚实的认知是非常重要的。</li>\n<li><a href=\"https://facebook.github.io/react/docs/reconciliation.html\" target=\"_blank\" rel=\"noopener\">协调算法</a>：React协调算法的高阶阐述。</li>\n<li><a href=\"https://github.com/reactjs/react-basic\" target=\"_blank\" rel=\"noopener\">React基本理论概念</a>：不带实现细节的React理论模型阐述。其中一些内容可能在第一次阅读时没什么意义，但随着时间推移会证明非常有用。</li>\n<li><a href=\"https://facebook.github.io/react/contributing/design-principles.html\" target=\"_blank\" rel=\"noopener\">React设计原则</a>：特别注意其中的Scheduling环节，它很好的诠释了React Fiber诞生的原因。</li>\n</ul>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>如果你还没阅读“必要的知识”环节，请确认阅读一下。</p>\n<p>在我们学习新的东西前，我们回顾一些概念。</p>\n<h3 id=\"什么是协调算法\"><a href=\"#什么是协调算法\" class=\"headerlink\" title=\"什么是协调算法\"></a>什么是协调算法</h3><ul>\n<li><p>协调算法(reconciliation)</p>\n<p>React用以比较两棵树的算法，其决定哪些部分需要更改。</p>\n</li>\n<li><p>更新(update)</p>\n<p>即渲染React app的数据发生的一个改变。通常是<code>setState</code>的结果。最终会导致重新渲染。</p>\n</li>\n</ul>\n<p>React API的核心思想是让更新能引发整个app及时的重新渲染。这将允许开发者作出声明式的推断，而不用担心app如何有效的从一个状态切换到另一个状态（A到B，B到C，C到A等等）。</p>\n<p>实际上，对于每一次改变都重新渲染app只对一些小型应用有用；现实中，这是极度浪费性能的。React使用了一些优化，能够达到类似重新渲染整个app的效果，同时保持高性能。这些优化就是<strong>协调算法</strong>的一部分。</p>\n<p>协调算法是基于通常被称为“虚拟DOM”技术的。一个高阶的描述是：当你渲染一个React app的时候，会生成app描述的节点树并保存在内存中。然后这个树被输出到渲染环境——比如，在浏览器应用中，它被翻译为一堆DOM操作。当一个app更新时（一般是通过<code>setState</code>），就产生了一棵新树。新树和旧树会进行比较，计算需要哪些操作来更新app。</p>\n<p>虽然Fiber是协调算法的推倒重写，关于<a href=\"https://facebook.github.io/react/docs/reconciliation.html\" target=\"_blank\" rel=\"noopener\">React文档</a>中的高阶知识还是一致的。主要的两点是：</p>\n<ul>\n<li>不同类型的组件很大程度上将会产生不同的树。React将不会比较他们，而是直接用新的完全替代旧的。</li>\n<li>列表的diff使用key。Key应当是稳定、可预测、并且唯一的。</li>\n</ul>\n<h3 id=\"协调算法-vs-渲染\"><a href=\"#协调算法-vs-渲染\" class=\"headerlink\" title=\"协调算法 vs 渲染\"></a>协调算法 vs 渲染</h3><p>DOM只是React可以输出的渲染环境之一，其他的一些主要目标包括通过React Native输出到原生的iOS和Android视图。（这也就是为什么“虚拟DOM”是有点用词不当的）。</p>\n<p>React支持这么多目标的原因是因为它将协调算法和渲染设计成了不同的阶段。协调算法负责计算一棵树哪些部分更改了；渲染器则利用该信息来实际更新app。</p>\n<p>这个分离意味着React DOM和React Native能共享React核心提供的协调算法，而使用它们各自的渲染器。</p>\n<p>Fiber重构了协调器。Fiber不是渲染需要首要考虑的，但渲染器需要改变来支持（并且利用）新的架构。</p>\n<h3 id=\"调度-Scheduling\"><a href=\"#调度-Scheduling\" class=\"headerlink\" title=\"调度(Scheduling)\"></a>调度(Scheduling)</h3><ul>\n<li><p>调度(scheduling)</p>\n<p>决定事务什么时候执行的过程。</p>\n</li>\n<li><p>事务(work)</p>\n<p>必须执行的计算。事务一般是由update引起的（比如<code>setState</code>）。</p>\n</li>\n</ul>\n<p>React的<a href=\"https://facebook.github.io/react/contributing/design-principles.html#scheduling\" target=\"_blank\" rel=\"noopener\">设计原则文档</a>在这方面写的很好，我引用如下：</p>\n<blockquote>\n<p>在当前的实现中，React递归遍历节点树，在一个tick内调用整棵新树的渲染函数。但是未来有可能推迟一些更新来避免掉帧。</p>\n<p>这是React设计的一个常见主题。一些流行的库采用”push”方法，在新的数据就绪的时候就执行计算。React仍然使用”pull”方法，计算可以推迟到需要的时候才执行。</p>\n<p>React不是通用的数据处理库。它是用以建立用户界面的库。我们认为在一个app中，知道计算是相关还是不相关的是独一无二的重要。</p>\n<p>如果某些东西超出了屏幕显示，我们可以延迟它相关的所有逻辑。如果数据到达的比帧率要快，我们可以合并和批处理更新。我们可以优先处理用户交互的事务（比如点击按钮引起的动画），次要处理没那么重要的背景事务（比如渲染刚从网络上返回的数据）来避免掉帧。</p>\n</blockquote>\n<p>关键点在于：</p>\n<ul>\n<li>在用户界面中，没必要每一个更新都立即执行；实际上这样做是很浪费的，导致掉帧，降低用户体验。</li>\n<li>不同类型的更新具有不同的优先级——一个动画更新需要比数据源的更新更快的完成。</li>\n<li>一个基于push的app需要应用（你，程序员）来决定怎么调度事务。基于pull的app允许框架(React)变得智能化，帮你完成这些决策。</li>\n</ul>\n<p>React现在没有很重要地利用调度；一个更新会引发整个子树被立即重新渲染。革新React的核心算法来充分利用调度是Fiber背后的驱动想法。</p>\n<hr>\n<p>现在我们已经准备好了深入Fiber的实现。下一节比我们前面讨论的都要更偏技术一点。继续之前，确认你学习好了前面的知识点。</p>\n<h2 id=\"什么是Fiber？\"><a href=\"#什么是Fiber？\" class=\"headerlink\" title=\"什么是Fiber？\"></a>什么是Fiber？</h2><p>我们将要讨论React Fiber架构的核心部分。Fibers是比应用开发者通常思考的部分要低很多的底层抽象。如果你发现很难理解它，不要丧气。多尝试几次，最终你就能理解。（如果你最后懂了，请提些建议来改进这节内容。）</p>\n<p>出发！</p>\n<hr>\n<p>我们前面已经确定了Fiber的主要目标是使React能够充分利用调度。详细来说，我们需要能够：</p>\n<ul>\n<li>暂停事务，在一段时间后再接着执行。</li>\n<li>分配不同类型事务的优先级。</li>\n<li>复用之前已完成的事务。</li>\n<li>当事务不再需要时，终止该事务。</li>\n</ul>\n<p>为了实现上面的任意一个功能，首先我们需要分解事务为若干单元的方法。在某种意义上那就是一个fiber。一个fiber代表了事务的一个单元。</p>\n<p>更进一步之前，我们重温一下<a href=\"https://github.com/reactjs/react-basic#transformation\" target=\"_blank\" rel=\"noopener\">React组件是数据的函数</a>的概念，通常表达为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v = f(d)</span><br></pre></td></tr></table></figure>\n<p>它表明渲染一个React app类似于调用一个函数，这个函数体里面包含了对其他函数的调用，以此类推。这个类比在思考fiber的时候很有帮助。</p>\n<p>计算机跟踪一个程序执行的方式是<a href=\"https://en.wikipedia.org/wiki/Call_stack\" target=\"_blank\" rel=\"noopener\">调用栈（call stack）</a>。当一个函数执行的时候，栈上面就会添加一个新的堆栈结构。这个堆栈结构代表了那个函数执行的事务。</p>\n<p>处理用户界面时，问题是如果太多的事务同时执行，它可能导致动画掉帧，看起来卡顿。还有，其中的一些事务是不需要的，因为它可能被最近的更新取代了。这就是UI组件和函数不同的地方，因为通常组件比函数有更特殊的关注点。</p>\n<p>最新的浏览器（和React Native）实现了API来定位这个问题：<code>requestIdleCallback</code>调度一个低优先级的函数在空闲阶段执行，<code>requestAnimationFrame</code>调度一个高优先级的函数在下一个动画帧执行。问题在于，要使用这些API，你需要将渲染事务分解为增量单元的方法。如果你仅依赖于调用栈，它将会一直工作直到栈变空。</p>\n<p>如果我们能自定义调用栈的行为来优化UI渲染该多好啊？如果我们能主动中断调用栈，手动操作堆栈结构该多好啊？</p>\n<p>这就是React Fiber的目的。Fiber是专门为React组件实现的堆栈重构。你可以把单个fiber当做一个<strong>虚拟的堆栈结构(virtual stack frame)</strong>。</p>\n<p>重构堆栈的好处是你能<a href=\"https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/\" target=\"_blank\" rel=\"noopener\">保存堆栈结构在内存里</a>，然后用你想要的方式和时机去执行它。这点对于实现我们要的调度功能非常重要。</p>\n<p>除了调度，手动操作堆栈结构也使的一些潜在特性变得可能，比如并发和错误边界。我们将会在未来的章节讨论这些话题。</p>\n<p>下一节，我们将讨论更多关于fiber的结构。</p>\n<h3 id=\"一个fiber的结构\"><a href=\"#一个fiber的结构\" class=\"headerlink\" title=\"一个fiber的结构\"></a>一个fiber的结构</h3><p><strong>注意：随着我们讨论更多的实现细节，某些东西被改变的概率也会上升。如果你发现了任何错误或过时的信息，请帮忙提交一下PR。</strong></p>\n<p>具体来说，一个fiber是包含了一个组件及其输入、输出信息的JavaScript对象。</p>\n<p>一个fiber对应了一个堆栈结构，同时它也对应了一个组件实例。</p>\n<p>下面是fiber的一些重要字段。（这个列表不是完全的。）</p>\n<h4 id=\"type和key\"><a href=\"#type和key\" class=\"headerlink\" title=\"type和key\"></a><code>type</code>和<code>key</code></h4><p>Fiber的<code>type</code>和<code>key</code>的作用和React元素一样。（实际上，一个fiber从组件创建时，这两个字段会直接复制过来）。</p>\n<p>Fiber的<code>type</code>描述了它对应的组件。对于复合组件，<code>type</code>就是复合函数或组件的class。对于宿主组件（<code>div</code>, <code>span</code>等），<code>type</code>是一个字符串。</p>\n<p>从概念上来说，<code>type</code>是执行会被堆栈结构跟踪的函数（即在<code>v = f(d)</code>里面的）。</p>\n<p>除了<code>type</code>之外，<code>key</code>是在协调算法中用来决定fiber是否可以重用的字段。</p>\n<h4 id=\"child和sibling\"><a href=\"#child和sibling\" class=\"headerlink\" title=\"child和sibling\"></a><code>child</code>和<code>sibling</code></h4><p>这些字段指向其他的fiber，描述的是fiber的递归树结构。</p>\n<p>子fiber(child fiber)指的是组件的<code>render</code>方法返回来的值。比如在下面的样例中<code>Parent</code>的子fiber就是<code>Child</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">  return &lt;Child /&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>兄弟fiber(<code>sibling</code> fiber)指代的是<code>render</code>方法返回多个子节点的情况（Fiber中的新特性！）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">  return [&lt;Child1 /&gt;, &lt;Child2 /&gt;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>兄弟fiber形成一个单链表，链表头就是第一个子节点。在上面的例子中，<code>Parent</code>的子节点是<code>Child1</code>，<code>Child1</code>的兄弟节点是<code>Child2</code>。</p>\n<p>回顾我们前面的函数类比，你可以把子fiber当做是一个<a href=\"https://en.wikipedia.org/wiki/Tail_call\" target=\"_blank\" rel=\"noopener\">尾调用函数</a>。</p>\n<h4 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a><code>return</code></h4><p>返回fiber(<code>return</code> fiber)是指程序处理完当前的fiber后应当处理的下一个fiber。理论上和一个堆栈结构的返回地址一样。也可以认为是父fiber。</p>\n<p>如果一个fiber有多个子fiber，每个子fiber的返回fiber都是它的父fiber。所以在我们上一个例子中，<code>Child1</code>和<code>Child2</code>的返回fiber都是<code>Parent</code>。</p>\n<h4 id=\"pendingProps和memoizedProps\"><a href=\"#pendingProps和memoizedProps\" class=\"headerlink\" title=\"pendingProps和memoizedProps\"></a><code>pendingProps</code>和<code>memoizedProps</code></h4><p>概念上来说，props就是一个函数的参数。一个fiber的<code>pendingProps</code>会在它开始执行处设置，<code>memoizedProps</code>则会在执行结尾处设置。</p>\n<p>当到来的<code>pendingProps</code>和上一个<code>memoizedProps</code>相等时，它意味着fiber的上一次输出可以重用，避免不必要的事务。</p>\n<h4 id=\"pendingWorkPriority\"><a href=\"#pendingWorkPriority\" class=\"headerlink\" title=\"pendingWorkPriority\"></a><code>pendingWorkPriority</code></h4><p>指示fiber代表的事务优先级的一个数字。<a href=\"https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js\" target=\"_blank\" rel=\"noopener\">React优先级</a>模块列举了不同的优先级和它们代表的意义。</p>\n<p>除了用0表示<code>NoWork</code>之外，越大的数字代表了越低的优先级。例如，你可以用下面的函数来检查一个fiber的优先级是不是不低于给定的等级：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function matchesPriority(fiber, priority) &#123;</span><br><span class=\"line\">  return fiber.pendingWorkPriority !== 0 &amp;&amp; fiber.pendingWorkPriority &lt;= priority</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数仅仅是作说明用，它实际上不属于React Fiber代码库。</p>\n<p>调度器使用这个优先级字段来搜索下一个要执行的事务。搜索算法会在将来的章节讨论。</p>\n<h4 id=\"alternate\"><a href=\"#alternate\" class=\"headerlink\" title=\"alternate\"></a><code>alternate</code></h4><ul>\n<li><p><code>flush</code></p>\n<p>冲洗一个fiber就是渲染输出结果到屏幕上。</p>\n</li>\n<li><p><code>work-in-progress</code></p>\n<p>进行中的fiber代表一个未处理完毕的fiber，概念上来说就是一个还未返回的堆栈结构。</p>\n</li>\n</ul>\n<p>在任意一个时刻，一个组件实例最多有两个fiber对应着它：当前fiber（冲洗的fiber）和进行中的fiber。</p>\n<p>当前fiber的替代(<code>alternate</code>)就是进行中的fiber，进行中的fiber的替代就是当前fiber。</p>\n<p>一个fiber的替代是通过<code>cloneFiber</code>函数懒创建的。<code>cloneFiber</code>会尝试重用fiber的替代（如果存在）来最小化分配空间，而不是总创建新的对象。</p>\n<p>你应当把<code>alternate</code>当做是一个实现细节，但它在代码里面出现了很多次，所以值得在这里讨论。</p>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a><code>output</code></h4><ul>\n<li><p><code>host component</code></p>\n<p>宿主组件(<code>host component</code>)是React应用的叶节点。它们是跟特定的渲染环境相关的（比如，在浏览器应用中，宿主组件是指<code>div</code>, <code>span</code>等）。在JSX中，它们是用小写字母的tag名称表示的。</p>\n</li>\n</ul>\n<p>概念上来说，一个fiber的输出结果就是一个函数的返回值。</p>\n<p>每个fiber最终都会有输出结果，但是输出结果是仅由叶节点的<strong>宿主组件</strong>创建的。然后输出结果会向上转移到整个树。</p>\n<p>输出结果就是最终交给渲染器的东西，然后渲染器能够将更改冲洗到渲染环境。定义输出结果怎么样创建和更新就是渲染器的职责了。</p>\n<h2 id=\"未来的章节\"><a href=\"#未来的章节\" class=\"headerlink\" title=\"未来的章节\"></a>未来的章节</h2><p>上面就是至今为止的内容了，但是这个文档还远未接近完成。未来的章节将会描述贯穿整个生命周期和更新使用的算法。将覆盖的主题包括：</p>\n<ul>\n<li>调度器怎么样找到下一个要执行的事务单元</li>\n<li>整个fiber树的优先级怎么跟踪和传播</li>\n<li>调度器怎么样知道什么时候暂停和继续事务</li>\n<li>事务是怎么冲洗和标记为完成的</li>\n<li>附带后果（比如声明周期方法）是怎么样工作的</li>\n<li>什么是协同程序，和它是怎么样用来实现一些特性比如上下文(context)和布局(layout)的</li>\n</ul>\n<h2 id=\"相关视频\"><a href=\"#相关视频\" class=\"headerlink\" title=\"相关视频\"></a>相关视频</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=crM1iRVGpGQ\" target=\"_blank\" rel=\"noopener\">What’s Next for React (ReactNext 2016)</a></li>\n</ul>\n<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a><a href=\"https://swenyang.gitbooks.io/yapn/content/react-fiber/\" target=\"_blank\" rel=\"noopener\">原文链接</a></h2>"},{"title":"React元素和组件","date":"2018-01-31T01:03:54.000Z","_content":"![](http://p2oiag4fy.bkt.clouddn.com/React.jpeg)\n# 一 、属性和状态\n\n### (一)什么是属性？\n\nprops=properties \n\n#### 1、属性的含义和用法\n\n含义 ：一个事物的性质与关系，属性往往是与生俱来的、无法自己改变的。\n\n3种用法 ：\n\n(1)键值对\n\n传入一个字符串：\n\n```js\n'Hello,World!' 或 {'Hello,World!'}\n```\n\n传入一个数组：\n\n```js\n{[Array1,Array2,Array3]}\n```\n\n传入一个变量：\n\n```js\n{variable}\n```\n\n(2)展开对象形式\n\n```js\nvar props = {\n\tone:\"123\",\n\ttwo:321\n\t}\n<HelloWorld {...props}/>\n```\n\nReact提供展开语法…,使用…加对象,react就会把对象中的属性和值，当成是属性的赋值。\n\n(3)setProps形式：\n\n通过组件更新属性，不能在组件内部中修改属性的，因为会违背组件设计原则（尽量避免）\n\n```js\n<script type=\"text/babel\">\n    var HelloWorld = React.createClass({\n        render: function(){\n            return <p>Hello, {this.props.name}</p>\n        }\n    });\n    var instance = ReactDOM.render(<HelloWorld></HelloWorld>, document.querySelector(\"#example\"));\n    instance.setProps({name: \"William\"});\n</script>\n```\n\nsetProps接收的参数是一个对象，但是react不推荐改变组件的属性,可以通过父组件向子组件传入的方式。\n\n### (二)什么是状态？\n\nstate\n\n#### 1、状态的含义和用法\n\n含义 ：事物所处的状况。状态是由事物自行处理、不断变化的，是事物的私有属性。 \n\n用法：\n\ngetInitialState:初始化每个实例特有的状态 \nsetState:更新组件状态 \n使用setState——启用diff算法——有变化，更新DOM\n\n```js\n\t//使用状态 state，实现时钟\n    class Time extends React.Component{\n        //构造器函数（初始化函数）：初始化\n        constructor(props) {\n            super(props);\n            //初始化状态\n            this.state={\n                date:new Date()\n            }\n            //修改状态:每隔一秒，修改状态\n            setInterval(()=>{\n                console.log('定时器执行');\n                this.setState({\n                    date:new Date()\n                })\n            },1000);\n        }\n        render(){\n            console.log('时间',this.state.date);\n            return(\n                //使用\n                <p>当前时间:  {this.state.date.toLocaleTimeString()}</p>\n            );\n        }\n    }\n    ReactDOM.render(\n        <Time />,\n        document.getElementById('root')\n        );\n```\n\n### (三)属性和状态对比 \n\n属性和状态作为组件之间数据流动的途径，非常容易混用，下面对属性和状态进行对比，介绍两者的相同点、不同点以及使用方法。\n\n#### 1、相同点\n\n- 都是纯JS对象\n- 都会触发render更新\n- 都具有确定性\n\n#### 2、对比\n\n| -            | 属性( props) | 状态(state) |\n| ------------ | :--------: | :-------: |\n| 能否从父组件获取初始值  |     √      |     ×     |\n| 能否由父组件修改     |     √      |     ×     |\n| 能否在组件内部设置默认值 |     √      |     √     |\n| 能否在组件内部修改    |     ×      |     √     |\n| 能否设置子组件的初始值  |     √      |     ×     |\n| 能否修改子组件的值    |     √      |     ×     |\n\n状态只和组件本身相关，组件不能修改属性\n\n#### 3、区分\n\n- 状态和属性都会触发render更新，都是纯JS对象\n\n- 状态：是和自己相关的，既不受父组件也不受子组件影响\n\n- 属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性。\n\n  根本的区别：组件在运行时需要去修改维护的就是状态\n\n  ​\n\n# 二、元素和组件\n\n### (一)、什么是元素？ \n\n元素用来描述你在屏幕上看到的内容\n\n与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。\n\nReact 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素:\n\n```js\nconst element = <div className=\"element\">I'm element</div>\n```\n\nReact 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的：\n\n```json\n{\n    _context: Object,\n    _owner: null,\n    key: null,\n    props: {\n    className: 'element'，\n    children: 'I'm element'\n  },\n    ref: null,\n    type: \"div\"\n}\n```\n\n只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口`ref`和`getDOMNode()`。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。\n\n除了使用 JSX 语法，我们还可以使用 `React.createElement()` 和 `React.cloneElement()` 来构建 React 元素。\n\n#### 1、React.createElement() 创建元素\n\nJSX 语法就是用`React.createElement()`来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如`div`、`span`，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。\n\n```js\nReact.createElement(\n    type,\n    [props],\n    [...children]\n)\n```\n\n该方法创建并返回一个`ReactElement`对象，其参数如下：\n\n- `type`，可以是一个`HTML标签`或是一个`React组件`（`ReactClass`）\n- `props`，可选参数，表示对象的属性\n- `children`，第三个参数及其后的参数都会被认为是元素的子元素\n- 返回值：`ReactElement`对象\n\n示例，创建一个如下结构的组件：\n\n```html\n<div className=\"myClass\">\n  <h2>itbilu.com</h2><hr/>\n</div>\n\n```\n\n使用`createElement()`方法操作如下：\n\n```js\nReactDOM.render(\n  React.createElement('div', {className:'myClass'},  \n    React.createElement('h2', null, 'itbilu.com'),\n    React.createElement('hr')\n  ),\n  document.getElementById('example')\n);\n\n// itbilu.com\n```\n\n\n\n#### 2、React.cloneElement() 元素克隆\n\n`React.cloneElement()`与`React.createElement()`相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。\n\n```js\nReact.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n```\n\n该方法会从已有的`ReactElement`中复制，并返回一个新的`ReactElement`对象，其参数如下：\n\n- `element`，一个`React元素`（`ReactElement`）\n- `props`，可选参数，表示对象的属性\n- `children`，第三个参数及其后的参数都会被认为是元素的子元素\n- 返回值：`ReactElement`对象\n\n示例，已有如下元素：\n\n```js\nReact.createElement('div');\n```\n\n使用`cloneElement()`复制这个元素，并最终生前面示例中的HTML。复制方法如下:\n\n```js\nvar div = React.createElement('div');\n\nReactDOM.render(\n  React.cloneElement(div, {className:'myClass'},  \n    React.createElement('h2', null, 'itbilu.com'),\n    React.createElement('hr')\n  ),\n  document.getElementById('example')\n);\n```\n\n### (二)、什么是组件？\n\n组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。\n\n组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。\n\n**特点 **：\n\n1. 组件就是函数\n2. 组件编写时，首字母大写\n3. 组件可以嵌套组合使用 ，遵循是W3C的规范\n\n定义一个组件最简单的方式是使用JavaScript函数：\n\n```js\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\n#### 1、函数定义组件(写法一)\n\n```js\nfunction Welcome(props) {\n        return <h1>Welcome,{props.name}</h1>\n    }\n```\n\n#### 2、类定义组件(写法二)\n\n```js\nclass Member extends React.Component{\n        render(){\n            return <h1>Welcome,{this.props.name}</h1>\n        }\n    };\n```\n\n#### 3、组合组件\n\n```js\nfunction Welcome(props) {\n        return <h1>Hello,{props.name}</h1>\n    }\n    function App() {\n        return(\n            // 组件的返回值只能有一个根元素。\n            // 这也是我们要用一个<div>来包裹所有<Welcome />元素的原因。\n            <div>\n                <Welcome name='Sara' />\n                <Welcome name='Cahal' />\n                <Welcome name='Edite' />\n            </div>\n        )\n    }\n    ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n    );\n```\n\n#### 4、提取组件\n\n**意义** :\n\n1. 可重用性\n2. 可读性\n3. 可维护性\n4. 便于调试与测试\n\n```js\n        function Avatar(props) {\n            return(\n                <img\n                    className='Avatar' \n                    src={props.user.avator} \n                    alt={props.user.name} \n                />\n            );\n        }\n        function UserInfo(props) {\n            return(\n                <div className=\"UserInfo\">\n                    <Avatar user={props.user} />\n                    <div className=\"UserInfoName\">\n                        {props.user.name}\n                    </div>\n                </div>\n            );\n        }\n        function Comment(props) { \n            return(\n                <div className=\"Comment\">\n                    <UserInfo user={props.user} /> \n                    <div className=\"CommentText\">\n                        {props.text}\n                    </div>\n                    <div className=\"CommentDate\">\n                        {props.date}\n                    </div>\n                </div>\n            ) \n        } \n        //提取Avatar组件 \n        ReactDOM.render(\n            <h1>Hello,World</h1>, \n            document.getElementById('root') \n        );\n```\n\n### (三)元素和组件的区别\n\n组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。\n\n打个不恰当的比喻，React 组件是`MyComponent`，React 元素就是`<MyComponent />`。\n\n# 三、组件的类型及其区别\n\nReact推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：\n\n1. 函数式定义的`无状态组件`\n2. es5原生方式`React.createClass`定义的组件\n3. es6形式的`extends React.Component`定义的组件\n\n虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。\n\n### (一)无状态函数式组件\n\n创建[无状态函数式组件形式](https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components)是从`React 0.14`版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的`props`来展示，不涉及到要`state`状态的操作。具体的*无状态函数式组件*，其官方指出：\n\n```\n   在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。\n```\n\n无状态函数式组件形式上表现为一个只带有一个`render`方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无`state`状态的。具体的创建形式如下：\n\n```js\nfunction HelloComponent(props, /* context */) {\n  return <div>Hello {props.name}</div>\n}\nReactDOM.render(<HelloComponent name=\"Sebastian\" />, mountNode) \n```\n\n无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：\n\n1. **组件不会被实例化，整体渲染性能得到提升**\n   因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。\n2. **组件不能访问this对象**\n   无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：`this.ref`、`this.state`等均不能访问。若想访问就不能使用这种形式来创建组件\n3. **组件无法访问生命周期的方法**\n   因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。\n4. **无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用**\n\n无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以**只要有可能，尽量使用无状态组件**。\n\n### (二)React.createClass\n\n```\n`React.createClass`是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：\n```\n\n```js\nvar InputControlES5 = React.createClass({\n    propTypes: {//定义传入props中的属性各种类型\n        initialValue: React.PropTypes.string\n    },\n    defaultProps: { //组件默认的props对象\n        initialValue: ''\n    },\n    // 设置 initial state\n    getInitialState: function() {//组件相关的状态对象\n        return {\n            text: this.props.initialValue || 'placeholder'\n        };\n    },\n    handleChange: function(event) {\n        this.setState({ //this represents react component instance\n            text: event.target.value\n        });\n    },\n    render: function() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange} value={this.state.text} />\n            </div>\n        );\n    }\n});\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n与无状态组件相比，`React.createClass`和后面要描述的`React.Component`都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，`React.createClass`形式自身的问题暴露出来：\n\n- React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。\n- React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components--HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考[无状态组件(Stateless Component) 与高阶组件](http://www.jianshu.com/p/63569386befc)。\n\n### (三)React.Component\n\n`React.Component`是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代`React.createClass`形式；相对于 `React.createClass`可以更好实现代码复用。将上面`React.createClass`的形式改为`React.Component`形式如下：\n\n```js\nclass InputControlES6 extends React.Component {\n    constructor(props) {\n        super(props);\n\n        // 设置 initial state\n        this.state = {\n            text: props.initialValue || 'placeholder'\n        };\n\n        // ES6 类中函数必须手动绑定\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(event) {\n        this.setState({\n            text: event.target.value\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange}\n               value={this.state.text} />\n            </div>\n        );\n    }\n}\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n### (四)React.createClass与React.Component区别\n\n根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。\n\n### 1、函数this自绑定\n\n`React.createClass`创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用`this.method`即可，函数中的`this`会被正确设置。\n\n```js\nconst Contacts = React.createClass({  \n  handleClick() {\n    console.log(this); // React Component instance\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n`React.Component`创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。\n\n```js\nclass Contacts extends React.Component {  \n  constructor(props) {\n    super(props);\n  }\n  handleClick() {\n    console.log(this); // null\n  }\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n```\n\n当然，`React.Component`有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用`method.bind(this)`来完成绑定，还可以使用arrow function来绑定。拿上例的`handleClick`函数来说，其绑定可以有：\n\n```js\n    constructor(props) {\n       super(props);\n       this.handleClick = this.handleClick.bind(this); //构造函数中绑定\n  }\n```\n\n```js\n    <div onClick={this.handleClick.bind(this)}></div> //使用bind来绑定\n```\n\n```js\n    <div onClick={()=>this.handleClick()}></div> //使用arrow function来绑定\n```\n\n### 2、组件属性类型propTypes及其默认props属性defaultProps配置不同\n\n`React.createClass`在创建组件时，有关组件props的属性类型及组件默认的属性会作为**组件实例的属性**来配置，其中defaultProps是使用`getDefaultProps`的方法来获取默认组件属性的\n\n```\nconst TodoItem = React.createClass({\n    propTypes: { // as an object\n        name: React.PropTypes.string\n    },\n    getDefaultProps(){   // return a object\n        return {\n            name: ''    \n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\n```\n\n`React.Component`在创建组件时配置这两个对应信息时，他们是作为**组件类的属性**，不是组件实例的属性，也就是所谓的**类的静态属性**来配置的。对应上面配置如下：\n\n```\nclass TodoItem extends React.Component {\n    static propTypes = {//类的静态属性\n        name: React.PropTypes.string\n    };\n\n    static defaultProps = {//类的静态属性\n        name: ''\n    };\n\n    ...\n}\n```\n\n### 3、组件初始状态state的配置不同\n\n`React.createClass`创建的组件，其状态state是通过`getInitialState`方法来配置组件相关的状态；\n`React.Component`创建的组件，其状态state是在`constructor`中像初始化组件属性一样声明的。\n\n```\nconst TodoItem = React.createClass({\n    // return an object\n    getInitialState(){ \n        return {\n            isEditing: false\n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\n```\n\n```\nclass TodoItem extends React.Component{\n    constructor(props){\n        super(props);\n        this.state = { // define this.state in constructor\n            isEditing: false\n        } \n    }\n    render(){\n        return <div></div>\n    }\n}\n```\n\n### 4、Mixins的支持不同\n\n[`Mixins`](https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins)(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过`Mixins`进该对象来达到代码复用。具体可以参考[React Mixin的前世今生](http://www.w3ctech.com/topic/1599)。\n\n`React.createClass`在创建组件时可以使用`mixins`属性，以数组的形式来混合类的集合。\n\n```\nvar SomeMixin = {  \n  doSomething() {\n\n  }\n};\nconst Contacts = React.createClass({  \n  mixins: [SomeMixin],\n  handleClick() {\n    this.doSomething(); // use mixin\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n但是遗憾的是`React.Component`这种形式并不支持`Mixins`，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代`Mixins`,那就是**Higher-Order Components**，具体细节可以参考[这篇文章](https://leozdgao.me/chushi-hoc/)\n\n### (五)如何选择哪种方式创建组件\n\n由于React团队[已经声明](https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html)React.createClass最终会被React.Component的类形式所取代。但是在找到`Mixins`替代方案之前是不会废弃掉`React.createClass`形式。所以：\n\n```\n能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。\n```\n\n除此之外，创建组件的形式选择还应该根据下面来决定：\n\n```\n1、只要有可能，尽量使用无状态组件创建形式。\n\n2、否则（如需要state、生命周期方法等），使用`React.Component`这种es6形式创建组件\n```\n\n**补充一点**\n\n> 无状态组件内部其实是可以使用`ref`功能的，虽然不能通过`this.refs`访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。\n\n例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：\n\n```js\nfunction TestComp(props){\n    let ref;\n    return (<div>\n        <div ref={(node) => ref = node}>\n            ...\n        </div>\n    </div>)\n}\n```\n\n### 参考文献\n\n- [React 组件构造方法: ES5 (createClass) 还是 ES6 (class)？](http://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html)\n- [React.createClass 对比 extends React.Component](http://www.peachis.me/react-createclass-versus-extends-react-component/)\n- [应该如何选择：React.createClass, ES6 Classes, 无状态函数式组件](https://medium.com/@kingzs70/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-react-createclass-es6-classes-%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-52f07dd70e75#.3m2m0t62r)\n- [React中函数式声明组件](https://segmentfault.com/a/1190000006180667)\n- [React Mixin 的前世今生](http://www.w3ctech.com/topic/1599)","source":"_posts/React元素和组件.md","raw":"---\ntitle: React元素和组件\ndate: 2018-01-31 09:03:54\ntags: React\ncategories: React\n---\n![](http://p2oiag4fy.bkt.clouddn.com/React.jpeg)\n# 一 、属性和状态\n\n### (一)什么是属性？\n\nprops=properties \n\n#### 1、属性的含义和用法\n\n含义 ：一个事物的性质与关系，属性往往是与生俱来的、无法自己改变的。\n\n3种用法 ：\n\n(1)键值对\n\n传入一个字符串：\n\n```js\n'Hello,World!' 或 {'Hello,World!'}\n```\n\n传入一个数组：\n\n```js\n{[Array1,Array2,Array3]}\n```\n\n传入一个变量：\n\n```js\n{variable}\n```\n\n(2)展开对象形式\n\n```js\nvar props = {\n\tone:\"123\",\n\ttwo:321\n\t}\n<HelloWorld {...props}/>\n```\n\nReact提供展开语法…,使用…加对象,react就会把对象中的属性和值，当成是属性的赋值。\n\n(3)setProps形式：\n\n通过组件更新属性，不能在组件内部中修改属性的，因为会违背组件设计原则（尽量避免）\n\n```js\n<script type=\"text/babel\">\n    var HelloWorld = React.createClass({\n        render: function(){\n            return <p>Hello, {this.props.name}</p>\n        }\n    });\n    var instance = ReactDOM.render(<HelloWorld></HelloWorld>, document.querySelector(\"#example\"));\n    instance.setProps({name: \"William\"});\n</script>\n```\n\nsetProps接收的参数是一个对象，但是react不推荐改变组件的属性,可以通过父组件向子组件传入的方式。\n\n### (二)什么是状态？\n\nstate\n\n#### 1、状态的含义和用法\n\n含义 ：事物所处的状况。状态是由事物自行处理、不断变化的，是事物的私有属性。 \n\n用法：\n\ngetInitialState:初始化每个实例特有的状态 \nsetState:更新组件状态 \n使用setState——启用diff算法——有变化，更新DOM\n\n```js\n\t//使用状态 state，实现时钟\n    class Time extends React.Component{\n        //构造器函数（初始化函数）：初始化\n        constructor(props) {\n            super(props);\n            //初始化状态\n            this.state={\n                date:new Date()\n            }\n            //修改状态:每隔一秒，修改状态\n            setInterval(()=>{\n                console.log('定时器执行');\n                this.setState({\n                    date:new Date()\n                })\n            },1000);\n        }\n        render(){\n            console.log('时间',this.state.date);\n            return(\n                //使用\n                <p>当前时间:  {this.state.date.toLocaleTimeString()}</p>\n            );\n        }\n    }\n    ReactDOM.render(\n        <Time />,\n        document.getElementById('root')\n        );\n```\n\n### (三)属性和状态对比 \n\n属性和状态作为组件之间数据流动的途径，非常容易混用，下面对属性和状态进行对比，介绍两者的相同点、不同点以及使用方法。\n\n#### 1、相同点\n\n- 都是纯JS对象\n- 都会触发render更新\n- 都具有确定性\n\n#### 2、对比\n\n| -            | 属性( props) | 状态(state) |\n| ------------ | :--------: | :-------: |\n| 能否从父组件获取初始值  |     √      |     ×     |\n| 能否由父组件修改     |     √      |     ×     |\n| 能否在组件内部设置默认值 |     √      |     √     |\n| 能否在组件内部修改    |     ×      |     √     |\n| 能否设置子组件的初始值  |     √      |     ×     |\n| 能否修改子组件的值    |     √      |     ×     |\n\n状态只和组件本身相关，组件不能修改属性\n\n#### 3、区分\n\n- 状态和属性都会触发render更新，都是纯JS对象\n\n- 状态：是和自己相关的，既不受父组件也不受子组件影响\n\n- 属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性。\n\n  根本的区别：组件在运行时需要去修改维护的就是状态\n\n  ​\n\n# 二、元素和组件\n\n### (一)、什么是元素？ \n\n元素用来描述你在屏幕上看到的内容\n\n与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。\n\nReact 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素:\n\n```js\nconst element = <div className=\"element\">I'm element</div>\n```\n\nReact 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的：\n\n```json\n{\n    _context: Object,\n    _owner: null,\n    key: null,\n    props: {\n    className: 'element'，\n    children: 'I'm element'\n  },\n    ref: null,\n    type: \"div\"\n}\n```\n\n只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口`ref`和`getDOMNode()`。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。\n\n除了使用 JSX 语法，我们还可以使用 `React.createElement()` 和 `React.cloneElement()` 来构建 React 元素。\n\n#### 1、React.createElement() 创建元素\n\nJSX 语法就是用`React.createElement()`来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如`div`、`span`，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。\n\n```js\nReact.createElement(\n    type,\n    [props],\n    [...children]\n)\n```\n\n该方法创建并返回一个`ReactElement`对象，其参数如下：\n\n- `type`，可以是一个`HTML标签`或是一个`React组件`（`ReactClass`）\n- `props`，可选参数，表示对象的属性\n- `children`，第三个参数及其后的参数都会被认为是元素的子元素\n- 返回值：`ReactElement`对象\n\n示例，创建一个如下结构的组件：\n\n```html\n<div className=\"myClass\">\n  <h2>itbilu.com</h2><hr/>\n</div>\n\n```\n\n使用`createElement()`方法操作如下：\n\n```js\nReactDOM.render(\n  React.createElement('div', {className:'myClass'},  \n    React.createElement('h2', null, 'itbilu.com'),\n    React.createElement('hr')\n  ),\n  document.getElementById('example')\n);\n\n// itbilu.com\n```\n\n\n\n#### 2、React.cloneElement() 元素克隆\n\n`React.cloneElement()`与`React.createElement()`相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。\n\n```js\nReact.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n```\n\n该方法会从已有的`ReactElement`中复制，并返回一个新的`ReactElement`对象，其参数如下：\n\n- `element`，一个`React元素`（`ReactElement`）\n- `props`，可选参数，表示对象的属性\n- `children`，第三个参数及其后的参数都会被认为是元素的子元素\n- 返回值：`ReactElement`对象\n\n示例，已有如下元素：\n\n```js\nReact.createElement('div');\n```\n\n使用`cloneElement()`复制这个元素，并最终生前面示例中的HTML。复制方法如下:\n\n```js\nvar div = React.createElement('div');\n\nReactDOM.render(\n  React.cloneElement(div, {className:'myClass'},  \n    React.createElement('h2', null, 'itbilu.com'),\n    React.createElement('hr')\n  ),\n  document.getElementById('example')\n);\n```\n\n### (二)、什么是组件？\n\n组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。\n\n组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。\n\n**特点 **：\n\n1. 组件就是函数\n2. 组件编写时，首字母大写\n3. 组件可以嵌套组合使用 ，遵循是W3C的规范\n\n定义一个组件最简单的方式是使用JavaScript函数：\n\n```js\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\n#### 1、函数定义组件(写法一)\n\n```js\nfunction Welcome(props) {\n        return <h1>Welcome,{props.name}</h1>\n    }\n```\n\n#### 2、类定义组件(写法二)\n\n```js\nclass Member extends React.Component{\n        render(){\n            return <h1>Welcome,{this.props.name}</h1>\n        }\n    };\n```\n\n#### 3、组合组件\n\n```js\nfunction Welcome(props) {\n        return <h1>Hello,{props.name}</h1>\n    }\n    function App() {\n        return(\n            // 组件的返回值只能有一个根元素。\n            // 这也是我们要用一个<div>来包裹所有<Welcome />元素的原因。\n            <div>\n                <Welcome name='Sara' />\n                <Welcome name='Cahal' />\n                <Welcome name='Edite' />\n            </div>\n        )\n    }\n    ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n    );\n```\n\n#### 4、提取组件\n\n**意义** :\n\n1. 可重用性\n2. 可读性\n3. 可维护性\n4. 便于调试与测试\n\n```js\n        function Avatar(props) {\n            return(\n                <img\n                    className='Avatar' \n                    src={props.user.avator} \n                    alt={props.user.name} \n                />\n            );\n        }\n        function UserInfo(props) {\n            return(\n                <div className=\"UserInfo\">\n                    <Avatar user={props.user} />\n                    <div className=\"UserInfoName\">\n                        {props.user.name}\n                    </div>\n                </div>\n            );\n        }\n        function Comment(props) { \n            return(\n                <div className=\"Comment\">\n                    <UserInfo user={props.user} /> \n                    <div className=\"CommentText\">\n                        {props.text}\n                    </div>\n                    <div className=\"CommentDate\">\n                        {props.date}\n                    </div>\n                </div>\n            ) \n        } \n        //提取Avatar组件 \n        ReactDOM.render(\n            <h1>Hello,World</h1>, \n            document.getElementById('root') \n        );\n```\n\n### (三)元素和组件的区别\n\n组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。\n\n打个不恰当的比喻，React 组件是`MyComponent`，React 元素就是`<MyComponent />`。\n\n# 三、组件的类型及其区别\n\nReact推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：\n\n1. 函数式定义的`无状态组件`\n2. es5原生方式`React.createClass`定义的组件\n3. es6形式的`extends React.Component`定义的组件\n\n虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。\n\n### (一)无状态函数式组件\n\n创建[无状态函数式组件形式](https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components)是从`React 0.14`版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的`props`来展示，不涉及到要`state`状态的操作。具体的*无状态函数式组件*，其官方指出：\n\n```\n   在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。\n```\n\n无状态函数式组件形式上表现为一个只带有一个`render`方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无`state`状态的。具体的创建形式如下：\n\n```js\nfunction HelloComponent(props, /* context */) {\n  return <div>Hello {props.name}</div>\n}\nReactDOM.render(<HelloComponent name=\"Sebastian\" />, mountNode) \n```\n\n无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：\n\n1. **组件不会被实例化，整体渲染性能得到提升**\n   因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。\n2. **组件不能访问this对象**\n   无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：`this.ref`、`this.state`等均不能访问。若想访问就不能使用这种形式来创建组件\n3. **组件无法访问生命周期的方法**\n   因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。\n4. **无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用**\n\n无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以**只要有可能，尽量使用无状态组件**。\n\n### (二)React.createClass\n\n```\n`React.createClass`是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：\n```\n\n```js\nvar InputControlES5 = React.createClass({\n    propTypes: {//定义传入props中的属性各种类型\n        initialValue: React.PropTypes.string\n    },\n    defaultProps: { //组件默认的props对象\n        initialValue: ''\n    },\n    // 设置 initial state\n    getInitialState: function() {//组件相关的状态对象\n        return {\n            text: this.props.initialValue || 'placeholder'\n        };\n    },\n    handleChange: function(event) {\n        this.setState({ //this represents react component instance\n            text: event.target.value\n        });\n    },\n    render: function() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange} value={this.state.text} />\n            </div>\n        );\n    }\n});\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n与无状态组件相比，`React.createClass`和后面要描述的`React.Component`都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，`React.createClass`形式自身的问题暴露出来：\n\n- React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。\n- React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components--HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考[无状态组件(Stateless Component) 与高阶组件](http://www.jianshu.com/p/63569386befc)。\n\n### (三)React.Component\n\n`React.Component`是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代`React.createClass`形式；相对于 `React.createClass`可以更好实现代码复用。将上面`React.createClass`的形式改为`React.Component`形式如下：\n\n```js\nclass InputControlES6 extends React.Component {\n    constructor(props) {\n        super(props);\n\n        // 设置 initial state\n        this.state = {\n            text: props.initialValue || 'placeholder'\n        };\n\n        // ES6 类中函数必须手动绑定\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(event) {\n        this.setState({\n            text: event.target.value\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange}\n               value={this.state.text} />\n            </div>\n        );\n    }\n}\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n### (四)React.createClass与React.Component区别\n\n根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。\n\n### 1、函数this自绑定\n\n`React.createClass`创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用`this.method`即可，函数中的`this`会被正确设置。\n\n```js\nconst Contacts = React.createClass({  \n  handleClick() {\n    console.log(this); // React Component instance\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n`React.Component`创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。\n\n```js\nclass Contacts extends React.Component {  \n  constructor(props) {\n    super(props);\n  }\n  handleClick() {\n    console.log(this); // null\n  }\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n```\n\n当然，`React.Component`有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用`method.bind(this)`来完成绑定，还可以使用arrow function来绑定。拿上例的`handleClick`函数来说，其绑定可以有：\n\n```js\n    constructor(props) {\n       super(props);\n       this.handleClick = this.handleClick.bind(this); //构造函数中绑定\n  }\n```\n\n```js\n    <div onClick={this.handleClick.bind(this)}></div> //使用bind来绑定\n```\n\n```js\n    <div onClick={()=>this.handleClick()}></div> //使用arrow function来绑定\n```\n\n### 2、组件属性类型propTypes及其默认props属性defaultProps配置不同\n\n`React.createClass`在创建组件时，有关组件props的属性类型及组件默认的属性会作为**组件实例的属性**来配置，其中defaultProps是使用`getDefaultProps`的方法来获取默认组件属性的\n\n```\nconst TodoItem = React.createClass({\n    propTypes: { // as an object\n        name: React.PropTypes.string\n    },\n    getDefaultProps(){   // return a object\n        return {\n            name: ''    \n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\n```\n\n`React.Component`在创建组件时配置这两个对应信息时，他们是作为**组件类的属性**，不是组件实例的属性，也就是所谓的**类的静态属性**来配置的。对应上面配置如下：\n\n```\nclass TodoItem extends React.Component {\n    static propTypes = {//类的静态属性\n        name: React.PropTypes.string\n    };\n\n    static defaultProps = {//类的静态属性\n        name: ''\n    };\n\n    ...\n}\n```\n\n### 3、组件初始状态state的配置不同\n\n`React.createClass`创建的组件，其状态state是通过`getInitialState`方法来配置组件相关的状态；\n`React.Component`创建的组件，其状态state是在`constructor`中像初始化组件属性一样声明的。\n\n```\nconst TodoItem = React.createClass({\n    // return an object\n    getInitialState(){ \n        return {\n            isEditing: false\n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\n```\n\n```\nclass TodoItem extends React.Component{\n    constructor(props){\n        super(props);\n        this.state = { // define this.state in constructor\n            isEditing: false\n        } \n    }\n    render(){\n        return <div></div>\n    }\n}\n```\n\n### 4、Mixins的支持不同\n\n[`Mixins`](https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins)(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过`Mixins`进该对象来达到代码复用。具体可以参考[React Mixin的前世今生](http://www.w3ctech.com/topic/1599)。\n\n`React.createClass`在创建组件时可以使用`mixins`属性，以数组的形式来混合类的集合。\n\n```\nvar SomeMixin = {  \n  doSomething() {\n\n  }\n};\nconst Contacts = React.createClass({  \n  mixins: [SomeMixin],\n  handleClick() {\n    this.doSomething(); // use mixin\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n但是遗憾的是`React.Component`这种形式并不支持`Mixins`，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代`Mixins`,那就是**Higher-Order Components**，具体细节可以参考[这篇文章](https://leozdgao.me/chushi-hoc/)\n\n### (五)如何选择哪种方式创建组件\n\n由于React团队[已经声明](https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html)React.createClass最终会被React.Component的类形式所取代。但是在找到`Mixins`替代方案之前是不会废弃掉`React.createClass`形式。所以：\n\n```\n能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。\n```\n\n除此之外，创建组件的形式选择还应该根据下面来决定：\n\n```\n1、只要有可能，尽量使用无状态组件创建形式。\n\n2、否则（如需要state、生命周期方法等），使用`React.Component`这种es6形式创建组件\n```\n\n**补充一点**\n\n> 无状态组件内部其实是可以使用`ref`功能的，虽然不能通过`this.refs`访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。\n\n例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：\n\n```js\nfunction TestComp(props){\n    let ref;\n    return (<div>\n        <div ref={(node) => ref = node}>\n            ...\n        </div>\n    </div>)\n}\n```\n\n### 参考文献\n\n- [React 组件构造方法: ES5 (createClass) 还是 ES6 (class)？](http://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html)\n- [React.createClass 对比 extends React.Component](http://www.peachis.me/react-createclass-versus-extends-react-component/)\n- [应该如何选择：React.createClass, ES6 Classes, 无状态函数式组件](https://medium.com/@kingzs70/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-react-createclass-es6-classes-%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-52f07dd70e75#.3m2m0t62r)\n- [React中函数式声明组件](https://segmentfault.com/a/1190000006180667)\n- [React Mixin 的前世今生](http://www.w3ctech.com/topic/1599)","slug":"React元素和组件","published":1,"updated":"2018-01-31T01:19:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzz70003f7kr4zqm9abb","content":"<p><img src=\"http://p2oiag4fy.bkt.clouddn.com/React.jpeg\" alt=\"\"></p>\n<h1 id=\"一-、属性和状态\"><a href=\"#一-、属性和状态\" class=\"headerlink\" title=\"一 、属性和状态\"></a>一 、属性和状态</h1><h3 id=\"一-什么是属性？\"><a href=\"#一-什么是属性？\" class=\"headerlink\" title=\"(一)什么是属性？\"></a>(一)什么是属性？</h3><p>props=properties </p>\n<h4 id=\"1、属性的含义和用法\"><a href=\"#1、属性的含义和用法\" class=\"headerlink\" title=\"1、属性的含义和用法\"></a>1、属性的含义和用法</h4><p>含义 ：一个事物的性质与关系，属性往往是与生俱来的、无法自己改变的。</p>\n<p>3种用法 ：</p>\n<p>(1)键值对</p>\n<p>传入一个字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'Hello,World!'</span> 或 &#123;<span class=\"string\">'Hello,World!'</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>传入一个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;[Array1,Array2,Array3]&#125;</span><br></pre></td></tr></table></figure>\n<p>传入一个变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;variable&#125;</span><br></pre></td></tr></table></figure>\n<p>(2)展开对象形式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> props = &#123;</span><br><span class=\"line\">\tone:<span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">\ttwo:<span class=\"number\">321</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;HelloWorld &#123;...props&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p>React提供展开语法…,使用…加对象,react就会把对象中的属性和值，当成是属性的赋值。</p>\n<p>(3)setProps形式：</p>\n<p>通过组件更新属性，不能在组件内部中修改属性的，因为会违背组件设计原则（尽量避免）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/babel\"</span>&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> HelloWorld = React.createClass(&#123;</span><br><span class=\"line\">        render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &lt;p&gt;Hello, &#123;this.props.name&#125;&lt;/p&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = ReactDOM.render(&lt;HelloWorld&gt;&lt;/HelloWorld&gt;, <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#example\"</span>));</span><br><span class=\"line\">    instance.setProps(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"William\"</span>&#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>setProps接收的参数是一个对象，但是react不推荐改变组件的属性,可以通过父组件向子组件传入的方式。</p>\n<h3 id=\"二-什么是状态？\"><a href=\"#二-什么是状态？\" class=\"headerlink\" title=\"(二)什么是状态？\"></a>(二)什么是状态？</h3><p>state</p>\n<h4 id=\"1、状态的含义和用法\"><a href=\"#1、状态的含义和用法\" class=\"headerlink\" title=\"1、状态的含义和用法\"></a>1、状态的含义和用法</h4><p>含义 ：事物所处的状况。状态是由事物自行处理、不断变化的，是事物的私有属性。 </p>\n<p>用法：</p>\n<p>getInitialState:初始化每个实例特有的状态<br>setState:更新组件状态<br>使用setState——启用diff算法——有变化，更新DOM</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用状态 state，实现时钟</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Time</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//构造器函数（初始化函数）：初始化</span></span><br><span class=\"line\">       <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">           <span class=\"comment\">//初始化状态</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.state=&#123;</span><br><span class=\"line\">               date:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">//修改状态:每隔一秒，修改状态</span></span><br><span class=\"line\">           setInterval(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"string\">'定时器执行'</span>);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                   date:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\">           &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       render()&#123;</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"string\">'时间'</span>,<span class=\"keyword\">this</span>.state.date);</span><br><span class=\"line\">           <span class=\"keyword\">return</span>(</span><br><span class=\"line\">               <span class=\"comment\">//使用</span></span><br><span class=\"line\">               &lt;p&gt;当前时间:  &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">           );</span></span><br><span class=\"line\"><span class=\"regexp\">       &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">   &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">   ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">       &lt;Time /</span>&gt;,</span><br><span class=\"line\">       <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">       );</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-属性和状态对比\"><a href=\"#三-属性和状态对比\" class=\"headerlink\" title=\"(三)属性和状态对比\"></a>(三)属性和状态对比</h3><p>属性和状态作为组件之间数据流动的途径，非常容易混用，下面对属性和状态进行对比，介绍两者的相同点、不同点以及使用方法。</p>\n<h4 id=\"1、相同点\"><a href=\"#1、相同点\" class=\"headerlink\" title=\"1、相同点\"></a>1、相同点</h4><ul>\n<li>都是纯JS对象</li>\n<li>都会触发render更新</li>\n<li>都具有确定性</li>\n</ul>\n<h4 id=\"2、对比\"><a href=\"#2、对比\" class=\"headerlink\" title=\"2、对比\"></a>2、对比</h4><table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">属性( props)</th>\n<th style=\"text-align:center\">状态(state)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>能否从父组件获取初始值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否由父组件修改</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否在组件内部设置默认值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>能否在组件内部修改</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>能否设置子组件的初始值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否修改子组件的值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<p>状态只和组件本身相关，组件不能修改属性</p>\n<h4 id=\"3、区分\"><a href=\"#3、区分\" class=\"headerlink\" title=\"3、区分\"></a>3、区分</h4><ul>\n<li><p>状态和属性都会触发render更新，都是纯JS对象</p>\n</li>\n<li><p>状态：是和自己相关的，既不受父组件也不受子组件影响</p>\n</li>\n<li><p>属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性。</p>\n<p>根本的区别：组件在运行时需要去修改维护的就是状态</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"二、元素和组件\"><a href=\"#二、元素和组件\" class=\"headerlink\" title=\"二、元素和组件\"></a>二、元素和组件</h1><h3 id=\"一-、什么是元素？\"><a href=\"#一-、什么是元素？\" class=\"headerlink\" title=\"(一)、什么是元素？\"></a>(一)、什么是元素？</h3><p>元素用来描述你在屏幕上看到的内容</p>\n<p>与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。</p>\n<p>React 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &lt;div className=\"element\"&gt;I'm element&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    _context: Object,</span><br><span class=\"line\">    _owner: null,</span><br><span class=\"line\">    key: null,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">    className: 'element'，</span><br><span class=\"line\">    children: 'I'm element'</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    ref: null,</span><br><span class=\"line\">    type: \"div\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口<code>ref</code>和<code>getDOMNode()</code>。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。</p>\n<p>除了使用 JSX 语法，我们还可以使用 <code>React.createElement()</code> 和 <code>React.cloneElement()</code> 来构建 React 元素。</p>\n<h4 id=\"1、React-createElement-创建元素\"><a href=\"#1、React-createElement-创建元素\" class=\"headerlink\" title=\"1、React.createElement() 创建元素\"></a>1、React.createElement() 创建元素</h4><p>JSX 语法就是用<code>React.createElement()</code>来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如<code>div</code>、<code>span</code>，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createElement(</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    [props],</span><br><span class=\"line\">    [...children]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该方法创建并返回一个<code>ReactElement</code>对象，其参数如下：</p>\n<ul>\n<li><code>type</code>，可以是一个<code>HTML标签</code>或是一个<code>React组件</code>（<code>ReactClass</code>）</li>\n<li><code>props</code>，可选参数，表示对象的属性</li>\n<li><code>children</code>，第三个参数及其后的参数都会被认为是元素的子元素</li>\n<li>返回值：<code>ReactElement</code>对象</li>\n</ul>\n<p>示例，创建一个如下结构的组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"myClass\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>itbilu.com<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">hr</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>使用<code>createElement()</code>方法操作如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  React.createElement(<span class=\"string\">'div'</span>, &#123;<span class=\"attr\">className</span>:<span class=\"string\">'myClass'</span>&#125;,  </span><br><span class=\"line\">    React.createElement(<span class=\"string\">'h2'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'itbilu.com'</span>),</span><br><span class=\"line\">    React.createElement(<span class=\"string\">'hr'</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// itbilu.com</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2、React-cloneElement-元素克隆\"><a href=\"#2、React-cloneElement-元素克隆\" class=\"headerlink\" title=\"2、React.cloneElement() 元素克隆\"></a>2、React.cloneElement() 元素克隆</h4><p><code>React.cloneElement()</code>与<code>React.createElement()</code>相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.cloneElement(</span><br><span class=\"line\">  element,</span><br><span class=\"line\">  [props],</span><br><span class=\"line\">  [...children]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该方法会从已有的<code>ReactElement</code>中复制，并返回一个新的<code>ReactElement</code>对象，其参数如下：</p>\n<ul>\n<li><code>element</code>，一个<code>React元素</code>（<code>ReactElement</code>）</li>\n<li><code>props</code>，可选参数，表示对象的属性</li>\n<li><code>children</code>，第三个参数及其后的参数都会被认为是元素的子元素</li>\n<li>返回值：<code>ReactElement</code>对象</li>\n</ul>\n<p>示例，已有如下元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createElement(<span class=\"string\">'div'</span>);</span><br></pre></td></tr></table></figure>\n<p>使用<code>cloneElement()</code>复制这个元素，并最终生前面示例中的HTML。复制方法如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div = React.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  React.cloneElement(div, &#123;<span class=\"attr\">className</span>:<span class=\"string\">'myClass'</span>&#125;,  </span><br><span class=\"line\">    React.createElement(<span class=\"string\">'h2'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'itbilu.com'</span>),</span><br><span class=\"line\">    React.createElement(<span class=\"string\">'hr'</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-、什么是组件？\"><a href=\"#二-、什么是组件？\" class=\"headerlink\" title=\"(二)、什么是组件？\"></a>(二)、什么是组件？</h3><p>组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。</p>\n<p>组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。</p>\n<p><strong>特点 </strong>：</p>\n<ol>\n<li>组件就是函数</li>\n<li>组件编写时，首字母大写</li>\n<li>组件可以嵌套组合使用 ，遵循是W3C的规范</li>\n</ol>\n<p>定义一个组件最简单的方式是使用JavaScript函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1、函数定义组件-写法一\"><a href=\"#1、函数定义组件-写法一\" class=\"headerlink\" title=\"1、函数定义组件(写法一)\"></a>1、函数定义组件(写法一)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome,&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、类定义组件-写法二\"><a href=\"#2、类定义组件-写法二\" class=\"headerlink\" title=\"2、类定义组件(写法二)\"></a>2、类定义组件(写法二)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">        render()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome,&#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、组合组件\"><a href=\"#3、组合组件\" class=\"headerlink\" title=\"3、组合组件\"></a>3、组合组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello,&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(</span><br><span class=\"line\">            <span class=\"comment\">// 组件的返回值只能有一个根元素。</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是我们要用一个&lt;div&gt;来包裹所有&lt;Welcome /&gt;元素的原因。</span></span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Sara'</span> /&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Cahal'</span> /&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Edite'</span> /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;App /</span>&gt;,</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、提取组件\"><a href=\"#4、提取组件\" class=\"headerlink\" title=\"4、提取组件\"></a>4、提取组件</h4><p><strong>意义</strong> :</p>\n<ol>\n<li>可重用性</li>\n<li>可读性</li>\n<li>可维护性</li>\n<li>便于调试与测试</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;img</span><br><span class=\"line\">            className=<span class=\"string\">'Avatar'</span> </span><br><span class=\"line\">            src=&#123;props.user.avator&#125; </span><br><span class=\"line\">            alt=&#123;props.user.name&#125; </span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"UserInfo\"</span>&gt;</span><br><span class=\"line\">            &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"UserInfoName\"</span>&gt;</span><br><span class=\"line\">                &#123;props.user.name&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"Comment\"</span>&gt;</span><br><span class=\"line\">            &lt;UserInfo user=&#123;props.user&#125; /&gt; </span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"CommentText\"</span>&gt;</span><br><span class=\"line\">                &#123;props.text&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div className=\"CommentDate\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;props.date&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ) </span></span><br><span class=\"line\"><span class=\"regexp\">&#125; </span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/提取Avatar组件 </span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;h1&gt;Hello,World&lt;/</span>h1&gt;, </span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>) </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-元素和组件的区别\"><a href=\"#三-元素和组件的区别\" class=\"headerlink\" title=\"(三)元素和组件的区别\"></a>(三)元素和组件的区别</h3><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。</p>\n<p>打个不恰当的比喻，React 组件是<code>MyComponent</code>，React 元素就是<code>&lt;MyComponent /&gt;</code>。</p>\n<h1 id=\"三、组件的类型及其区别\"><a href=\"#三、组件的类型及其区别\" class=\"headerlink\" title=\"三、组件的类型及其区别\"></a>三、组件的类型及其区别</h1><p>React推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：</p>\n<ol>\n<li>函数式定义的<code>无状态组件</code></li>\n<li>es5原生方式<code>React.createClass</code>定义的组件</li>\n<li>es6形式的<code>extends React.Component</code>定义的组件</li>\n</ol>\n<p>虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。</p>\n<h3 id=\"一-无状态函数式组件\"><a href=\"#一-无状态函数式组件\" class=\"headerlink\" title=\"(一)无状态函数式组件\"></a>(一)无状态函数式组件</h3><p>创建<a href=\"https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components\" target=\"_blank\" rel=\"noopener\">无状态函数式组件形式</a>是从<code>React 0.14</code>版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的<code>props</code>来展示，不涉及到要<code>state</code>状态的操作。具体的<em>无状态函数式组件</em>，其官方指出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。</span><br></pre></td></tr></table></figure>\n<p>无状态函数式组件形式上表现为一个只带有一个<code>render</code>方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无<code>state</code>状态的。具体的创建形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloComponent</span>(<span class=\"params\">props, <span class=\"regexp\">/* context */</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">HelloComponent</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sebastian\"</span> /&gt;</span>, mountNode)</span></span><br></pre></td></tr></table></figure>\n<p>无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：</p>\n<ol>\n<li><strong>组件不会被实例化，整体渲染性能得到提升</strong><br>因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。</li>\n<li><strong>组件不能访问this对象</strong><br>无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：<code>this.ref</code>、<code>this.state</code>等均不能访问。若想访问就不能使用这种形式来创建组件</li>\n<li><strong>组件无法访问生命周期的方法</strong><br>因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。</li>\n<li><strong>无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用</strong></li>\n</ol>\n<p>无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以<strong>只要有可能，尽量使用无状态组件</strong>。</p>\n<h3 id=\"二-React-createClass\"><a href=\"#二-React-createClass\" class=\"headerlink\" title=\"(二)React.createClass\"></a>(二)React.createClass</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`React.createClass`是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> InputControlES5 = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123;<span class=\"comment\">//定义传入props中的属性各种类型</span></span><br><span class=\"line\">        initialValue: React.PropTypes.string</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    defaultProps: &#123; <span class=\"comment\">//组件默认的props对象</span></span><br><span class=\"line\">        initialValue: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 设置 initial state</span></span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">//组件相关的状态对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            text: <span class=\"keyword\">this</span>.props.initialValue || <span class=\"string\">'placeholder'</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; <span class=\"comment\">//this represents react component instance</span></span><br><span class=\"line\">            text: event.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Type something:</span><br><span class=\"line\">                &lt;input onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; value=&#123;<span class=\"keyword\">this</span>.state.text&#125; /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: React.PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.defaultProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: ''</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<p>与无状态组件相比，<code>React.createClass</code>和后面要描述的<code>React.Component</code>都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，<code>React.createClass</code>形式自身的问题暴露出来：</p>\n<ul>\n<li>React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。</li>\n<li>React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components–HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考<a href=\"http://www.jianshu.com/p/63569386befc\" target=\"_blank\" rel=\"noopener\">无状态组件(Stateless Component) 与高阶组件</a>。</li>\n</ul>\n<h3 id=\"三-React-Component\"><a href=\"#三-React-Component\" class=\"headerlink\" title=\"(三)React.Component\"></a>(三)React.Component</h3><p><code>React.Component</code>是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代<code>React.createClass</code>形式；相对于 <code>React.createClass</code>可以更好实现代码复用。将上面<code>React.createClass</code>的形式改为<code>React.Component</code>形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputControlES6</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置 initial state</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            text: props.initialValue || <span class=\"string\">'placeholder'</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ES6 类中函数必须手动绑定</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange(event) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            text: event.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Type something:</span><br><span class=\"line\">                &lt;input onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;</span><br><span class=\"line\">               value=&#123;<span class=\"keyword\">this</span>.state.text&#125; /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: React.PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.defaultProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: ''</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"四-React-createClass与React-Component区别\"><a href=\"#四-React-createClass与React-Component区别\" class=\"headerlink\" title=\"(四)React.createClass与React.Component区别\"></a>(四)React.createClass与React.Component区别</h3><p>根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。</p>\n<h3 id=\"1、函数this自绑定\"><a href=\"#1、函数this自绑定\" class=\"headerlink\" title=\"1、函数this自绑定\"></a>1、函数this自绑定</h3><p><code>React.createClass</code>创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用<code>this.method</code>即可，函数中的<code>this</code>会被正确设置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Contacts = React.createClass(&#123;  </span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// React Component instance</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>React.Component</code>创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Contacts</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>当然，<code>React.Component</code>有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用<code>method.bind(this)</code>来完成绑定，还可以使用arrow function来绑定。拿上例的<code>handleClick</code>函数来说，其绑定可以有：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>); <span class=\"comment\">//构造函数中绑定</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">//使用bind来绑定</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;()=&gt;<span class=\"keyword\">this</span>.handleClick()&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">//使用arrow function来绑定</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、组件属性类型propTypes及其默认props属性defaultProps配置不同\"><a href=\"#2、组件属性类型propTypes及其默认props属性defaultProps配置不同\" class=\"headerlink\" title=\"2、组件属性类型propTypes及其默认props属性defaultProps配置不同\"></a>2、组件属性类型propTypes及其默认props属性defaultProps配置不同</h3><p><code>React.createClass</code>在创建组件时，有关组件props的属性类型及组件默认的属性会作为<strong>组件实例的属性</strong>来配置，其中defaultProps是使用<code>getDefaultProps</code>的方法来获取默认组件属性的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const TodoItem = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123; // as an object</span><br><span class=\"line\">        name: React.PropTypes.string</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getDefaultProps()&#123;   // return a object</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            name: &apos;&apos;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>React.Component</code>在创建组件时配置这两个对应信息时，他们是作为<strong>组件类的属性</strong>，不是组件实例的属性，也就是所谓的<strong>类的静态属性</strong>来配置的。对应上面配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoItem extends React.Component &#123;</span><br><span class=\"line\">    static propTypes = &#123;//类的静态属性</span><br><span class=\"line\">        name: React.PropTypes.string</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    static defaultProps = &#123;//类的静态属性</span><br><span class=\"line\">        name: &apos;&apos;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、组件初始状态state的配置不同\"><a href=\"#3、组件初始状态state的配置不同\" class=\"headerlink\" title=\"3、组件初始状态state的配置不同\"></a>3、组件初始状态state的配置不同</h3><p><code>React.createClass</code>创建的组件，其状态state是通过<code>getInitialState</code>方法来配置组件相关的状态；<br><code>React.Component</code>创建的组件，其状态state是在<code>constructor</code>中像初始化组件属性一样声明的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const TodoItem = React.createClass(&#123;</span><br><span class=\"line\">    // return an object</span><br><span class=\"line\">    getInitialState()&#123; </span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            isEditing: false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoItem extends React.Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123; // define this.state in constructor</span><br><span class=\"line\">            isEditing: false</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、Mixins的支持不同\"><a href=\"#4、Mixins的支持不同\" class=\"headerlink\" title=\"4、Mixins的支持不同\"></a>4、Mixins的支持不同</h3><p><a href=\"https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins\" target=\"_blank\" rel=\"noopener\"><code>Mixins</code></a>(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过<code>Mixins</code>进该对象来达到代码复用。具体可以参考<a href=\"http://www.w3ctech.com/topic/1599\" target=\"_blank\" rel=\"noopener\">React Mixin的前世今生</a>。</p>\n<p><code>React.createClass</code>在创建组件时可以使用<code>mixins</code>属性，以数组的形式来混合类的集合。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var SomeMixin = &#123;  </span><br><span class=\"line\">  doSomething() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const Contacts = React.createClass(&#123;  </span><br><span class=\"line\">  mixins: [SomeMixin],</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    this.doSomething(); // use mixin</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>但是遗憾的是<code>React.Component</code>这种形式并不支持<code>Mixins</code>，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代<code>Mixins</code>,那就是<strong>Higher-Order Components</strong>，具体细节可以参考<a href=\"https://leozdgao.me/chushi-hoc/\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n<h3 id=\"五-如何选择哪种方式创建组件\"><a href=\"#五-如何选择哪种方式创建组件\" class=\"headerlink\" title=\"(五)如何选择哪种方式创建组件\"></a>(五)如何选择哪种方式创建组件</h3><p>由于React团队<a href=\"https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html\" target=\"_blank\" rel=\"noopener\">已经声明</a>React.createClass最终会被React.Component的类形式所取代。但是在找到<code>Mixins</code>替代方案之前是不会废弃掉<code>React.createClass</code>形式。所以：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。</span><br></pre></td></tr></table></figure>\n<p>除此之外，创建组件的形式选择还应该根据下面来决定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、只要有可能，尽量使用无状态组件创建形式。</span><br><span class=\"line\"></span><br><span class=\"line\">2、否则（如需要state、生命周期方法等），使用`React.Component`这种es6形式创建组件</span><br></pre></td></tr></table></figure>\n<p><strong>补充一点</strong></p>\n<blockquote>\n<p>无状态组件内部其实是可以使用<code>ref</code>功能的，虽然不能通过<code>this.refs</code>访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。</p>\n</blockquote>\n<p>例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">TestComp</span>(<span class=\"params\">props</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ref;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">        &lt;div ref=&#123;(node) =&gt; ref = node&#125;&gt;</span><br><span class=\"line\">            ...</span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"http://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html\" target=\"_blank\" rel=\"noopener\">React 组件构造方法: ES5 (createClass) 还是 ES6 (class)？</a></li>\n<li><a href=\"http://www.peachis.me/react-createclass-versus-extends-react-component/\" target=\"_blank\" rel=\"noopener\">React.createClass 对比 extends React.Component</a></li>\n<li><a href=\"https://medium.com/@kingzs70/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-react-createclass-es6-classes-%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-52f07dd70e75#.3m2m0t62r\" target=\"_blank\" rel=\"noopener\">应该如何选择：React.createClass, ES6 Classes, 无状态函数式组件</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006180667\" target=\"_blank\" rel=\"noopener\">React中函数式声明组件</a></li>\n<li><a href=\"http://www.w3ctech.com/topic/1599\" target=\"_blank\" rel=\"noopener\">React Mixin 的前世今生</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://p2oiag4fy.bkt.clouddn.com/React.jpeg\" alt=\"\"></p>\n<h1 id=\"一-、属性和状态\"><a href=\"#一-、属性和状态\" class=\"headerlink\" title=\"一 、属性和状态\"></a>一 、属性和状态</h1><h3 id=\"一-什么是属性？\"><a href=\"#一-什么是属性？\" class=\"headerlink\" title=\"(一)什么是属性？\"></a>(一)什么是属性？</h3><p>props=properties </p>\n<h4 id=\"1、属性的含义和用法\"><a href=\"#1、属性的含义和用法\" class=\"headerlink\" title=\"1、属性的含义和用法\"></a>1、属性的含义和用法</h4><p>含义 ：一个事物的性质与关系，属性往往是与生俱来的、无法自己改变的。</p>\n<p>3种用法 ：</p>\n<p>(1)键值对</p>\n<p>传入一个字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'Hello,World!'</span> 或 &#123;<span class=\"string\">'Hello,World!'</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>传入一个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;[Array1,Array2,Array3]&#125;</span><br></pre></td></tr></table></figure>\n<p>传入一个变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;variable&#125;</span><br></pre></td></tr></table></figure>\n<p>(2)展开对象形式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> props = &#123;</span><br><span class=\"line\">\tone:<span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">\ttwo:<span class=\"number\">321</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;HelloWorld &#123;...props&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p>React提供展开语法…,使用…加对象,react就会把对象中的属性和值，当成是属性的赋值。</p>\n<p>(3)setProps形式：</p>\n<p>通过组件更新属性，不能在组件内部中修改属性的，因为会违背组件设计原则（尽量避免）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/babel\"</span>&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> HelloWorld = React.createClass(&#123;</span><br><span class=\"line\">        render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &lt;p&gt;Hello, &#123;this.props.name&#125;&lt;/p&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = ReactDOM.render(&lt;HelloWorld&gt;&lt;/HelloWorld&gt;, <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#example\"</span>));</span><br><span class=\"line\">    instance.setProps(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"William\"</span>&#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>setProps接收的参数是一个对象，但是react不推荐改变组件的属性,可以通过父组件向子组件传入的方式。</p>\n<h3 id=\"二-什么是状态？\"><a href=\"#二-什么是状态？\" class=\"headerlink\" title=\"(二)什么是状态？\"></a>(二)什么是状态？</h3><p>state</p>\n<h4 id=\"1、状态的含义和用法\"><a href=\"#1、状态的含义和用法\" class=\"headerlink\" title=\"1、状态的含义和用法\"></a>1、状态的含义和用法</h4><p>含义 ：事物所处的状况。状态是由事物自行处理、不断变化的，是事物的私有属性。 </p>\n<p>用法：</p>\n<p>getInitialState:初始化每个实例特有的状态<br>setState:更新组件状态<br>使用setState——启用diff算法——有变化，更新DOM</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用状态 state，实现时钟</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Time</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//构造器函数（初始化函数）：初始化</span></span><br><span class=\"line\">       <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">           <span class=\"comment\">//初始化状态</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.state=&#123;</span><br><span class=\"line\">               date:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">//修改状态:每隔一秒，修改状态</span></span><br><span class=\"line\">           setInterval(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"string\">'定时器执行'</span>);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                   date:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\">           &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       render()&#123;</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"string\">'时间'</span>,<span class=\"keyword\">this</span>.state.date);</span><br><span class=\"line\">           <span class=\"keyword\">return</span>(</span><br><span class=\"line\">               <span class=\"comment\">//使用</span></span><br><span class=\"line\">               &lt;p&gt;当前时间:  &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">           );</span></span><br><span class=\"line\"><span class=\"regexp\">       &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">   &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">   ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">       &lt;Time /</span>&gt;,</span><br><span class=\"line\">       <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">       );</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-属性和状态对比\"><a href=\"#三-属性和状态对比\" class=\"headerlink\" title=\"(三)属性和状态对比\"></a>(三)属性和状态对比</h3><p>属性和状态作为组件之间数据流动的途径，非常容易混用，下面对属性和状态进行对比，介绍两者的相同点、不同点以及使用方法。</p>\n<h4 id=\"1、相同点\"><a href=\"#1、相同点\" class=\"headerlink\" title=\"1、相同点\"></a>1、相同点</h4><ul>\n<li>都是纯JS对象</li>\n<li>都会触发render更新</li>\n<li>都具有确定性</li>\n</ul>\n<h4 id=\"2、对比\"><a href=\"#2、对比\" class=\"headerlink\" title=\"2、对比\"></a>2、对比</h4><table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">属性( props)</th>\n<th style=\"text-align:center\">状态(state)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>能否从父组件获取初始值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否由父组件修改</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否在组件内部设置默认值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>能否在组件内部修改</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>能否设置子组件的初始值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td>能否修改子组件的值</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<p>状态只和组件本身相关，组件不能修改属性</p>\n<h4 id=\"3、区分\"><a href=\"#3、区分\" class=\"headerlink\" title=\"3、区分\"></a>3、区分</h4><ul>\n<li><p>状态和属性都会触发render更新，都是纯JS对象</p>\n</li>\n<li><p>状态：是和自己相关的，既不受父组件也不受子组件影响</p>\n</li>\n<li><p>属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性。</p>\n<p>根本的区别：组件在运行时需要去修改维护的就是状态</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"二、元素和组件\"><a href=\"#二、元素和组件\" class=\"headerlink\" title=\"二、元素和组件\"></a>二、元素和组件</h1><h3 id=\"一-、什么是元素？\"><a href=\"#一-、什么是元素？\" class=\"headerlink\" title=\"(一)、什么是元素？\"></a>(一)、什么是元素？</h3><p>元素用来描述你在屏幕上看到的内容</p>\n<p>与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。</p>\n<p>React 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &lt;div className=\"element\"&gt;I'm element&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    _context: Object,</span><br><span class=\"line\">    _owner: null,</span><br><span class=\"line\">    key: null,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">    className: 'element'，</span><br><span class=\"line\">    children: 'I'm element'</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    ref: null,</span><br><span class=\"line\">    type: \"div\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口<code>ref</code>和<code>getDOMNode()</code>。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。</p>\n<p>除了使用 JSX 语法，我们还可以使用 <code>React.createElement()</code> 和 <code>React.cloneElement()</code> 来构建 React 元素。</p>\n<h4 id=\"1、React-createElement-创建元素\"><a href=\"#1、React-createElement-创建元素\" class=\"headerlink\" title=\"1、React.createElement() 创建元素\"></a>1、React.createElement() 创建元素</h4><p>JSX 语法就是用<code>React.createElement()</code>来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如<code>div</code>、<code>span</code>，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createElement(</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    [props],</span><br><span class=\"line\">    [...children]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该方法创建并返回一个<code>ReactElement</code>对象，其参数如下：</p>\n<ul>\n<li><code>type</code>，可以是一个<code>HTML标签</code>或是一个<code>React组件</code>（<code>ReactClass</code>）</li>\n<li><code>props</code>，可选参数，表示对象的属性</li>\n<li><code>children</code>，第三个参数及其后的参数都会被认为是元素的子元素</li>\n<li>返回值：<code>ReactElement</code>对象</li>\n</ul>\n<p>示例，创建一个如下结构的组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"myClass\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>itbilu.com<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">hr</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>使用<code>createElement()</code>方法操作如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  React.createElement(<span class=\"string\">'div'</span>, &#123;<span class=\"attr\">className</span>:<span class=\"string\">'myClass'</span>&#125;,  </span><br><span class=\"line\">    React.createElement(<span class=\"string\">'h2'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'itbilu.com'</span>),</span><br><span class=\"line\">    React.createElement(<span class=\"string\">'hr'</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// itbilu.com</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2、React-cloneElement-元素克隆\"><a href=\"#2、React-cloneElement-元素克隆\" class=\"headerlink\" title=\"2、React.cloneElement() 元素克隆\"></a>2、React.cloneElement() 元素克隆</h4><p><code>React.cloneElement()</code>与<code>React.createElement()</code>相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.cloneElement(</span><br><span class=\"line\">  element,</span><br><span class=\"line\">  [props],</span><br><span class=\"line\">  [...children]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该方法会从已有的<code>ReactElement</code>中复制，并返回一个新的<code>ReactElement</code>对象，其参数如下：</p>\n<ul>\n<li><code>element</code>，一个<code>React元素</code>（<code>ReactElement</code>）</li>\n<li><code>props</code>，可选参数，表示对象的属性</li>\n<li><code>children</code>，第三个参数及其后的参数都会被认为是元素的子元素</li>\n<li>返回值：<code>ReactElement</code>对象</li>\n</ul>\n<p>示例，已有如下元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createElement(<span class=\"string\">'div'</span>);</span><br></pre></td></tr></table></figure>\n<p>使用<code>cloneElement()</code>复制这个元素，并最终生前面示例中的HTML。复制方法如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div = React.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  React.cloneElement(div, &#123;<span class=\"attr\">className</span>:<span class=\"string\">'myClass'</span>&#125;,  </span><br><span class=\"line\">    React.createElement(<span class=\"string\">'h2'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'itbilu.com'</span>),</span><br><span class=\"line\">    React.createElement(<span class=\"string\">'hr'</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-、什么是组件？\"><a href=\"#二-、什么是组件？\" class=\"headerlink\" title=\"(二)、什么是组件？\"></a>(二)、什么是组件？</h3><p>组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。</p>\n<p>组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。</p>\n<p><strong>特点 </strong>：</p>\n<ol>\n<li>组件就是函数</li>\n<li>组件编写时，首字母大写</li>\n<li>组件可以嵌套组合使用 ，遵循是W3C的规范</li>\n</ol>\n<p>定义一个组件最简单的方式是使用JavaScript函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1、函数定义组件-写法一\"><a href=\"#1、函数定义组件-写法一\" class=\"headerlink\" title=\"1、函数定义组件(写法一)\"></a>1、函数定义组件(写法一)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome,&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、类定义组件-写法二\"><a href=\"#2、类定义组件-写法二\" class=\"headerlink\" title=\"2、类定义组件(写法二)\"></a>2、类定义组件(写法二)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">        render()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome,&#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、组合组件\"><a href=\"#3、组合组件\" class=\"headerlink\" title=\"3、组合组件\"></a>3、组合组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello,&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(</span><br><span class=\"line\">            <span class=\"comment\">// 组件的返回值只能有一个根元素。</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是我们要用一个&lt;div&gt;来包裹所有&lt;Welcome /&gt;元素的原因。</span></span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Sara'</span> /&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Cahal'</span> /&gt;</span><br><span class=\"line\">                &lt;Welcome name=<span class=\"string\">'Edite'</span> /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;App /</span>&gt;,</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、提取组件\"><a href=\"#4、提取组件\" class=\"headerlink\" title=\"4、提取组件\"></a>4、提取组件</h4><p><strong>意义</strong> :</p>\n<ol>\n<li>可重用性</li>\n<li>可读性</li>\n<li>可维护性</li>\n<li>便于调试与测试</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;img</span><br><span class=\"line\">            className=<span class=\"string\">'Avatar'</span> </span><br><span class=\"line\">            src=&#123;props.user.avator&#125; </span><br><span class=\"line\">            alt=&#123;props.user.name&#125; </span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"UserInfo\"</span>&gt;</span><br><span class=\"line\">            &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"UserInfoName\"</span>&gt;</span><br><span class=\"line\">                &#123;props.user.name&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"Comment\"</span>&gt;</span><br><span class=\"line\">            &lt;UserInfo user=&#123;props.user&#125; /&gt; </span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"CommentText\"</span>&gt;</span><br><span class=\"line\">                &#123;props.text&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div className=\"CommentDate\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;props.date&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ) </span></span><br><span class=\"line\"><span class=\"regexp\">&#125; </span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/提取Avatar组件 </span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;h1&gt;Hello,World&lt;/</span>h1&gt;, </span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>) </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-元素和组件的区别\"><a href=\"#三-元素和组件的区别\" class=\"headerlink\" title=\"(三)元素和组件的区别\"></a>(三)元素和组件的区别</h3><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。</p>\n<p>打个不恰当的比喻，React 组件是<code>MyComponent</code>，React 元素就是<code>&lt;MyComponent /&gt;</code>。</p>\n<h1 id=\"三、组件的类型及其区别\"><a href=\"#三、组件的类型及其区别\" class=\"headerlink\" title=\"三、组件的类型及其区别\"></a>三、组件的类型及其区别</h1><p>React推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：</p>\n<ol>\n<li>函数式定义的<code>无状态组件</code></li>\n<li>es5原生方式<code>React.createClass</code>定义的组件</li>\n<li>es6形式的<code>extends React.Component</code>定义的组件</li>\n</ol>\n<p>虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。</p>\n<h3 id=\"一-无状态函数式组件\"><a href=\"#一-无状态函数式组件\" class=\"headerlink\" title=\"(一)无状态函数式组件\"></a>(一)无状态函数式组件</h3><p>创建<a href=\"https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components\" target=\"_blank\" rel=\"noopener\">无状态函数式组件形式</a>是从<code>React 0.14</code>版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的<code>props</code>来展示，不涉及到要<code>state</code>状态的操作。具体的<em>无状态函数式组件</em>，其官方指出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。</span><br></pre></td></tr></table></figure>\n<p>无状态函数式组件形式上表现为一个只带有一个<code>render</code>方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无<code>state</code>状态的。具体的创建形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloComponent</span>(<span class=\"params\">props, <span class=\"regexp\">/* context */</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">HelloComponent</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sebastian\"</span> /&gt;</span>, mountNode)</span></span><br></pre></td></tr></table></figure>\n<p>无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：</p>\n<ol>\n<li><strong>组件不会被实例化，整体渲染性能得到提升</strong><br>因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。</li>\n<li><strong>组件不能访问this对象</strong><br>无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：<code>this.ref</code>、<code>this.state</code>等均不能访问。若想访问就不能使用这种形式来创建组件</li>\n<li><strong>组件无法访问生命周期的方法</strong><br>因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。</li>\n<li><strong>无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用</strong></li>\n</ol>\n<p>无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以<strong>只要有可能，尽量使用无状态组件</strong>。</p>\n<h3 id=\"二-React-createClass\"><a href=\"#二-React-createClass\" class=\"headerlink\" title=\"(二)React.createClass\"></a>(二)React.createClass</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`React.createClass`是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> InputControlES5 = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123;<span class=\"comment\">//定义传入props中的属性各种类型</span></span><br><span class=\"line\">        initialValue: React.PropTypes.string</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    defaultProps: &#123; <span class=\"comment\">//组件默认的props对象</span></span><br><span class=\"line\">        initialValue: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 设置 initial state</span></span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">//组件相关的状态对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            text: <span class=\"keyword\">this</span>.props.initialValue || <span class=\"string\">'placeholder'</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; <span class=\"comment\">//this represents react component instance</span></span><br><span class=\"line\">            text: event.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Type something:</span><br><span class=\"line\">                &lt;input onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; value=&#123;<span class=\"keyword\">this</span>.state.text&#125; /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: React.PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.defaultProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: ''</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<p>与无状态组件相比，<code>React.createClass</code>和后面要描述的<code>React.Component</code>都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，<code>React.createClass</code>形式自身的问题暴露出来：</p>\n<ul>\n<li>React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。</li>\n<li>React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components–HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考<a href=\"http://www.jianshu.com/p/63569386befc\" target=\"_blank\" rel=\"noopener\">无状态组件(Stateless Component) 与高阶组件</a>。</li>\n</ul>\n<h3 id=\"三-React-Component\"><a href=\"#三-React-Component\" class=\"headerlink\" title=\"(三)React.Component\"></a>(三)React.Component</h3><p><code>React.Component</code>是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代<code>React.createClass</code>形式；相对于 <code>React.createClass</code>可以更好实现代码复用。将上面<code>React.createClass</code>的形式改为<code>React.Component</code>形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputControlES6</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置 initial state</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            text: props.initialValue || <span class=\"string\">'placeholder'</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ES6 类中函数必须手动绑定</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange(event) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            text: event.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Type something:</span><br><span class=\"line\">                &lt;input onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;</span><br><span class=\"line\">               value=&#123;<span class=\"keyword\">this</span>.state.text&#125; /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: React.PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">InputControlES6.defaultProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    initialValue: ''</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"四-React-createClass与React-Component区别\"><a href=\"#四-React-createClass与React-Component区别\" class=\"headerlink\" title=\"(四)React.createClass与React.Component区别\"></a>(四)React.createClass与React.Component区别</h3><p>根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。</p>\n<h3 id=\"1、函数this自绑定\"><a href=\"#1、函数this自绑定\" class=\"headerlink\" title=\"1、函数this自绑定\"></a>1、函数this自绑定</h3><p><code>React.createClass</code>创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用<code>this.method</code>即可，函数中的<code>this</code>会被正确设置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Contacts = React.createClass(&#123;  </span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// React Component instance</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>React.Component</code>创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Contacts</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>当然，<code>React.Component</code>有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用<code>method.bind(this)</code>来完成绑定，还可以使用arrow function来绑定。拿上例的<code>handleClick</code>函数来说，其绑定可以有：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>); <span class=\"comment\">//构造函数中绑定</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">//使用bind来绑定</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;()=&gt;<span class=\"keyword\">this</span>.handleClick()&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">//使用arrow function来绑定</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、组件属性类型propTypes及其默认props属性defaultProps配置不同\"><a href=\"#2、组件属性类型propTypes及其默认props属性defaultProps配置不同\" class=\"headerlink\" title=\"2、组件属性类型propTypes及其默认props属性defaultProps配置不同\"></a>2、组件属性类型propTypes及其默认props属性defaultProps配置不同</h3><p><code>React.createClass</code>在创建组件时，有关组件props的属性类型及组件默认的属性会作为<strong>组件实例的属性</strong>来配置，其中defaultProps是使用<code>getDefaultProps</code>的方法来获取默认组件属性的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const TodoItem = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123; // as an object</span><br><span class=\"line\">        name: React.PropTypes.string</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getDefaultProps()&#123;   // return a object</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            name: &apos;&apos;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>React.Component</code>在创建组件时配置这两个对应信息时，他们是作为<strong>组件类的属性</strong>，不是组件实例的属性，也就是所谓的<strong>类的静态属性</strong>来配置的。对应上面配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoItem extends React.Component &#123;</span><br><span class=\"line\">    static propTypes = &#123;//类的静态属性</span><br><span class=\"line\">        name: React.PropTypes.string</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    static defaultProps = &#123;//类的静态属性</span><br><span class=\"line\">        name: &apos;&apos;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、组件初始状态state的配置不同\"><a href=\"#3、组件初始状态state的配置不同\" class=\"headerlink\" title=\"3、组件初始状态state的配置不同\"></a>3、组件初始状态state的配置不同</h3><p><code>React.createClass</code>创建的组件，其状态state是通过<code>getInitialState</code>方法来配置组件相关的状态；<br><code>React.Component</code>创建的组件，其状态state是在<code>constructor</code>中像初始化组件属性一样声明的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const TodoItem = React.createClass(&#123;</span><br><span class=\"line\">    // return an object</span><br><span class=\"line\">    getInitialState()&#123; </span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            isEditing: false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoItem extends React.Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123; // define this.state in constructor</span><br><span class=\"line\">            isEditing: false</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、Mixins的支持不同\"><a href=\"#4、Mixins的支持不同\" class=\"headerlink\" title=\"4、Mixins的支持不同\"></a>4、Mixins的支持不同</h3><p><a href=\"https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins\" target=\"_blank\" rel=\"noopener\"><code>Mixins</code></a>(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过<code>Mixins</code>进该对象来达到代码复用。具体可以参考<a href=\"http://www.w3ctech.com/topic/1599\" target=\"_blank\" rel=\"noopener\">React Mixin的前世今生</a>。</p>\n<p><code>React.createClass</code>在创建组件时可以使用<code>mixins</code>属性，以数组的形式来混合类的集合。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var SomeMixin = &#123;  </span><br><span class=\"line\">  doSomething() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const Contacts = React.createClass(&#123;  </span><br><span class=\"line\">  mixins: [SomeMixin],</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    this.doSomething(); // use mixin</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>但是遗憾的是<code>React.Component</code>这种形式并不支持<code>Mixins</code>，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代<code>Mixins</code>,那就是<strong>Higher-Order Components</strong>，具体细节可以参考<a href=\"https://leozdgao.me/chushi-hoc/\" target=\"_blank\" rel=\"noopener\">这篇文章</a></p>\n<h3 id=\"五-如何选择哪种方式创建组件\"><a href=\"#五-如何选择哪种方式创建组件\" class=\"headerlink\" title=\"(五)如何选择哪种方式创建组件\"></a>(五)如何选择哪种方式创建组件</h3><p>由于React团队<a href=\"https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html\" target=\"_blank\" rel=\"noopener\">已经声明</a>React.createClass最终会被React.Component的类形式所取代。但是在找到<code>Mixins</code>替代方案之前是不会废弃掉<code>React.createClass</code>形式。所以：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。</span><br></pre></td></tr></table></figure>\n<p>除此之外，创建组件的形式选择还应该根据下面来决定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、只要有可能，尽量使用无状态组件创建形式。</span><br><span class=\"line\"></span><br><span class=\"line\">2、否则（如需要state、生命周期方法等），使用`React.Component`这种es6形式创建组件</span><br></pre></td></tr></table></figure>\n<p><strong>补充一点</strong></p>\n<blockquote>\n<p>无状态组件内部其实是可以使用<code>ref</code>功能的，虽然不能通过<code>this.refs</code>访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。</p>\n</blockquote>\n<p>例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">TestComp</span>(<span class=\"params\">props</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ref;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">        &lt;div ref=&#123;(node) =&gt; ref = node&#125;&gt;</span><br><span class=\"line\">            ...</span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"http://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html\" target=\"_blank\" rel=\"noopener\">React 组件构造方法: ES5 (createClass) 还是 ES6 (class)？</a></li>\n<li><a href=\"http://www.peachis.me/react-createclass-versus-extends-react-component/\" target=\"_blank\" rel=\"noopener\">React.createClass 对比 extends React.Component</a></li>\n<li><a href=\"https://medium.com/@kingzs70/%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-react-createclass-es6-classes-%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-52f07dd70e75#.3m2m0t62r\" target=\"_blank\" rel=\"noopener\">应该如何选择：React.createClass, ES6 Classes, 无状态函数式组件</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006180667\" target=\"_blank\" rel=\"noopener\">React中函数式声明组件</a></li>\n<li><a href=\"http://www.w3ctech.com/topic/1599\" target=\"_blank\" rel=\"noopener\">React Mixin 的前世今生</a></li>\n</ul>\n"},{"title":"WebSocket：5分钟从入门到精通","date":"2018-01-12T00:47:35.000Z","_content":"一、内容概览\nWebSocket的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了WebSocket如何建立连接、交换数据的细节，以及数据帧的格式。此外，还简要介绍了针对WebSocket的安全攻击，以及协议是如何抵御类似攻击的。\n\n二、什么是WebSocket\nHTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。\n\n对大部分web开发者来说，上面这段描述有点枯燥，其实只要记住几点：\n\nWebSocket可以在浏览器里使用\n支持双向通信\n使用很简单\n1、有哪些优点\n说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。\n\n支持双向通信，实时性更强。\n更好的二进制支持。\n较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。\n支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）\n对于后面两点，没有研究过WebSocket协议规范的同学可能理解起来不够直观，但不影响对WebSocket的学习和使用。\n\n2、需要学习哪些东西\n对网络应用层协议的学习来说，最重要的往往就是连接建立过程、数据交换教程。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。\n\n下文主要围绕下面几点展开：\n\n如何建立连接\n如何交换数据\n数据帧格式\n如何维持连接\n三、入门例子\n在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了WebSocket服务端、WebSocket客户端（网页端）。完整代码可以在 这里 找到。\n\n这里服务端用了ws这个库。相比大家熟悉的socket.io，ws实现更轻量，更适合学习的目的。\n\n1、服务端\n代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。\n\nvar app = require('express')();\nvar server = require('http').Server(app);\nvar WebSocket = require('ws');\n\nvar wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n    console.log('server: receive connection.');\n    \n    ws.on('message', function incoming(message) {\n        console.log('server: received: %s', message);\n    });\n\n    ws.send('world');\n});\n\napp.get('/', function (req, res) {\n  res.sendfile(__dirname + '/index.html');\n});\n\napp.listen(3000);\n2、客户端\n代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。\n\n<script>\n  var ws = new WebSocket('ws://localhost:8080');\n  ws.onopen = function () {\n    console.log('ws onopen');\n    ws.send('from client: hello');\n  };\n  ws.onmessage = function (e) {\n    console.log('ws onmessage');\n    console.log('from server: ' + e.data);\n  };\n</script>\n3、运行结果\n可分别查看服务端、客户端的日志，这里不展开。\n\n服务端输出：\n\nserver: receive connection.\nserver: received hello\n客户端输出：\n\nclient: ws connection is open\nclient: received world\n四、如何建立连接\n前面提到，WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。\n\n1、客户端：申请协议升级\n首先，客户端发起协议升级请求。可以看到，采用的是标准的HTTP报文格式，且只支持GET方法。\n\nGET / HTTP/1.1\nHost: localhost:8080\nOrigin: http://127.0.0.1:3000\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Version: 13\nSec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==\n重点请求首部意义如下：\n\nConnection: Upgrade：表示要升级协议\nUpgrade: websocket：表示要升级到websocket协议。\nSec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。\nSec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。\n注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。\n\n2、服务端：响应协议升级\n服务端返回内容如下，状态代码101表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。\n\nHTTP/1.1 101 Switching Protocols\nConnection:Upgrade\nUpgrade: websocket\nSec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=\n\n备注：每个header都以\\r\\n结尾，并且最后一行加上一个额外的空行\\r\\n。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。\n\n3、Sec-WebSocket-Accept的计算\nSec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。\n\n计算公式为：\n\n将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。\n通过SHA1计算出摘要，并转成base64字符串。\n伪代码如下：\n\n>toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )\n验证下前面的返回结果：\n\nconst crypto = require('crypto');\nconst magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\nconst secWebSocketKey = 'w4v7O6xFTi36lq3RNcgctw==';\n\nlet secWebSocketAccept = crypto.createHash('sha1')\n\t.update(secWebSocketKey + magic)\n\t.digest('base64');\n\nconsole.log(secWebSocketAccept);\n// Oy4NRAQ13jhfONC7bP8dTKb4PTU=\n五、数据帧格式\n客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。\n\nWebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。\n\n发送端：将消息切割成多个帧，并发送给服务端；\n接收端：接收消息帧，并将关联的帧重新组装成完整的消息；\n本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455 5.2节 。\n\n1、数据帧格式概览\n下面给出了WebSocket数据帧的统一格式。熟悉TCP/IP协议的同学对这样的图应该不陌生。\n\n从左到右，单位是比特。比如FIN、RSV1各占据1比特，opcode占据4比特。\n内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）\n 2、数据帧格式详解\n针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。\n\nFIN：1个比特。\n\n如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。\n\nRSV1, RSV2, RSV3：各占1个比特。\n\n一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。\n\nOpcode: 4个比特。\n\n操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：\n\n%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。\n%x1：表示这是一个文本帧（frame）\n%x2：表示这是一个二进制帧（frame）\n%x3-7：保留的操作代码，用于后续定义的非控制帧。\n%x8：表示连接断开。\n%x9：表示这是一个ping操作。\n%xA：表示这是一个pong操作。\n%xB-F：保留的操作代码，用于后续定义的控制帧。\nMask: 1个比特。\n\n表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。\n\n如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。\n\n如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。\n\n掩码的算法、用途在下一小节讲解。\n\nPayload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。\n\n假设数Payload length === x，如果\n\nx为0~126：数据的长度为x字节。\nx为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。\nx为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。\n此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。\n\nMasking-key：0或4字节（32位）\n\n所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。\n\n备注：载荷数据的长度，不包括mask key的长度。\n\nPayload data：(x+y) 字节\n\n载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。\n\n扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。\n\n应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。\n\n3、掩码算法\n掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：\n\n首先，假设：\n\noriginal-octet-i：为原始数据的第i字节。\ntransformed-octet-i：为转换后的数据的第i字节。\nj：为i mod 4的结果。\nmasking-key-octet-j：为mask key第j字节。\n算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。\n\nj = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j\n\n六、数据传递\n一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。\n\nWebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。\n\n1、数据分片\nWebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。\n\nFIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。\n\n此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。\n\n2、数据分片例子\n直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。\n\n第一条消息\n\nFIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。\n\n第二条消息\n\nFIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。\nFIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。\nFIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。\nClient: FIN=1, opcode=0x1, msg=\"hello\"\nServer: (process complete message immediately) Hi.\nClient: FIN=0, opcode=0x1, msg=\"and a\"\nServer: (listening, new message containing text started)\nClient: FIN=0, opcode=0x0, msg=\"happy new\"\nServer: (listening, payload concatenated to previous message)\nClient: FIN=1, opcode=0x0, msg=\"year!\"\nServer: (process complete message) Happy new year to you too!\n七、连接保持+心跳\nWebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。\n\n但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。\n\n发送方->接收方：ping\n接收方->发送方：pong\nping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。\n\n举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）\n\nws.ping('', false, true);\n八、Sec-WebSocket-Key/Accept的作用\n前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。\n\n作用大致归纳如下：\n\n避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）\n确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）\n用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）\n可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。\nSec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。\n强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。\n\n九、数据掩码的作用\nWebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。\n\n那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。\n\n答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。\n\n1、代理缓存污染攻击\n下面摘自2010年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。\n\n“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”\n\n[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, \"Talking to Yourself for Fun and Profit\", 2010,\n\n在正式描述攻击步骤之前，我们假设有如下参与者：\n\n攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）\n受害者、受害者想要访问的资源（简称“正义资源”）\n受害者实际想要访问的服务器（简称“正义服务器”）\n中间代理服务器\n攻击步骤一：\n\n攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。\n协议升级请求 实际到达 代理服务器。\n代理服务器 将协议升级请求转发到 邪恶服务器。\n邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。\n由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。\n\n攻击步骤二：\n\n攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）\n请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。\n代理服务器 向 邪恶服务器 请求 邪恶资源。\n邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。\n到这里，受害者可以登场了：\n\n受害者 通过 代理服务器 访问 正义服务器 的 正义资源。\n代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。\n代理服务器 将 邪恶资源 返回给 受害者。\n受害者 卒。\n附：前面提到的精心构造的“HTTP请求报文”。\n\nClient → Server:\nPOST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: <connection-key>\nServer → Client:\nHTTP/1.1 200 OK\nSec-WebSocket-Accept: <connection-key>\n2、当前解决方案\n最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。\n\n需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。\n\n但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。\n\n十、写在后面\nWebSocket可写的东西还挺多，比如WebSocket扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。\n\n篇幅所限，这里先不展开，感兴趣的同学可以留言交流。文章如有错漏，敬请指出","source":"_posts/WebSocket：5分钟从入门到精通.md","raw":"---\ntitle: WebSocket：5分钟从入门到精通\ndate: 2018-01-12 08:47:35\ntags:\n---\n一、内容概览\nWebSocket的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了WebSocket如何建立连接、交换数据的细节，以及数据帧的格式。此外，还简要介绍了针对WebSocket的安全攻击，以及协议是如何抵御类似攻击的。\n\n二、什么是WebSocket\nHTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。\n\n对大部分web开发者来说，上面这段描述有点枯燥，其实只要记住几点：\n\nWebSocket可以在浏览器里使用\n支持双向通信\n使用很简单\n1、有哪些优点\n说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。\n\n支持双向通信，实时性更强。\n更好的二进制支持。\n较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。\n支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）\n对于后面两点，没有研究过WebSocket协议规范的同学可能理解起来不够直观，但不影响对WebSocket的学习和使用。\n\n2、需要学习哪些东西\n对网络应用层协议的学习来说，最重要的往往就是连接建立过程、数据交换教程。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。\n\n下文主要围绕下面几点展开：\n\n如何建立连接\n如何交换数据\n数据帧格式\n如何维持连接\n三、入门例子\n在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了WebSocket服务端、WebSocket客户端（网页端）。完整代码可以在 这里 找到。\n\n这里服务端用了ws这个库。相比大家熟悉的socket.io，ws实现更轻量，更适合学习的目的。\n\n1、服务端\n代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。\n\nvar app = require('express')();\nvar server = require('http').Server(app);\nvar WebSocket = require('ws');\n\nvar wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n    console.log('server: receive connection.');\n    \n    ws.on('message', function incoming(message) {\n        console.log('server: received: %s', message);\n    });\n\n    ws.send('world');\n});\n\napp.get('/', function (req, res) {\n  res.sendfile(__dirname + '/index.html');\n});\n\napp.listen(3000);\n2、客户端\n代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。\n\n<script>\n  var ws = new WebSocket('ws://localhost:8080');\n  ws.onopen = function () {\n    console.log('ws onopen');\n    ws.send('from client: hello');\n  };\n  ws.onmessage = function (e) {\n    console.log('ws onmessage');\n    console.log('from server: ' + e.data);\n  };\n</script>\n3、运行结果\n可分别查看服务端、客户端的日志，这里不展开。\n\n服务端输出：\n\nserver: receive connection.\nserver: received hello\n客户端输出：\n\nclient: ws connection is open\nclient: received world\n四、如何建立连接\n前面提到，WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。\n\n1、客户端：申请协议升级\n首先，客户端发起协议升级请求。可以看到，采用的是标准的HTTP报文格式，且只支持GET方法。\n\nGET / HTTP/1.1\nHost: localhost:8080\nOrigin: http://127.0.0.1:3000\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Version: 13\nSec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==\n重点请求首部意义如下：\n\nConnection: Upgrade：表示要升级协议\nUpgrade: websocket：表示要升级到websocket协议。\nSec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。\nSec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。\n注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。\n\n2、服务端：响应协议升级\n服务端返回内容如下，状态代码101表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。\n\nHTTP/1.1 101 Switching Protocols\nConnection:Upgrade\nUpgrade: websocket\nSec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=\n\n备注：每个header都以\\r\\n结尾，并且最后一行加上一个额外的空行\\r\\n。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。\n\n3、Sec-WebSocket-Accept的计算\nSec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。\n\n计算公式为：\n\n将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。\n通过SHA1计算出摘要，并转成base64字符串。\n伪代码如下：\n\n>toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )\n验证下前面的返回结果：\n\nconst crypto = require('crypto');\nconst magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\nconst secWebSocketKey = 'w4v7O6xFTi36lq3RNcgctw==';\n\nlet secWebSocketAccept = crypto.createHash('sha1')\n\t.update(secWebSocketKey + magic)\n\t.digest('base64');\n\nconsole.log(secWebSocketAccept);\n// Oy4NRAQ13jhfONC7bP8dTKb4PTU=\n五、数据帧格式\n客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。\n\nWebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。\n\n发送端：将消息切割成多个帧，并发送给服务端；\n接收端：接收消息帧，并将关联的帧重新组装成完整的消息；\n本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455 5.2节 。\n\n1、数据帧格式概览\n下面给出了WebSocket数据帧的统一格式。熟悉TCP/IP协议的同学对这样的图应该不陌生。\n\n从左到右，单位是比特。比如FIN、RSV1各占据1比特，opcode占据4比特。\n内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）\n 2、数据帧格式详解\n针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。\n\nFIN：1个比特。\n\n如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。\n\nRSV1, RSV2, RSV3：各占1个比特。\n\n一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。\n\nOpcode: 4个比特。\n\n操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：\n\n%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。\n%x1：表示这是一个文本帧（frame）\n%x2：表示这是一个二进制帧（frame）\n%x3-7：保留的操作代码，用于后续定义的非控制帧。\n%x8：表示连接断开。\n%x9：表示这是一个ping操作。\n%xA：表示这是一个pong操作。\n%xB-F：保留的操作代码，用于后续定义的控制帧。\nMask: 1个比特。\n\n表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。\n\n如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。\n\n如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。\n\n掩码的算法、用途在下一小节讲解。\n\nPayload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。\n\n假设数Payload length === x，如果\n\nx为0~126：数据的长度为x字节。\nx为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。\nx为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。\n此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。\n\nMasking-key：0或4字节（32位）\n\n所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。\n\n备注：载荷数据的长度，不包括mask key的长度。\n\nPayload data：(x+y) 字节\n\n载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。\n\n扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。\n\n应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。\n\n3、掩码算法\n掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：\n\n首先，假设：\n\noriginal-octet-i：为原始数据的第i字节。\ntransformed-octet-i：为转换后的数据的第i字节。\nj：为i mod 4的结果。\nmasking-key-octet-j：为mask key第j字节。\n算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。\n\nj = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j\n\n六、数据传递\n一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。\n\nWebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。\n\n1、数据分片\nWebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。\n\nFIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。\n\n此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。\n\n2、数据分片例子\n直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。\n\n第一条消息\n\nFIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。\n\n第二条消息\n\nFIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。\nFIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。\nFIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。\nClient: FIN=1, opcode=0x1, msg=\"hello\"\nServer: (process complete message immediately) Hi.\nClient: FIN=0, opcode=0x1, msg=\"and a\"\nServer: (listening, new message containing text started)\nClient: FIN=0, opcode=0x0, msg=\"happy new\"\nServer: (listening, payload concatenated to previous message)\nClient: FIN=1, opcode=0x0, msg=\"year!\"\nServer: (process complete message) Happy new year to you too!\n七、连接保持+心跳\nWebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。\n\n但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。\n\n发送方->接收方：ping\n接收方->发送方：pong\nping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。\n\n举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）\n\nws.ping('', false, true);\n八、Sec-WebSocket-Key/Accept的作用\n前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。\n\n作用大致归纳如下：\n\n避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）\n确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）\n用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）\n可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。\nSec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。\n强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。\n\n九、数据掩码的作用\nWebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。\n\n那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。\n\n答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。\n\n1、代理缓存污染攻击\n下面摘自2010年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。\n\n“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”\n\n[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, \"Talking to Yourself for Fun and Profit\", 2010,\n\n在正式描述攻击步骤之前，我们假设有如下参与者：\n\n攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）\n受害者、受害者想要访问的资源（简称“正义资源”）\n受害者实际想要访问的服务器（简称“正义服务器”）\n中间代理服务器\n攻击步骤一：\n\n攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。\n协议升级请求 实际到达 代理服务器。\n代理服务器 将协议升级请求转发到 邪恶服务器。\n邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。\n由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。\n\n攻击步骤二：\n\n攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）\n请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。\n代理服务器 向 邪恶服务器 请求 邪恶资源。\n邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。\n到这里，受害者可以登场了：\n\n受害者 通过 代理服务器 访问 正义服务器 的 正义资源。\n代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。\n代理服务器 将 邪恶资源 返回给 受害者。\n受害者 卒。\n附：前面提到的精心构造的“HTTP请求报文”。\n\nClient → Server:\nPOST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: <connection-key>\nServer → Client:\nHTTP/1.1 200 OK\nSec-WebSocket-Accept: <connection-key>\n2、当前解决方案\n最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。\n\n需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。\n\n但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。\n\n十、写在后面\nWebSocket可写的东西还挺多，比如WebSocket扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。\n\n篇幅所限，这里先不展开，感兴趣的同学可以留言交流。文章如有错漏，敬请指出","slug":"WebSocket：5分钟从入门到精通","published":1,"updated":"2018-01-12T05:06:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzzc0006f7kricy24dmr","content":"<p>一、内容概览<br>WebSocket的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了WebSocket如何建立连接、交换数据的细节，以及数据帧的格式。此外，还简要介绍了针对WebSocket的安全攻击，以及协议是如何抵御类似攻击的。</p>\n<p>二、什么是WebSocket<br>HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。</p>\n<p>对大部分web开发者来说，上面这段描述有点枯燥，其实只要记住几点：</p>\n<p>WebSocket可以在浏览器里使用<br>支持双向通信<br>使用很简单<br>1、有哪些优点<br>说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。</p>\n<p>支持双向通信，实时性更强。<br>更好的二进制支持。<br>较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。<br>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）<br>对于后面两点，没有研究过WebSocket协议规范的同学可能理解起来不够直观，但不影响对WebSocket的学习和使用。</p>\n<p>2、需要学习哪些东西<br>对网络应用层协议的学习来说，最重要的往往就是连接建立过程、数据交换教程。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。</p>\n<p>下文主要围绕下面几点展开：</p>\n<p>如何建立连接<br>如何交换数据<br>数据帧格式<br>如何维持连接<br>三、入门例子<br>在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了WebSocket服务端、WebSocket客户端（网页端）。完整代码可以在 这里 找到。</p>\n<p>这里服务端用了ws这个库。相比大家熟悉的socket.io，ws实现更轻量，更适合学习的目的。</p>\n<p>1、服务端<br>代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。</p>\n<p>var app = require(‘express’)();<br>var server = require(‘http’).Server(app);<br>var WebSocket = require(‘ws’);</p>\n<p>var wss = new WebSocket.Server({ port: 8080 });</p>\n<p>wss.on(‘connection’, function connection(ws) {<br>    console.log(‘server: receive connection.’);</p>\n<pre><code>ws.on(&apos;message&apos;, function incoming(message) {\n    console.log(&apos;server: received: %s&apos;, message);\n});\n\nws.send(&apos;world&apos;);\n</code></pre><p>});</p>\n<p>app.get(‘/‘, function (req, res) {<br>  res.sendfile(__dirname + ‘/index.html’);<br>});</p>\n<p>app.listen(3000);<br>2、客户端<br>代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。</p>\n<p><script><br>  var ws = new WebSocket(‘ws://localhost:8080’);<br>  ws.onopen = function () {<br>    console.log(‘ws onopen’);<br>    ws.send(‘from client: hello’);<br>  };<br>  ws.onmessage = function (e) {<br>    console.log(‘ws onmessage’);<br>    console.log(‘from server: ‘ + e.data);<br>  };<br></script><br>3、运行结果<br>可分别查看服务端、客户端的日志，这里不展开。</p>\n<p>服务端输出：</p>\n<p>server: receive connection.<br>server: received hello<br>客户端输出：</p>\n<p>client: ws connection is open<br>client: received world<br>四、如何建立连接<br>前面提到，WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。</p>\n<p>1、客户端：申请协议升级<br>首先，客户端发起协议升级请求。可以看到，采用的是标准的HTTP报文格式，且只支持GET方法。</p>\n<p>GET / HTTP/1.1<br>Host: localhost:8080<br>Origin: <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a><br>Connection: Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Version: 13<br>Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==<br>重点请求首部意义如下：</p>\n<p>Connection: Upgrade：表示要升级协议<br>Upgrade: websocket：表示要升级到websocket协议。<br>Sec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。<br>Sec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。<br>注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。</p>\n<p>2、服务端：响应协议升级<br>服务端返回内容如下，状态代码101表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p>\n<p>HTTP/1.1 101 Switching Protocols<br>Connection:Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</p>\n<p>备注：每个header都以\\r\\n结尾，并且最后一行加上一个额外的空行\\r\\n。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。</p>\n<p>3、Sec-WebSocket-Accept的计算<br>Sec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。</p>\n<p>计算公式为：</p>\n<p>将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。<br>通过SHA1计算出摘要，并转成base64字符串。<br>伪代码如下：</p>\n<blockquote>\n<p>toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )<br>验证下前面的返回结果：</p>\n</blockquote>\n<p>const crypto = require(‘crypto’);<br>const magic = ‘258EAFA5-E914-47DA-95CA-C5AB0DC85B11’;<br>const secWebSocketKey = ‘w4v7O6xFTi36lq3RNcgctw==’;</p>\n<p>let secWebSocketAccept = crypto.createHash(‘sha1’)<br>    .update(secWebSocketKey + magic)<br>    .digest(‘base64’);</p>\n<p>console.log(secWebSocketAccept);<br>// Oy4NRAQ13jhfONC7bP8dTKb4PTU=<br>五、数据帧格式<br>客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。</p>\n<p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p>\n<p>发送端：将消息切割成多个帧，并发送给服务端；<br>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；<br>本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455 5.2节 。</p>\n<p>1、数据帧格式概览<br>下面给出了WebSocket数据帧的统一格式。熟悉TCP/IP协议的同学对这样的图应该不陌生。</p>\n<p>从左到右，单位是比特。比如FIN、RSV1各占据1比特，opcode占据4比特。<br>内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）<br> 2、数据帧格式详解<br>针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。</p>\n<p>FIN：1个比特。</p>\n<p>如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>\n<p>RSV1, RSV2, RSV3：各占1个比特。</p>\n<p>一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p>\n<p>Opcode: 4个比特。</p>\n<p>操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p>\n<p>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。<br>%x1：表示这是一个文本帧（frame）<br>%x2：表示这是一个二进制帧（frame）<br>%x3-7：保留的操作代码，用于后续定义的非控制帧。<br>%x8：表示连接断开。<br>%x9：表示这是一个ping操作。<br>%xA：表示这是一个pong操作。<br>%xB-F：保留的操作代码，用于后续定义的控制帧。<br>Mask: 1个比特。</p>\n<p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p>\n<p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p>\n<p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p>\n<p>掩码的算法、用途在下一小节讲解。</p>\n<p>Payload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。</p>\n<p>假设数Payload length === x，如果</p>\n<p>x为0~126：数据的长度为x字节。<br>x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。<br>x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。<br>此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p>\n<p>Masking-key：0或4字节（32位）</p>\n<p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p>\n<p>备注：载荷数据的长度，不包括mask key的长度。</p>\n<p>Payload data：(x+y) 字节</p>\n<p>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</p>\n<p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p>\n<p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p>\n<p>3、掩码算法<br>掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p>\n<p>首先，假设：</p>\n<p>original-octet-i：为原始数据的第i字节。<br>transformed-octet-i：为转换后的数据的第i字节。<br>j：为i mod 4的结果。<br>masking-key-octet-j：为mask key第j字节。<br>算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>\n<p>j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j</p>\n<p>六、数据传递<br>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p>\n<p>WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>\n<p>1、数据分片<br>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。</p>\n<p>FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p>\n<p>此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>\n<p>2、数据分片例子<br>直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>\n<p>第一条消息</p>\n<p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p>\n<p>第二条消息</p>\n<p>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。<br>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。<br>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。<br>Client: FIN=1, opcode=0x1, msg=”hello”<br>Server: (process complete message immediately) Hi.<br>Client: FIN=0, opcode=0x1, msg=”and a”<br>Server: (listening, new message containing text started)<br>Client: FIN=0, opcode=0x0, msg=”happy new”<br>Server: (listening, payload concatenated to previous message)<br>Client: FIN=1, opcode=0x0, msg=”year!”<br>Server: (process complete message) Happy new year to you too!<br>七、连接保持+心跳<br>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p>\n<p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>\n<p>发送方-&gt;接收方：ping<br>接收方-&gt;发送方：pong<br>ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。</p>\n<p>举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）</p>\n<p>ws.ping(‘’, false, true);<br>八、Sec-WebSocket-Key/Accept的作用<br>前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p>\n<p>作用大致归纳如下：</p>\n<p>避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）<br>确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）<br>用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）<br>可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。<br>Sec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。<br>强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。</p>\n<p>九、数据掩码的作用<br>WebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p>\n<p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p>\n<p>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p>\n<p>1、代理缓存污染攻击<br>下面摘自2010年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。</p>\n<p>“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”</p>\n<p>[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, “Talking to Yourself for Fun and Profit”, 2010,</p>\n<p>在正式描述攻击步骤之前，我们假设有如下参与者：</p>\n<p>攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）<br>受害者、受害者想要访问的资源（简称“正义资源”）<br>受害者实际想要访问的服务器（简称“正义服务器”）<br>中间代理服务器<br>攻击步骤一：</p>\n<p>攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。<br>协议升级请求 实际到达 代理服务器。<br>代理服务器 将协议升级请求转发到 邪恶服务器。<br>邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。<br>由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。</p>\n<p>攻击步骤二：</p>\n<p>攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）<br>请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。<br>代理服务器 向 邪恶服务器 请求 邪恶资源。<br>邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。<br>到这里，受害者可以登场了：</p>\n<p>受害者 通过 代理服务器 访问 正义服务器 的 正义资源。<br>代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。<br>代理服务器 将 邪恶资源 返回给 受害者。<br>受害者 卒。<br>附：前面提到的精心构造的“HTTP请求报文”。</p>\n<p>Client → Server:<br>POST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: <connection-key><br>Server → Client:<br>HTTP/1.1 200 OK<br>Sec-WebSocket-Accept: <connection-key><br>2、当前解决方案<br>最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。</connection-key></connection-key></p>\n<p>需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。</p>\n<p>但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。</p>\n<p>十、写在后面<br>WebSocket可写的东西还挺多，比如WebSocket扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。</p>\n<p>篇幅所限，这里先不展开，感兴趣的同学可以留言交流。文章如有错漏，敬请指出</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、内容概览<br>WebSocket的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了WebSocket如何建立连接、交换数据的细节，以及数据帧的格式。此外，还简要介绍了针对WebSocket的安全攻击，以及协议是如何抵御类似攻击的。</p>\n<p>二、什么是WebSocket<br>HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。</p>\n<p>对大部分web开发者来说，上面这段描述有点枯燥，其实只要记住几点：</p>\n<p>WebSocket可以在浏览器里使用<br>支持双向通信<br>使用很简单<br>1、有哪些优点<br>说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。</p>\n<p>支持双向通信，实时性更强。<br>更好的二进制支持。<br>较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。<br>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）<br>对于后面两点，没有研究过WebSocket协议规范的同学可能理解起来不够直观，但不影响对WebSocket的学习和使用。</p>\n<p>2、需要学习哪些东西<br>对网络应用层协议的学习来说，最重要的往往就是连接建立过程、数据交换教程。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。</p>\n<p>下文主要围绕下面几点展开：</p>\n<p>如何建立连接<br>如何交换数据<br>数据帧格式<br>如何维持连接<br>三、入门例子<br>在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了WebSocket服务端、WebSocket客户端（网页端）。完整代码可以在 这里 找到。</p>\n<p>这里服务端用了ws这个库。相比大家熟悉的socket.io，ws实现更轻量，更适合学习的目的。</p>\n<p>1、服务端<br>代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。</p>\n<p>var app = require(‘express’)();<br>var server = require(‘http’).Server(app);<br>var WebSocket = require(‘ws’);</p>\n<p>var wss = new WebSocket.Server({ port: 8080 });</p>\n<p>wss.on(‘connection’, function connection(ws) {<br>    console.log(‘server: receive connection.’);</p>\n<pre><code>ws.on(&apos;message&apos;, function incoming(message) {\n    console.log(&apos;server: received: %s&apos;, message);\n});\n\nws.send(&apos;world&apos;);\n</code></pre><p>});</p>\n<p>app.get(‘/‘, function (req, res) {<br>  res.sendfile(__dirname + ‘/index.html’);<br>});</p>\n<p>app.listen(3000);<br>2、客户端<br>代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。</p>\n<p><script><br>  var ws = new WebSocket(‘ws://localhost:8080’);<br>  ws.onopen = function () {<br>    console.log(‘ws onopen’);<br>    ws.send(‘from client: hello’);<br>  };<br>  ws.onmessage = function (e) {<br>    console.log(‘ws onmessage’);<br>    console.log(‘from server: ‘ + e.data);<br>  };<br></script><br>3、运行结果<br>可分别查看服务端、客户端的日志，这里不展开。</p>\n<p>服务端输出：</p>\n<p>server: receive connection.<br>server: received hello<br>客户端输出：</p>\n<p>client: ws connection is open<br>client: received world<br>四、如何建立连接<br>前面提到，WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。</p>\n<p>1、客户端：申请协议升级<br>首先，客户端发起协议升级请求。可以看到，采用的是标准的HTTP报文格式，且只支持GET方法。</p>\n<p>GET / HTTP/1.1<br>Host: localhost:8080<br>Origin: <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a><br>Connection: Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Version: 13<br>Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==<br>重点请求首部意义如下：</p>\n<p>Connection: Upgrade：表示要升级协议<br>Upgrade: websocket：表示要升级到websocket协议。<br>Sec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。<br>Sec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。<br>注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。</p>\n<p>2、服务端：响应协议升级<br>服务端返回内容如下，状态代码101表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p>\n<p>HTTP/1.1 101 Switching Protocols<br>Connection:Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</p>\n<p>备注：每个header都以\\r\\n结尾，并且最后一行加上一个额外的空行\\r\\n。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。</p>\n<p>3、Sec-WebSocket-Accept的计算<br>Sec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。</p>\n<p>计算公式为：</p>\n<p>将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。<br>通过SHA1计算出摘要，并转成base64字符串。<br>伪代码如下：</p>\n<blockquote>\n<p>toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )<br>验证下前面的返回结果：</p>\n</blockquote>\n<p>const crypto = require(‘crypto’);<br>const magic = ‘258EAFA5-E914-47DA-95CA-C5AB0DC85B11’;<br>const secWebSocketKey = ‘w4v7O6xFTi36lq3RNcgctw==’;</p>\n<p>let secWebSocketAccept = crypto.createHash(‘sha1’)<br>    .update(secWebSocketKey + magic)<br>    .digest(‘base64’);</p>\n<p>console.log(secWebSocketAccept);<br>// Oy4NRAQ13jhfONC7bP8dTKb4PTU=<br>五、数据帧格式<br>客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。</p>\n<p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p>\n<p>发送端：将消息切割成多个帧，并发送给服务端；<br>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；<br>本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455 5.2节 。</p>\n<p>1、数据帧格式概览<br>下面给出了WebSocket数据帧的统一格式。熟悉TCP/IP协议的同学对这样的图应该不陌生。</p>\n<p>从左到右，单位是比特。比如FIN、RSV1各占据1比特，opcode占据4比特。<br>内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）<br> 2、数据帧格式详解<br>针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。</p>\n<p>FIN：1个比特。</p>\n<p>如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>\n<p>RSV1, RSV2, RSV3：各占1个比特。</p>\n<p>一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p>\n<p>Opcode: 4个比特。</p>\n<p>操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p>\n<p>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。<br>%x1：表示这是一个文本帧（frame）<br>%x2：表示这是一个二进制帧（frame）<br>%x3-7：保留的操作代码，用于后续定义的非控制帧。<br>%x8：表示连接断开。<br>%x9：表示这是一个ping操作。<br>%xA：表示这是一个pong操作。<br>%xB-F：保留的操作代码，用于后续定义的控制帧。<br>Mask: 1个比特。</p>\n<p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p>\n<p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p>\n<p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p>\n<p>掩码的算法、用途在下一小节讲解。</p>\n<p>Payload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。</p>\n<p>假设数Payload length === x，如果</p>\n<p>x为0~126：数据的长度为x字节。<br>x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。<br>x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。<br>此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p>\n<p>Masking-key：0或4字节（32位）</p>\n<p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p>\n<p>备注：载荷数据的长度，不包括mask key的长度。</p>\n<p>Payload data：(x+y) 字节</p>\n<p>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</p>\n<p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p>\n<p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p>\n<p>3、掩码算法<br>掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p>\n<p>首先，假设：</p>\n<p>original-octet-i：为原始数据的第i字节。<br>transformed-octet-i：为转换后的数据的第i字节。<br>j：为i mod 4的结果。<br>masking-key-octet-j：为mask key第j字节。<br>算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>\n<p>j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j</p>\n<p>六、数据传递<br>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p>\n<p>WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>\n<p>1、数据分片<br>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。</p>\n<p>FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p>\n<p>此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>\n<p>2、数据分片例子<br>直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>\n<p>第一条消息</p>\n<p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p>\n<p>第二条消息</p>\n<p>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。<br>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。<br>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。<br>Client: FIN=1, opcode=0x1, msg=”hello”<br>Server: (process complete message immediately) Hi.<br>Client: FIN=0, opcode=0x1, msg=”and a”<br>Server: (listening, new message containing text started)<br>Client: FIN=0, opcode=0x0, msg=”happy new”<br>Server: (listening, payload concatenated to previous message)<br>Client: FIN=1, opcode=0x0, msg=”year!”<br>Server: (process complete message) Happy new year to you too!<br>七、连接保持+心跳<br>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p>\n<p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>\n<p>发送方-&gt;接收方：ping<br>接收方-&gt;发送方：pong<br>ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。</p>\n<p>举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）</p>\n<p>ws.ping(‘’, false, true);<br>八、Sec-WebSocket-Key/Accept的作用<br>前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p>\n<p>作用大致归纳如下：</p>\n<p>避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）<br>确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）<br>用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）<br>可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。<br>Sec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。<br>强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。</p>\n<p>九、数据掩码的作用<br>WebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p>\n<p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p>\n<p>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p>\n<p>1、代理缓存污染攻击<br>下面摘自2010年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。</p>\n<p>“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”</p>\n<p>[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, “Talking to Yourself for Fun and Profit”, 2010,</p>\n<p>在正式描述攻击步骤之前，我们假设有如下参与者：</p>\n<p>攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）<br>受害者、受害者想要访问的资源（简称“正义资源”）<br>受害者实际想要访问的服务器（简称“正义服务器”）<br>中间代理服务器<br>攻击步骤一：</p>\n<p>攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。<br>协议升级请求 实际到达 代理服务器。<br>代理服务器 将协议升级请求转发到 邪恶服务器。<br>邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。<br>由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。</p>\n<p>攻击步骤二：</p>\n<p>攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）<br>请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。<br>代理服务器 向 邪恶服务器 请求 邪恶资源。<br>邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。<br>到这里，受害者可以登场了：</p>\n<p>受害者 通过 代理服务器 访问 正义服务器 的 正义资源。<br>代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。<br>代理服务器 将 邪恶资源 返回给 受害者。<br>受害者 卒。<br>附：前面提到的精心构造的“HTTP请求报文”。</p>\n<p>Client → Server:<br>POST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: <connection-key><br>Server → Client:<br>HTTP/1.1 200 OK<br>Sec-WebSocket-Accept: <connection-key><br>2、当前解决方案<br>最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。</connection-key></connection-key></p>\n<p>需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。</p>\n<p>但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。</p>\n<p>十、写在后面<br>WebSocket可写的东西还挺多，比如WebSocket扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。</p>\n<p>篇幅所限，这里先不展开，感兴趣的同学可以留言交流。文章如有错漏，敬请指出</p>\n"},{"title":"react-native 踩坑及心得体会（持续更新）","date":"2018-11-07T09:16:08.000Z","_content":"\n# react-native 踩坑及心得体会\n\n### 遇到啥写啥\n\n- h.config not found ....\n\n```\n  cd node_modules/react-native/third-party/glog-0.3.5\n  ./configure\n  make\n  make install\n```\n\n- android 键盘顶开底部导航 (createBottomTabNavigator)\n\n修改 android/app/src/AndroidManifest `android:windowSoftInputMode` 的值为 `stateAlwaysHidden|adjustPan`\n\n- 使用 `antd-mobile`\n\n`npm i` 之后 `react-native run-ios` 会报关于 `react-dom` 的错误，删除 `node_modules` 并使用 `yarn` 即可解决\n\n- vscode 快速打包 android APK 任务配置\n```\n{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"build react-native android apk\",\n      \"type\": \"shell\",\n      \"command\": \"cd android/ && ./gradlew clean && ./gradlew assembleRelease && cd app/build/outputs/apk/release/ && open .\"\n    }\n  ]\n}\n```\n\n每次打包按下 `cmd + shift + p` + `Run Task` + `build react-native android apk` 一直回车即可\n\n- 查看文件代码行数\n\n进入到指定目录中执行 (.js即为查看所有js文件\b)\n\n```\nfind . \"(\" -name \"*.js\"  \")\" -print | xargs wc -l\n```\n\n- 关于 CocoaPods 配置\n\n不知道哪一版本开始(当前0.57.4)，要在 `ios/Podfile` 里这样写了\n\n```\n# Uncomment the next line to define a global platform for your project\n# platform :ios, '9.0'\n\ntarget 'AppName' do\n  # Uncomment the next line if you're using Swift or would like to use dynamic frameworks\n  # use_frameworks!\n\n  # Pods for AppName\n # 'node_modules'目录一般位于根目录中\n  # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`\n  pod 'React', :path => '../node_modules/react-native', :subspecs => [\n    'Core',\n    'CxxBridge', # 如果RN版本 >= 0.47则加入此行\n    'DevSupport', # 如果RN版本 >= 0.43，则需要加入此行才能开启开发者菜单\n    'RCTText',\n    'RCTNetwork',\n    'RCTWebSocket', # 调试功能需要此模块\n    'RCTAnimation', # FlatList和原生动画功能需要此模块\n    # 在这里继续添加你所需要的其他RN模块\n  ]\n  # 如果你的RN版本 >= 0.42.0，则加入下面这行\n  pod 'yoga', :path => '../node_modules/react-native/ReactCommon/yoga'\n\n  # 如果RN版本 >= 0.45则加入下面三个第三方编译依赖\n  pod 'DoubleConversion', :podspec => '../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec'\n  pod 'glog', :podspec => '../node_modules/react-native/third-party-podspecs/glog.podspec'\n  pod 'Folly', :podspec => '../node_modules/react-native/third-party-podspecs/Folly.podspec'\n\nend\n```\n\n```\n  pod install\n```\n","source":"_posts/react-native 踩坑及心得体会.md","raw":"---\ntitle: react-native 踩坑及心得体会（持续更新）\ndate: 2018-11-07 17:16:08\ntags:\n---\n\n# react-native 踩坑及心得体会\n\n### 遇到啥写啥\n\n- h.config not found ....\n\n```\n  cd node_modules/react-native/third-party/glog-0.3.5\n  ./configure\n  make\n  make install\n```\n\n- android 键盘顶开底部导航 (createBottomTabNavigator)\n\n修改 android/app/src/AndroidManifest `android:windowSoftInputMode` 的值为 `stateAlwaysHidden|adjustPan`\n\n- 使用 `antd-mobile`\n\n`npm i` 之后 `react-native run-ios` 会报关于 `react-dom` 的错误，删除 `node_modules` 并使用 `yarn` 即可解决\n\n- vscode 快速打包 android APK 任务配置\n```\n{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"build react-native android apk\",\n      \"type\": \"shell\",\n      \"command\": \"cd android/ && ./gradlew clean && ./gradlew assembleRelease && cd app/build/outputs/apk/release/ && open .\"\n    }\n  ]\n}\n```\n\n每次打包按下 `cmd + shift + p` + `Run Task` + `build react-native android apk` 一直回车即可\n\n- 查看文件代码行数\n\n进入到指定目录中执行 (.js即为查看所有js文件\b)\n\n```\nfind . \"(\" -name \"*.js\"  \")\" -print | xargs wc -l\n```\n\n- 关于 CocoaPods 配置\n\n不知道哪一版本开始(当前0.57.4)，要在 `ios/Podfile` 里这样写了\n\n```\n# Uncomment the next line to define a global platform for your project\n# platform :ios, '9.0'\n\ntarget 'AppName' do\n  # Uncomment the next line if you're using Swift or would like to use dynamic frameworks\n  # use_frameworks!\n\n  # Pods for AppName\n # 'node_modules'目录一般位于根目录中\n  # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`\n  pod 'React', :path => '../node_modules/react-native', :subspecs => [\n    'Core',\n    'CxxBridge', # 如果RN版本 >= 0.47则加入此行\n    'DevSupport', # 如果RN版本 >= 0.43，则需要加入此行才能开启开发者菜单\n    'RCTText',\n    'RCTNetwork',\n    'RCTWebSocket', # 调试功能需要此模块\n    'RCTAnimation', # FlatList和原生动画功能需要此模块\n    # 在这里继续添加你所需要的其他RN模块\n  ]\n  # 如果你的RN版本 >= 0.42.0，则加入下面这行\n  pod 'yoga', :path => '../node_modules/react-native/ReactCommon/yoga'\n\n  # 如果RN版本 >= 0.45则加入下面三个第三方编译依赖\n  pod 'DoubleConversion', :podspec => '../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec'\n  pod 'glog', :podspec => '../node_modules/react-native/third-party-podspecs/glog.podspec'\n  pod 'Folly', :podspec => '../node_modules/react-native/third-party-podspecs/Folly.podspec'\n\nend\n```\n\n```\n  pod install\n```\n","slug":"react-native 踩坑及心得体会","published":1,"updated":"2018-11-15T04:42:11.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzze0007f7krfzmzln4r","content":"<h1 id=\"react-native-踩坑及心得体会\"><a href=\"#react-native-踩坑及心得体会\" class=\"headerlink\" title=\"react-native 踩坑及心得体会\"></a>react-native 踩坑及心得体会</h1><h3 id=\"遇到啥写啥\"><a href=\"#遇到啥写啥\" class=\"headerlink\" title=\"遇到啥写啥\"></a>遇到啥写啥</h3><ul>\n<li>h.config not found ….</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd node_modules/react-native/third-party/glog-0.3.5</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n<ul>\n<li>android 键盘顶开底部导航 (createBottomTabNavigator)</li>\n</ul>\n<p>修改 android/app/src/AndroidManifest <code>android:windowSoftInputMode</code> 的值为 <code>stateAlwaysHidden|adjustPan</code></p>\n<ul>\n<li>使用 <code>antd-mobile</code></li>\n</ul>\n<p><code>npm i</code> 之后 <code>react-native run-ios</code> 会报关于 <code>react-dom</code> 的错误，删除 <code>node_modules</code> 并使用 <code>yarn</code> 即可解决</p>\n<ul>\n<li>vscode 快速打包 android APK 任务配置<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class=\"line\">  &quot;tasks&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;label&quot;: &quot;build react-native android apk&quot;,</span><br><span class=\"line\">      &quot;type&quot;: &quot;shell&quot;,</span><br><span class=\"line\">      &quot;command&quot;: &quot;cd android/ &amp;&amp; ./gradlew clean &amp;&amp; ./gradlew assembleRelease &amp;&amp; cd app/build/outputs/apk/release/ &amp;&amp; open .&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每次打包按下 <code>cmd + shift + p</code> + <code>Run Task</code> + <code>build react-native android apk</code> 一直回车即可</p>\n<ul>\n<li>查看文件代码行数</li>\n</ul>\n<p>进入到指定目录中执行 (.js即为查看所有js文件\b)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . &quot;(&quot; -name &quot;*.js&quot;  &quot;)&quot; -print | xargs wc -l</span><br></pre></td></tr></table></figure>\n<ul>\n<li>关于 CocoaPods 配置</li>\n</ul>\n<p>不知道哪一版本开始(当前0.57.4)，要在 <code>ios/Podfile</code> 里这样写了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Uncomment the next line to define a global platform for your project</span><br><span class=\"line\"># platform :ios, &apos;9.0&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">target &apos;AppName&apos; do</span><br><span class=\"line\">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class=\"line\">  # use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\">  # Pods for AppName</span><br><span class=\"line\"> # &apos;node_modules&apos;目录一般位于根目录中</span><br><span class=\"line\">  # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`</span><br><span class=\"line\">  pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt; [</span><br><span class=\"line\">    &apos;Core&apos;,</span><br><span class=\"line\">    &apos;CxxBridge&apos;, # 如果RN版本 &gt;= 0.47则加入此行</span><br><span class=\"line\">    &apos;DevSupport&apos;, # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单</span><br><span class=\"line\">    &apos;RCTText&apos;,</span><br><span class=\"line\">    &apos;RCTNetwork&apos;,</span><br><span class=\"line\">    &apos;RCTWebSocket&apos;, # 调试功能需要此模块</span><br><span class=\"line\">    &apos;RCTAnimation&apos;, # FlatList和原生动画功能需要此模块</span><br><span class=\"line\">    # 在这里继续添加你所需要的其他RN模块</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  # 如果你的RN版本 &gt;= 0.42.0，则加入下面这行</span><br><span class=\"line\">  pod &apos;yoga&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/yoga&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">  # 如果RN版本 &gt;= 0.45则加入下面三个第三方编译依赖</span><br><span class=\"line\">  pod &apos;DoubleConversion&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec&apos;</span><br><span class=\"line\">  pod &apos;glog&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/glog.podspec&apos;</span><br><span class=\"line\">  pod &apos;Folly&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/Folly.podspec&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod install</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"react-native-踩坑及心得体会\"><a href=\"#react-native-踩坑及心得体会\" class=\"headerlink\" title=\"react-native 踩坑及心得体会\"></a>react-native 踩坑及心得体会</h1><h3 id=\"遇到啥写啥\"><a href=\"#遇到啥写啥\" class=\"headerlink\" title=\"遇到啥写啥\"></a>遇到啥写啥</h3><ul>\n<li>h.config not found ….</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd node_modules/react-native/third-party/glog-0.3.5</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n<ul>\n<li>android 键盘顶开底部导航 (createBottomTabNavigator)</li>\n</ul>\n<p>修改 android/app/src/AndroidManifest <code>android:windowSoftInputMode</code> 的值为 <code>stateAlwaysHidden|adjustPan</code></p>\n<ul>\n<li>使用 <code>antd-mobile</code></li>\n</ul>\n<p><code>npm i</code> 之后 <code>react-native run-ios</code> 会报关于 <code>react-dom</code> 的错误，删除 <code>node_modules</code> 并使用 <code>yarn</code> 即可解决</p>\n<ul>\n<li>vscode 快速打包 android APK 任务配置<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class=\"line\">  &quot;tasks&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;label&quot;: &quot;build react-native android apk&quot;,</span><br><span class=\"line\">      &quot;type&quot;: &quot;shell&quot;,</span><br><span class=\"line\">      &quot;command&quot;: &quot;cd android/ &amp;&amp; ./gradlew clean &amp;&amp; ./gradlew assembleRelease &amp;&amp; cd app/build/outputs/apk/release/ &amp;&amp; open .&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每次打包按下 <code>cmd + shift + p</code> + <code>Run Task</code> + <code>build react-native android apk</code> 一直回车即可</p>\n<ul>\n<li>查看文件代码行数</li>\n</ul>\n<p>进入到指定目录中执行 (.js即为查看所有js文件\b)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . &quot;(&quot; -name &quot;*.js&quot;  &quot;)&quot; -print | xargs wc -l</span><br></pre></td></tr></table></figure>\n<ul>\n<li>关于 CocoaPods 配置</li>\n</ul>\n<p>不知道哪一版本开始(当前0.57.4)，要在 <code>ios/Podfile</code> 里这样写了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Uncomment the next line to define a global platform for your project</span><br><span class=\"line\"># platform :ios, &apos;9.0&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">target &apos;AppName&apos; do</span><br><span class=\"line\">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class=\"line\">  # use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\">  # Pods for AppName</span><br><span class=\"line\"> # &apos;node_modules&apos;目录一般位于根目录中</span><br><span class=\"line\">  # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`</span><br><span class=\"line\">  pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt; [</span><br><span class=\"line\">    &apos;Core&apos;,</span><br><span class=\"line\">    &apos;CxxBridge&apos;, # 如果RN版本 &gt;= 0.47则加入此行</span><br><span class=\"line\">    &apos;DevSupport&apos;, # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单</span><br><span class=\"line\">    &apos;RCTText&apos;,</span><br><span class=\"line\">    &apos;RCTNetwork&apos;,</span><br><span class=\"line\">    &apos;RCTWebSocket&apos;, # 调试功能需要此模块</span><br><span class=\"line\">    &apos;RCTAnimation&apos;, # FlatList和原生动画功能需要此模块</span><br><span class=\"line\">    # 在这里继续添加你所需要的其他RN模块</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  # 如果你的RN版本 &gt;= 0.42.0，则加入下面这行</span><br><span class=\"line\">  pod &apos;yoga&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/yoga&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">  # 如果RN版本 &gt;= 0.45则加入下面三个第三方编译依赖</span><br><span class=\"line\">  pod &apos;DoubleConversion&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec&apos;</span><br><span class=\"line\">  pod &apos;glog&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/glog.podspec&apos;</span><br><span class=\"line\">  pod &apos;Folly&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/Folly.podspec&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod install</span><br></pre></td></tr></table></figure>\n"},{"title":"svn基本操作","date":"2018-08-28T02:22:44.000Z","_content":"\n### svn基本的操作:\n\n 流程:\n\n　　你刚刚进入一个新的公司，让你接手一个正在进行的项目，你打开终端写下了：svn co svn://192.168.1.1/pro/domain 然后就可以在当前目录里面找到一个叫domain的项目，cd domain，你浏览了几行代码，太特么的竟然有bug，你忍不住改了，你要提交了，svn ci -m 'something'  ，成功。你又在domain下得app文件夹下添加了几个.php文件，把整个项目都做完了！你又打开终端：svn add domain/app/*.php 添加成功。太牛逼了，下班了，你去吃了一碗自己最喜欢的老坛酸菜味方便面。\n\n\n\n以下是一些常用命令\n\n**1、**将文件checkout到本地目录\n\n```bash\n1 svn checkout path（path是服务器上的目录）\n\n2 例如：svn checkout svn://192.168.1.1/pro/domain\n\n3 简写：svn co\n\n```\n\n**2、**往版本库中添加新的文件\n\n```bash\n1 svn add file\n\n2 例如：svn add test.php(添加test.php)\n\n3 svn add *.php(添加当前目录下所有的php文件)\n\n```\n\n**3、**将改动的文件提交到版本库\n\n```bash\n1 svn commit -m “LogMessage“ -N PATH　　　　　　　　(如果选择了保持锁，就使用–no-unlock开关)\n\n2 例如：\n\n　　svn commit -m “add test file for my test“ test.php\n\n3 简写：\n\n　　svn ci\n\n```\n\n**4、**加锁/解锁\n\n```bash\n1 svn lock -m “LockMessage“ [--force] PATH\n\n2 例如：svn lock -m “lock test file“ test.php\n\n3 svn unlock PATH\n\n```\n\n**5、**更新到某个版本\n\n```bash\n1 svn update -r m path\n\n2 例如：\n\n3 svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。\n\n4 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)\n\n5 svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)\n\n6 简写：svn up\n\n```\n\n**6、**查看文件或者目录状态\n\n```bash\n1 1）svn status path（目录下的文件和子目录的状态，正常状态不显示）\n\n2 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】\n\n3 2）svn status -v path(显示文件和子目录状态)\n\n4 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。\n\n5 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。\n\n6 简写：svn st\n\n```\n\n**7、**删除文件\n\n```bash\n1 svn delete path -m “delete test fle“\n\n2 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”\n\n3 或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种\n\n4 简写：svn (del, remove, rm)\n\n```\n\n**8、**查看日志\n\n```bash\n1 svn log path\n\n2 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化\n\n```\n\n**9、**查看文件详细信息\n\n```bash\n1 svn info path\n\n2 例如：svn info test.php\n\n```\n\n**10、**比较差异\n\n```bash\n1 svn diff path(将修改的文件与基础版本比较)\n\n2 例如：svn diff test.php\n\n3 svn diff -r m:n path(对版本m和版本n比较差异)\n\n4 例如：svn diff -r 200:201 test.php\n\n5 简写：svn di\n\n```\n\n**11、**将两个版本之间的差异合并到当前文件\n\n```bash\n1 svn merge -r m:n path\n\n2 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）\n\n```\n\n**12、**SVN 帮助\n\n```bash\n1 svn help\n\n2 svn help ci\n\n```\n\n**13、**版本库下的文件和目录列表\n\n```bash\n1 svn list path\n\n2 显示path目录下的所有属于版本库的文件和目录\n\n3 简写：svn ls\n\n```\n\n**14、**创建纳入版本控制下的新目录\n\n```bash\n1 svn mkdir: 创建纳入版本控制下的新目录。\n\n2 用法: 1、mkdir PATH…\n\n3 2、mkdir URL…\n\n4 创建版本控制的目录。\n\n5 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增\n\n6 调度，以待下一次的提交。\n\n7 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。\n\n8 在这两个情况下，所有的中间目录都必须事先存在 \n\n```\n\n**15、**恢复本地修改\n\n```bash\n1 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:\n\n2 用法: revert PATH…\n\n3 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复\n\n4 被删除的目录\n\n```\n\n**16、**代码库URL变更\n\n```bash\n 1 svn switch (sw): 更新工作副本至不同的URL。\n\n 2 用法: 1、switch URL [PATH]\n\n 3 2、switch –relocate FROM TO [PATH...]\n\n 4  \n\n 5 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将\n\n 6 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的\n\n 7 方法。\n\n 8 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动\n\n 9 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用\n\n10 这个命令更新工作副本与仓库的对应关系。\n\n```\n\n**17、**解决冲突\n\n```bash\n1 svn resolved: 移除工作副本的目录或文件的“冲突”状态。\n\n2 用法: resolved PATH…\n\n3 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的\n\n4 相关文件，然后让 PATH 可以再次提交。\n\n```\n\n#### [原文引自](https://www.cnblogs.com/luckythan/p/4478706.html)","source":"_posts/svn基本操作.md","raw":"---\ntitle: svn基本操作\ndate: 2018-08-28 10:22:44\ntags: svn\n---\n\n### svn基本的操作:\n\n 流程:\n\n　　你刚刚进入一个新的公司，让你接手一个正在进行的项目，你打开终端写下了：svn co svn://192.168.1.1/pro/domain 然后就可以在当前目录里面找到一个叫domain的项目，cd domain，你浏览了几行代码，太特么的竟然有bug，你忍不住改了，你要提交了，svn ci -m 'something'  ，成功。你又在domain下得app文件夹下添加了几个.php文件，把整个项目都做完了！你又打开终端：svn add domain/app/*.php 添加成功。太牛逼了，下班了，你去吃了一碗自己最喜欢的老坛酸菜味方便面。\n\n\n\n以下是一些常用命令\n\n**1、**将文件checkout到本地目录\n\n```bash\n1 svn checkout path（path是服务器上的目录）\n\n2 例如：svn checkout svn://192.168.1.1/pro/domain\n\n3 简写：svn co\n\n```\n\n**2、**往版本库中添加新的文件\n\n```bash\n1 svn add file\n\n2 例如：svn add test.php(添加test.php)\n\n3 svn add *.php(添加当前目录下所有的php文件)\n\n```\n\n**3、**将改动的文件提交到版本库\n\n```bash\n1 svn commit -m “LogMessage“ -N PATH　　　　　　　　(如果选择了保持锁，就使用–no-unlock开关)\n\n2 例如：\n\n　　svn commit -m “add test file for my test“ test.php\n\n3 简写：\n\n　　svn ci\n\n```\n\n**4、**加锁/解锁\n\n```bash\n1 svn lock -m “LockMessage“ [--force] PATH\n\n2 例如：svn lock -m “lock test file“ test.php\n\n3 svn unlock PATH\n\n```\n\n**5、**更新到某个版本\n\n```bash\n1 svn update -r m path\n\n2 例如：\n\n3 svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。\n\n4 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)\n\n5 svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)\n\n6 简写：svn up\n\n```\n\n**6、**查看文件或者目录状态\n\n```bash\n1 1）svn status path（目录下的文件和子目录的状态，正常状态不显示）\n\n2 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】\n\n3 2）svn status -v path(显示文件和子目录状态)\n\n4 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。\n\n5 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。\n\n6 简写：svn st\n\n```\n\n**7、**删除文件\n\n```bash\n1 svn delete path -m “delete test fle“\n\n2 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”\n\n3 或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种\n\n4 简写：svn (del, remove, rm)\n\n```\n\n**8、**查看日志\n\n```bash\n1 svn log path\n\n2 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化\n\n```\n\n**9、**查看文件详细信息\n\n```bash\n1 svn info path\n\n2 例如：svn info test.php\n\n```\n\n**10、**比较差异\n\n```bash\n1 svn diff path(将修改的文件与基础版本比较)\n\n2 例如：svn diff test.php\n\n3 svn diff -r m:n path(对版本m和版本n比较差异)\n\n4 例如：svn diff -r 200:201 test.php\n\n5 简写：svn di\n\n```\n\n**11、**将两个版本之间的差异合并到当前文件\n\n```bash\n1 svn merge -r m:n path\n\n2 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）\n\n```\n\n**12、**SVN 帮助\n\n```bash\n1 svn help\n\n2 svn help ci\n\n```\n\n**13、**版本库下的文件和目录列表\n\n```bash\n1 svn list path\n\n2 显示path目录下的所有属于版本库的文件和目录\n\n3 简写：svn ls\n\n```\n\n**14、**创建纳入版本控制下的新目录\n\n```bash\n1 svn mkdir: 创建纳入版本控制下的新目录。\n\n2 用法: 1、mkdir PATH…\n\n3 2、mkdir URL…\n\n4 创建版本控制的目录。\n\n5 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增\n\n6 调度，以待下一次的提交。\n\n7 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。\n\n8 在这两个情况下，所有的中间目录都必须事先存在 \n\n```\n\n**15、**恢复本地修改\n\n```bash\n1 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:\n\n2 用法: revert PATH…\n\n3 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复\n\n4 被删除的目录\n\n```\n\n**16、**代码库URL变更\n\n```bash\n 1 svn switch (sw): 更新工作副本至不同的URL。\n\n 2 用法: 1、switch URL [PATH]\n\n 3 2、switch –relocate FROM TO [PATH...]\n\n 4  \n\n 5 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将\n\n 6 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的\n\n 7 方法。\n\n 8 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动\n\n 9 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用\n\n10 这个命令更新工作副本与仓库的对应关系。\n\n```\n\n**17、**解决冲突\n\n```bash\n1 svn resolved: 移除工作副本的目录或文件的“冲突”状态。\n\n2 用法: resolved PATH…\n\n3 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的\n\n4 相关文件，然后让 PATH 可以再次提交。\n\n```\n\n#### [原文引自](https://www.cnblogs.com/luckythan/p/4478706.html)","slug":"svn基本操作","published":1,"updated":"2018-08-28T02:32:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzzf0008f7kryci7yyoo","content":"<h3 id=\"svn基本的操作\"><a href=\"#svn基本的操作\" class=\"headerlink\" title=\"svn基本的操作:\"></a>svn基本的操作:</h3><p> 流程:</p>\n<p>　　你刚刚进入一个新的公司，让你接手一个正在进行的项目，你打开终端写下了：svn co svn://192.168.1.1/pro/domain 然后就可以在当前目录里面找到一个叫domain的项目，cd domain，你浏览了几行代码，太特么的竟然有bug，你忍不住改了，你要提交了，svn ci -m ‘something’  ，成功。你又在domain下得app文件夹下添加了几个.php文件，把整个项目都做完了！你又打开终端：svn add domain/app/*.php 添加成功。太牛逼了，下班了，你去吃了一碗自己最喜欢的老坛酸菜味方便面。</p>\n<p>以下是一些常用命令</p>\n<p><strong>1、</strong>将文件checkout到本地目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn checkout path（path是服务器上的目录）</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn checkout svn://192.168.1.1/pro/domain</span><br><span class=\"line\"></span><br><span class=\"line\">3 简写：svn co</span><br></pre></td></tr></table></figure>\n<p><strong>2、</strong>往版本库中添加新的文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn add file</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn add test.php(添加test.php)</span><br><span class=\"line\"></span><br><span class=\"line\">3 svn add *.php(添加当前目录下所有的php文件)</span><br></pre></td></tr></table></figure>\n<p><strong>3、</strong>将改动的文件提交到版本库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn commit -m “LogMessage“ -N PATH　　　　　　　　(如果选择了保持锁，就使用–no-unlock开关)</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：</span><br><span class=\"line\"></span><br><span class=\"line\">　　svn commit -m “add <span class=\"built_in\">test</span> file <span class=\"keyword\">for</span> my <span class=\"built_in\">test</span>“ test.php</span><br><span class=\"line\"></span><br><span class=\"line\">3 简写：</span><br><span class=\"line\"></span><br><span class=\"line\">　　svn ci</span><br></pre></td></tr></table></figure>\n<p><strong>4、</strong>加锁/解锁</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn lock -m “LockMessage“ [--force] PATH</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn lock -m “lock <span class=\"built_in\">test</span> file“ test.php</span><br><span class=\"line\"></span><br><span class=\"line\">3 svn unlock PATH</span><br></pre></td></tr></table></figure>\n<p><strong>5、</strong>更新到某个版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn update -r m path</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：</span><br><span class=\"line\"></span><br><span class=\"line\">3 svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。</span><br><span class=\"line\"></span><br><span class=\"line\">4 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)</span><br><span class=\"line\"></span><br><span class=\"line\">5 svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)</span><br><span class=\"line\"></span><br><span class=\"line\">6 简写：svn up</span><br></pre></td></tr></table></figure>\n<p><strong>6、</strong>查看文件或者目录状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1）svn status path（目录下的文件和子目录的状态，正常状态不显示）</span><br><span class=\"line\"></span><br><span class=\"line\">2 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】</span><br><span class=\"line\"></span><br><span class=\"line\">3 2）svn status -v path(显示文件和子目录状态)</span><br><span class=\"line\"></span><br><span class=\"line\">4 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。</span><br><span class=\"line\"></span><br><span class=\"line\">5 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。</span><br><span class=\"line\"></span><br><span class=\"line\">6 简写：svn st</span><br></pre></td></tr></table></figure>\n<p><strong>7、</strong>删除文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn delete path -m “delete <span class=\"built_in\">test</span> fle“</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete <span class=\"built_in\">test</span> file”</span><br><span class=\"line\"></span><br><span class=\"line\">3 或者直接svn delete test.php 然后再svn ci -m ‘delete <span class=\"built_in\">test</span> file‘，推荐使用这种</span><br><span class=\"line\"></span><br><span class=\"line\">4 简写：svn (del, remove, rm)</span><br></pre></td></tr></table></figure>\n<p><strong>8、</strong>查看日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn <span class=\"built_in\">log</span> path</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn <span class=\"built_in\">log</span> test.php 显示这个文件的所有修改记录，及其版本号的变化</span><br></pre></td></tr></table></figure>\n<p><strong>9、</strong>查看文件详细信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn info path</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn info test.php</span><br></pre></td></tr></table></figure>\n<p><strong>10、</strong>比较差异</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn diff path(将修改的文件与基础版本比较)</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn diff test.php</span><br><span class=\"line\"></span><br><span class=\"line\">3 svn diff -r m:n path(对版本m和版本n比较差异)</span><br><span class=\"line\"></span><br><span class=\"line\">4 例如：svn diff -r 200:201 test.php</span><br><span class=\"line\"></span><br><span class=\"line\">5 简写：svn di</span><br></pre></td></tr></table></figure>\n<p><strong>11、</strong>将两个版本之间的差异合并到当前文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn merge -r m:n path</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）</span><br></pre></td></tr></table></figure>\n<p><strong>12、</strong>SVN 帮助</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn <span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\">2 svn <span class=\"built_in\">help</span> ci</span><br></pre></td></tr></table></figure>\n<p><strong>13、</strong>版本库下的文件和目录列表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn list path</span><br><span class=\"line\"></span><br><span class=\"line\">2 显示path目录下的所有属于版本库的文件和目录</span><br><span class=\"line\"></span><br><span class=\"line\">3 简写：svn ls</span><br></pre></td></tr></table></figure>\n<p><strong>14、</strong>创建纳入版本控制下的新目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn mkdir: 创建纳入版本控制下的新目录。</span><br><span class=\"line\"></span><br><span class=\"line\">2 用法: 1、mkdir PATH…</span><br><span class=\"line\"></span><br><span class=\"line\">3 2、mkdir URL…</span><br><span class=\"line\"></span><br><span class=\"line\">4 创建版本控制的目录。</span><br><span class=\"line\"></span><br><span class=\"line\">5 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增</span><br><span class=\"line\"></span><br><span class=\"line\">6 调度，以待下一次的提交。</span><br><span class=\"line\"></span><br><span class=\"line\">7 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。</span><br><span class=\"line\"></span><br><span class=\"line\">8 在这两个情况下，所有的中间目录都必须事先存在</span><br></pre></td></tr></table></figure>\n<p><strong>15、</strong>恢复本地修改</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:</span><br><span class=\"line\"></span><br><span class=\"line\">2 用法: revert PATH…</span><br><span class=\"line\"></span><br><span class=\"line\">3 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复</span><br><span class=\"line\"></span><br><span class=\"line\">4 被删除的目录</span><br></pre></td></tr></table></figure>\n<p><strong>16、</strong>代码库URL变更</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 svn switch (sw): 更新工作副本至不同的URL。</span><br><span class=\"line\"></span><br><span class=\"line\"> 2 用法: 1、switch URL [PATH]</span><br><span class=\"line\"></span><br><span class=\"line\"> 3 2、switch –relocate FROM TO [PATH...]</span><br><span class=\"line\"></span><br><span class=\"line\"> 4  </span><br><span class=\"line\"></span><br><span class=\"line\"> 5 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将</span><br><span class=\"line\"></span><br><span class=\"line\"> 6 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的</span><br><span class=\"line\"></span><br><span class=\"line\"> 7 方法。</span><br><span class=\"line\"></span><br><span class=\"line\"> 8 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动</span><br><span class=\"line\"></span><br><span class=\"line\"> 9 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用</span><br><span class=\"line\"></span><br><span class=\"line\">10 这个命令更新工作副本与仓库的对应关系。</span><br></pre></td></tr></table></figure>\n<p><strong>17、</strong>解决冲突</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn resolved: 移除工作副本的目录或文件的“冲突”状态。</span><br><span class=\"line\"></span><br><span class=\"line\">2 用法: resolved PATH…</span><br><span class=\"line\"></span><br><span class=\"line\">3 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的</span><br><span class=\"line\"></span><br><span class=\"line\">4 相关文件，然后让 PATH 可以再次提交。</span><br></pre></td></tr></table></figure>\n<h4 id=\"原文引自\"><a href=\"#原文引自\" class=\"headerlink\" title=\"原文引自\"></a><a href=\"https://www.cnblogs.com/luckythan/p/4478706.html\" target=\"_blank\" rel=\"noopener\">原文引自</a></h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"svn基本的操作\"><a href=\"#svn基本的操作\" class=\"headerlink\" title=\"svn基本的操作:\"></a>svn基本的操作:</h3><p> 流程:</p>\n<p>　　你刚刚进入一个新的公司，让你接手一个正在进行的项目，你打开终端写下了：svn co svn://192.168.1.1/pro/domain 然后就可以在当前目录里面找到一个叫domain的项目，cd domain，你浏览了几行代码，太特么的竟然有bug，你忍不住改了，你要提交了，svn ci -m ‘something’  ，成功。你又在domain下得app文件夹下添加了几个.php文件，把整个项目都做完了！你又打开终端：svn add domain/app/*.php 添加成功。太牛逼了，下班了，你去吃了一碗自己最喜欢的老坛酸菜味方便面。</p>\n<p>以下是一些常用命令</p>\n<p><strong>1、</strong>将文件checkout到本地目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn checkout path（path是服务器上的目录）</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn checkout svn://192.168.1.1/pro/domain</span><br><span class=\"line\"></span><br><span class=\"line\">3 简写：svn co</span><br></pre></td></tr></table></figure>\n<p><strong>2、</strong>往版本库中添加新的文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn add file</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn add test.php(添加test.php)</span><br><span class=\"line\"></span><br><span class=\"line\">3 svn add *.php(添加当前目录下所有的php文件)</span><br></pre></td></tr></table></figure>\n<p><strong>3、</strong>将改动的文件提交到版本库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn commit -m “LogMessage“ -N PATH　　　　　　　　(如果选择了保持锁，就使用–no-unlock开关)</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：</span><br><span class=\"line\"></span><br><span class=\"line\">　　svn commit -m “add <span class=\"built_in\">test</span> file <span class=\"keyword\">for</span> my <span class=\"built_in\">test</span>“ test.php</span><br><span class=\"line\"></span><br><span class=\"line\">3 简写：</span><br><span class=\"line\"></span><br><span class=\"line\">　　svn ci</span><br></pre></td></tr></table></figure>\n<p><strong>4、</strong>加锁/解锁</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn lock -m “LockMessage“ [--force] PATH</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn lock -m “lock <span class=\"built_in\">test</span> file“ test.php</span><br><span class=\"line\"></span><br><span class=\"line\">3 svn unlock PATH</span><br></pre></td></tr></table></figure>\n<p><strong>5、</strong>更新到某个版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn update -r m path</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：</span><br><span class=\"line\"></span><br><span class=\"line\">3 svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。</span><br><span class=\"line\"></span><br><span class=\"line\">4 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)</span><br><span class=\"line\"></span><br><span class=\"line\">5 svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)</span><br><span class=\"line\"></span><br><span class=\"line\">6 简写：svn up</span><br></pre></td></tr></table></figure>\n<p><strong>6、</strong>查看文件或者目录状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1）svn status path（目录下的文件和子目录的状态，正常状态不显示）</span><br><span class=\"line\"></span><br><span class=\"line\">2 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】</span><br><span class=\"line\"></span><br><span class=\"line\">3 2）svn status -v path(显示文件和子目录状态)</span><br><span class=\"line\"></span><br><span class=\"line\">4 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。</span><br><span class=\"line\"></span><br><span class=\"line\">5 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。</span><br><span class=\"line\"></span><br><span class=\"line\">6 简写：svn st</span><br></pre></td></tr></table></figure>\n<p><strong>7、</strong>删除文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn delete path -m “delete <span class=\"built_in\">test</span> fle“</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete <span class=\"built_in\">test</span> file”</span><br><span class=\"line\"></span><br><span class=\"line\">3 或者直接svn delete test.php 然后再svn ci -m ‘delete <span class=\"built_in\">test</span> file‘，推荐使用这种</span><br><span class=\"line\"></span><br><span class=\"line\">4 简写：svn (del, remove, rm)</span><br></pre></td></tr></table></figure>\n<p><strong>8、</strong>查看日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn <span class=\"built_in\">log</span> path</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn <span class=\"built_in\">log</span> test.php 显示这个文件的所有修改记录，及其版本号的变化</span><br></pre></td></tr></table></figure>\n<p><strong>9、</strong>查看文件详细信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn info path</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn info test.php</span><br></pre></td></tr></table></figure>\n<p><strong>10、</strong>比较差异</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn diff path(将修改的文件与基础版本比较)</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn diff test.php</span><br><span class=\"line\"></span><br><span class=\"line\">3 svn diff -r m:n path(对版本m和版本n比较差异)</span><br><span class=\"line\"></span><br><span class=\"line\">4 例如：svn diff -r 200:201 test.php</span><br><span class=\"line\"></span><br><span class=\"line\">5 简写：svn di</span><br></pre></td></tr></table></figure>\n<p><strong>11、</strong>将两个版本之间的差异合并到当前文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn merge -r m:n path</span><br><span class=\"line\"></span><br><span class=\"line\">2 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）</span><br></pre></td></tr></table></figure>\n<p><strong>12、</strong>SVN 帮助</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn <span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\">2 svn <span class=\"built_in\">help</span> ci</span><br></pre></td></tr></table></figure>\n<p><strong>13、</strong>版本库下的文件和目录列表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn list path</span><br><span class=\"line\"></span><br><span class=\"line\">2 显示path目录下的所有属于版本库的文件和目录</span><br><span class=\"line\"></span><br><span class=\"line\">3 简写：svn ls</span><br></pre></td></tr></table></figure>\n<p><strong>14、</strong>创建纳入版本控制下的新目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn mkdir: 创建纳入版本控制下的新目录。</span><br><span class=\"line\"></span><br><span class=\"line\">2 用法: 1、mkdir PATH…</span><br><span class=\"line\"></span><br><span class=\"line\">3 2、mkdir URL…</span><br><span class=\"line\"></span><br><span class=\"line\">4 创建版本控制的目录。</span><br><span class=\"line\"></span><br><span class=\"line\">5 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增</span><br><span class=\"line\"></span><br><span class=\"line\">6 调度，以待下一次的提交。</span><br><span class=\"line\"></span><br><span class=\"line\">7 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。</span><br><span class=\"line\"></span><br><span class=\"line\">8 在这两个情况下，所有的中间目录都必须事先存在</span><br></pre></td></tr></table></figure>\n<p><strong>15、</strong>恢复本地修改</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:</span><br><span class=\"line\"></span><br><span class=\"line\">2 用法: revert PATH…</span><br><span class=\"line\"></span><br><span class=\"line\">3 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复</span><br><span class=\"line\"></span><br><span class=\"line\">4 被删除的目录</span><br></pre></td></tr></table></figure>\n<p><strong>16、</strong>代码库URL变更</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 svn switch (sw): 更新工作副本至不同的URL。</span><br><span class=\"line\"></span><br><span class=\"line\"> 2 用法: 1、switch URL [PATH]</span><br><span class=\"line\"></span><br><span class=\"line\"> 3 2、switch –relocate FROM TO [PATH...]</span><br><span class=\"line\"></span><br><span class=\"line\"> 4  </span><br><span class=\"line\"></span><br><span class=\"line\"> 5 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将</span><br><span class=\"line\"></span><br><span class=\"line\"> 6 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的</span><br><span class=\"line\"></span><br><span class=\"line\"> 7 方法。</span><br><span class=\"line\"></span><br><span class=\"line\"> 8 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动</span><br><span class=\"line\"></span><br><span class=\"line\"> 9 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用</span><br><span class=\"line\"></span><br><span class=\"line\">10 这个命令更新工作副本与仓库的对应关系。</span><br></pre></td></tr></table></figure>\n<p><strong>17、</strong>解决冲突</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 svn resolved: 移除工作副本的目录或文件的“冲突”状态。</span><br><span class=\"line\"></span><br><span class=\"line\">2 用法: resolved PATH…</span><br><span class=\"line\"></span><br><span class=\"line\">3 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的</span><br><span class=\"line\"></span><br><span class=\"line\">4 相关文件，然后让 PATH 可以再次提交。</span><br></pre></td></tr></table></figure>\n<h4 id=\"原文引自\"><a href=\"#原文引自\" class=\"headerlink\" title=\"原文引自\"></a><a href=\"https://www.cnblogs.com/luckythan/p/4478706.html\" target=\"_blank\" rel=\"noopener\">原文引自</a></h4>"},{"title":"关于Array的ES5部分方法的实现","date":"2018-01-13T05:30:47.000Z","_content":"# 关于Array的ES5部分方法的实现\n\n> forEach\n\n```js\nif (typeof Array.prototype.forEach !== &quot;function&quot;) {\n    Array.prototype.myForEach = function (fn) {\n        for (var i = 0; i &lt; this.length; i++) {\n            // console.log(Object.prototype);\n            // console.log(Object.prototype.hasOwnProperty.call(this, i))\n            if (typeof fn === &quot;function&quot;) {\n                if (Object.prototype.hasOwnProperty.call(this, i)) {\n                    fn.call(this,this[i], i, this);\n                }\n            }\n            else {\n                throw new Error(fn + &quot; is not a function&quot;);\n            }\n        }\n    }\n }\nvar array = [1, 2, 3, 4, 5, 6];\narray.myForEach(function (value, index, array) {\n    console.log(value);\n    console.log(index);\n    console.log(array);\n})\n```\n> map\n\n```js\nif (typeof Array.prototype.map !== &quot;function&quot;) {\nArray.prototype.myMap = function (fn) {\n        var temp = [];\n        for (var i = 0; i &lt; this.length; i++) {\n            if (typeof fn === &quot;function&quot;) {\n                if (Object.prototype.hasOwnProperty.call(this, i)) {\n                    temp.push(fn.call(this, this[i], i, this));\n                }\n            } else {\n                throw new Error(fn + &quot; is not a function&quot;);\n            }\n        }\n        return temp;\n    }\n}\nvar arr1 = [1, 2, 3, 4, 5, 6];\nvar arr2 = arr1.myMap(function (value) {\n    return value * 2;\n})\nconsole.log(arr2);\n```\n\n> filter\n\n```js\nif(typeof Array.prototype.filter !== &quot;function&quot;){\n\tArray.prototype.myFilter = function(fn){\n        var temp = [];\n        for(var i=0;i&lt;this.length;i++){\n            if(typeof fn === &quot;function&quot;){\n                if(Object.prototype.hasOwnProperty.call(this,i)){\n                    if(fn.call(this,this[i])){\n                        temp.push(this[i]);\n                    }\n                }\n            }\n        }\n        return temp;\n    }\n }\nvar arr1 = [1,2,3,4,45,89,123,45,8,10];\nvar arr2 = arr1.myFilter(function(value){\n    return value &lt; 5;\n})\nconsole.log(arr2);\n```\n\n","source":"_posts/关于Array的ES5部分方法的实现.md","raw":"---\ntitle: 关于Array的ES5部分方法的实现\ndate: 2018-01-13 13:30:47\ntags:\n---\n# 关于Array的ES5部分方法的实现\n\n> forEach\n\n```js\nif (typeof Array.prototype.forEach !== &quot;function&quot;) {\n    Array.prototype.myForEach = function (fn) {\n        for (var i = 0; i &lt; this.length; i++) {\n            // console.log(Object.prototype);\n            // console.log(Object.prototype.hasOwnProperty.call(this, i))\n            if (typeof fn === &quot;function&quot;) {\n                if (Object.prototype.hasOwnProperty.call(this, i)) {\n                    fn.call(this,this[i], i, this);\n                }\n            }\n            else {\n                throw new Error(fn + &quot; is not a function&quot;);\n            }\n        }\n    }\n }\nvar array = [1, 2, 3, 4, 5, 6];\narray.myForEach(function (value, index, array) {\n    console.log(value);\n    console.log(index);\n    console.log(array);\n})\n```\n> map\n\n```js\nif (typeof Array.prototype.map !== &quot;function&quot;) {\nArray.prototype.myMap = function (fn) {\n        var temp = [];\n        for (var i = 0; i &lt; this.length; i++) {\n            if (typeof fn === &quot;function&quot;) {\n                if (Object.prototype.hasOwnProperty.call(this, i)) {\n                    temp.push(fn.call(this, this[i], i, this));\n                }\n            } else {\n                throw new Error(fn + &quot; is not a function&quot;);\n            }\n        }\n        return temp;\n    }\n}\nvar arr1 = [1, 2, 3, 4, 5, 6];\nvar arr2 = arr1.myMap(function (value) {\n    return value * 2;\n})\nconsole.log(arr2);\n```\n\n> filter\n\n```js\nif(typeof Array.prototype.filter !== &quot;function&quot;){\n\tArray.prototype.myFilter = function(fn){\n        var temp = [];\n        for(var i=0;i&lt;this.length;i++){\n            if(typeof fn === &quot;function&quot;){\n                if(Object.prototype.hasOwnProperty.call(this,i)){\n                    if(fn.call(this,this[i])){\n                        temp.push(this[i]);\n                    }\n                }\n            }\n        }\n        return temp;\n    }\n }\nvar arr1 = [1,2,3,4,45,89,123,45,8,10];\nvar arr2 = arr1.myFilter(function(value){\n    return value &lt; 5;\n})\nconsole.log(arr2);\n```\n\n","slug":"关于Array的ES5部分方法的实现","published":1,"updated":"2018-01-31T12:55:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzzj000cf7krlynvwjuo","content":"<h1 id=\"关于Array的ES5部分方法的实现\"><a href=\"#关于Array的ES5部分方法的实现\" class=\"headerlink\" title=\"关于Array的ES5部分方法的实现\"></a>关于Array的ES5部分方法的实现</h1><blockquote>\n<p>forEach</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.forEach !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.myForEach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// console.log(Object.prototype);</span></span><br><span class=\"line\">            <span class=\"comment\">// console.log(Object.prototype.hasOwnProperty.call(this, i))</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>, i)) &#123;</span><br><span class=\"line\">                    fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i], i, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(fn + &amp;quot; is not a <span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;);</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\"> &#125;</span></span><br><span class=\"line\">var array = [1, 2, 3, 4, 5, 6];</span><br><span class=\"line\">array.myForEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, index, array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>map</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.map !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.myMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>, i)) &#123;</span><br><span class=\"line\">                    temp.push(fn.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>[i], i, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(fn + &amp;quot; is not a <span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;);</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">return</span> <span class=\"title\">temp</span>;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\">var arr1 = [1, 2, 3, 4, 5, 6];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.myMap(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>filter</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.filter !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.myFilter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&amp;lt;<span class=\"keyword\">this</span>.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>,i))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i]))&#123;</span><br><span class=\"line\">                        temp.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">45</span>,<span class=\"number\">89</span>,<span class=\"number\">123</span>,<span class=\"number\">45</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.myFilter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value &amp;lt; <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于Array的ES5部分方法的实现\"><a href=\"#关于Array的ES5部分方法的实现\" class=\"headerlink\" title=\"关于Array的ES5部分方法的实现\"></a>关于Array的ES5部分方法的实现</h1><blockquote>\n<p>forEach</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.forEach !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.myForEach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// console.log(Object.prototype);</span></span><br><span class=\"line\">            <span class=\"comment\">// console.log(Object.prototype.hasOwnProperty.call(this, i))</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>, i)) &#123;</span><br><span class=\"line\">                    fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i], i, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(fn + &amp;quot; is not a <span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;);</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\"> &#125;</span></span><br><span class=\"line\">var array = [1, 2, 3, 4, 5, 6];</span><br><span class=\"line\">array.myForEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, index, array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>map</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.map !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.myMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>, i)) &#123;</span><br><span class=\"line\">                    temp.push(fn.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>[i], i, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(fn + &amp;quot; is not a <span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;);</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">return</span> <span class=\"title\">temp</span>;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\">var arr1 = [1, 2, 3, 4, 5, 6];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.myMap(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>filter</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.filter !== &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.myFilter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&amp;lt;<span class=\"keyword\">this</span>.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fn === &amp;quot;<span class=\"function\"><span class=\"keyword\">function</span>&amp;<span class=\"title\">quot</span>;)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(<span class=\"keyword\">this</span>,i))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i]))&#123;</span><br><span class=\"line\">                        temp.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">45</span>,<span class=\"number\">89</span>,<span class=\"number\">123</span>,<span class=\"number\">45</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.myFilter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value &amp;lt; <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>\n"},{"title":"关于puppeteer","date":"2018-01-20T07:23:24.000Z","_content":"\n### 介绍一下Puppeteer\n\n>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API（默认headless也就是无UI的chrome，也可以配置为有UI</br>有点类似于PhantomJS，但Puppeteer是Chrome官方团队进行维护的，前景更好。</br>使用Puppeteer，相当于同时具有Linux和Chrome的能力，应用场景会非常多。就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关\n\n#### [详情请看Puppeteer官方文档](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser)\n\n阅读以下内容，可以实现爬取[片刻网](http://pianke.me)的首页数据。\n\n#### Puppeteer 几个重要功能\n* 可以抓取网站内容\n* 可以自动化表单提交、搜索网络内容、UI测试等\n* 获取网页生成的PDF、图片、视频等资源\n\n接下来的操作基于 Node 环境\n\n```\nmkdir test && cd test\nnpm init\nnpm install puppeteer\n```\n\n<!--上述命令墙内用户可能会有问题，建议科学上网-->\n\n#### Puppeteer 基本用法\n\n1.使用`puppeteer.launch()`运行puppeteer，他会return一个promise，使用then方法获取browser实例，[Browser API](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser).\n\n2.拿到browser实例后，通过`browser.newPage()`方法，可以得到一个page实例，[Page API](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-page).\n\n3.使用`page.goto()`方法，[跳转至ES6标准入门](http://es6.ruanyifeng.com/#README).\n\n4.在`page.evaluate()`方法中注册回调函数，并分析dom结构，从下图可以进行详细分析，并通过`document.querySelectorAll('ol li a')`拿到想要获取的内容.\n\n#### 具体代码\n\n[点我查看详细代码](https://github.com/easy261925/Puppeteer)\n\n或 `git clone git@github.com:easy261925/Puppeteer.git`\n\n#### 说一下我遇到坑吧\n\n1. 在配置环境的时候由于网络的原因，在安装 Puppetee 的时候可能会无法安装,[ node_modules 百度云下载地址 ](https://pan.baidu.com/s/1dIMKjk) 密码: bxhy. 不需要 `npm i`了, 下载完后直接使用`node getData.js`即可.\n2. 代码的实现过程, 在看过网上很多关于 Puppeteer 技术文章和同学大力帮助之后，也算把想要的结果得到了，但是关于 async Promise await 等函数以及 ES6 Array\n的新用法还不是特别清楚， 本人打算学习[ 阮一峰老师的ES6 ](http://es6.ruanyifeng.com/#README)之后, 在来详细补充其原理.\n3. 爬取到的数据是通过 class 名，找到里面元素的 src/style/innerText，但是获取到的数据格式为:` img:['1.jpg','2.jpg'];title:[ 'AAAAAAA','BBBBBBB'] ` 为了使用方便，我们对数据做了一些调整，让它变为`[{item1:['1.jpg','AAAAAAA']},{item1:['2.jpg','BBBBBBB']}]`,这样我们在铺到页面上时使用更加方便了.( 经历此过程也体验了一回写 API 接口的感觉 全是眼泪啊~~~ )\n\n\n### 结语\n由于能力有限,存在的问题还有很多，请看到此文的人不吝赐教，感激不尽。\n\n特别鸣谢:[QC-L老师](https://github.com/QC-L)，[marryyan ](https://github.com/marryyan)的帮助.\n\n### 未完待续。。。\n\n##### 参考文章:[https://segmentfault.com/a/1190000010736797](https://segmentfault.com/a/1190000010736797)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/关于puppeteer.md","raw":"---\ntitle: 关于puppeteer\ndate: 2018-01-20 15:23:24\ntags: puppeteer\ncategories: Node\n---\n\n### 介绍一下Puppeteer\n\n>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API（默认headless也就是无UI的chrome，也可以配置为有UI</br>有点类似于PhantomJS，但Puppeteer是Chrome官方团队进行维护的，前景更好。</br>使用Puppeteer，相当于同时具有Linux和Chrome的能力，应用场景会非常多。就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关\n\n#### [详情请看Puppeteer官方文档](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser)\n\n阅读以下内容，可以实现爬取[片刻网](http://pianke.me)的首页数据。\n\n#### Puppeteer 几个重要功能\n* 可以抓取网站内容\n* 可以自动化表单提交、搜索网络内容、UI测试等\n* 获取网页生成的PDF、图片、视频等资源\n\n接下来的操作基于 Node 环境\n\n```\nmkdir test && cd test\nnpm init\nnpm install puppeteer\n```\n\n<!--上述命令墙内用户可能会有问题，建议科学上网-->\n\n#### Puppeteer 基本用法\n\n1.使用`puppeteer.launch()`运行puppeteer，他会return一个promise，使用then方法获取browser实例，[Browser API](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser).\n\n2.拿到browser实例后，通过`browser.newPage()`方法，可以得到一个page实例，[Page API](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-page).\n\n3.使用`page.goto()`方法，[跳转至ES6标准入门](http://es6.ruanyifeng.com/#README).\n\n4.在`page.evaluate()`方法中注册回调函数，并分析dom结构，从下图可以进行详细分析，并通过`document.querySelectorAll('ol li a')`拿到想要获取的内容.\n\n#### 具体代码\n\n[点我查看详细代码](https://github.com/easy261925/Puppeteer)\n\n或 `git clone git@github.com:easy261925/Puppeteer.git`\n\n#### 说一下我遇到坑吧\n\n1. 在配置环境的时候由于网络的原因，在安装 Puppetee 的时候可能会无法安装,[ node_modules 百度云下载地址 ](https://pan.baidu.com/s/1dIMKjk) 密码: bxhy. 不需要 `npm i`了, 下载完后直接使用`node getData.js`即可.\n2. 代码的实现过程, 在看过网上很多关于 Puppeteer 技术文章和同学大力帮助之后，也算把想要的结果得到了，但是关于 async Promise await 等函数以及 ES6 Array\n的新用法还不是特别清楚， 本人打算学习[ 阮一峰老师的ES6 ](http://es6.ruanyifeng.com/#README)之后, 在来详细补充其原理.\n3. 爬取到的数据是通过 class 名，找到里面元素的 src/style/innerText，但是获取到的数据格式为:` img:['1.jpg','2.jpg'];title:[ 'AAAAAAA','BBBBBBB'] ` 为了使用方便，我们对数据做了一些调整，让它变为`[{item1:['1.jpg','AAAAAAA']},{item1:['2.jpg','BBBBBBB']}]`,这样我们在铺到页面上时使用更加方便了.( 经历此过程也体验了一回写 API 接口的感觉 全是眼泪啊~~~ )\n\n\n### 结语\n由于能力有限,存在的问题还有很多，请看到此文的人不吝赐教，感激不尽。\n\n特别鸣谢:[QC-L老师](https://github.com/QC-L)，[marryyan ](https://github.com/marryyan)的帮助.\n\n### 未完待续。。。\n\n##### 参考文章:[https://segmentfault.com/a/1190000010736797](https://segmentfault.com/a/1190000010736797)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"关于puppeteer","published":1,"updated":"2018-01-22T02:03:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzzn000df7kr3ozgmxar","content":"<h3 id=\"介绍一下Puppeteer\"><a href=\"#介绍一下Puppeteer\" class=\"headerlink\" title=\"介绍一下Puppeteer\"></a>介绍一下Puppeteer</h3><blockquote>\n<p>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API（默认headless也就是无UI的chrome，也可以配置为有UI<br>有点类似于PhantomJS，但Puppeteer是Chrome官方团队进行维护的，前景更好。<br>使用Puppeteer，相当于同时具有Linux和Chrome的能力，应用场景会非常多。就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关</p>\n</blockquote>\n<h4 id=\"详情请看Puppeteer官方文档\"><a href=\"#详情请看Puppeteer官方文档\" class=\"headerlink\" title=\"详情请看Puppeteer官方文档\"></a><a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser\" target=\"_blank\" rel=\"noopener\">详情请看Puppeteer官方文档</a></h4><p>阅读以下内容，可以实现爬取<a href=\"http://pianke.me\" target=\"_blank\" rel=\"noopener\">片刻网</a>的首页数据。</p>\n<h4 id=\"Puppeteer-几个重要功能\"><a href=\"#Puppeteer-几个重要功能\" class=\"headerlink\" title=\"Puppeteer 几个重要功能\"></a>Puppeteer 几个重要功能</h4><ul>\n<li>可以抓取网站内容</li>\n<li>可以自动化表单提交、搜索网络内容、UI测试等</li>\n<li>获取网页生成的PDF、图片、视频等资源</li>\n</ul>\n<p>接下来的操作基于 Node 环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir test &amp;&amp; cd test</span><br><span class=\"line\">npm init</span><br><span class=\"line\">npm install puppeteer</span><br></pre></td></tr></table></figure>\n<!--上述命令墙内用户可能会有问题，建议科学上网-->\n<h4 id=\"Puppeteer-基本用法\"><a href=\"#Puppeteer-基本用法\" class=\"headerlink\" title=\"Puppeteer 基本用法\"></a>Puppeteer 基本用法</h4><p>1.使用<code>puppeteer.launch()</code>运行puppeteer，他会return一个promise，使用then方法获取browser实例，<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser\" target=\"_blank\" rel=\"noopener\">Browser API</a>.</p>\n<p>2.拿到browser实例后，通过<code>browser.newPage()</code>方法，可以得到一个page实例，<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-page\" target=\"_blank\" rel=\"noopener\">Page API</a>.</p>\n<p>3.使用<code>page.goto()</code>方法，<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">跳转至ES6标准入门</a>.</p>\n<p>4.在<code>page.evaluate()</code>方法中注册回调函数，并分析dom结构，从下图可以进行详细分析，并通过<code>document.querySelectorAll(&#39;ol li a&#39;)</code>拿到想要获取的内容.</p>\n<h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><p><a href=\"https://github.com/easy261925/Puppeteer\" target=\"_blank\" rel=\"noopener\">点我查看详细代码</a></p>\n<p>或 <code>git clone git@github.com:easy261925/Puppeteer.git</code></p>\n<h4 id=\"说一下我遇到坑吧\"><a href=\"#说一下我遇到坑吧\" class=\"headerlink\" title=\"说一下我遇到坑吧\"></a>说一下我遇到坑吧</h4><ol>\n<li>在配置环境的时候由于网络的原因，在安装 Puppetee 的时候可能会无法安装,<a href=\"https://pan.baidu.com/s/1dIMKjk\" target=\"_blank\" rel=\"noopener\"> node_modules 百度云下载地址 </a> 密码: bxhy. 不需要 <code>npm i</code>了, 下载完后直接使用<code>node getData.js</code>即可.</li>\n<li>代码的实现过程, 在看过网上很多关于 Puppeteer 技术文章和同学大力帮助之后，也算把想要的结果得到了，但是关于 async Promise await 等函数以及 ES6 Array<br>的新用法还不是特别清楚， 本人打算学习<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\"> 阮一峰老师的ES6 </a>之后, 在来详细补充其原理.</li>\n<li>爬取到的数据是通过 class 名，找到里面元素的 src/style/innerText，但是获取到的数据格式为:<code>img:[&#39;1.jpg&#39;,&#39;2.jpg&#39;];title:[ &#39;AAAAAAA&#39;,&#39;BBBBBBB&#39;]</code> 为了使用方便，我们对数据做了一些调整，让它变为<code>[{item1:[&#39;1.jpg&#39;,&#39;AAAAAAA&#39;]},{item1:[&#39;2.jpg&#39;,&#39;BBBBBBB&#39;]}]</code>,这样我们在铺到页面上时使用更加方便了.( 经历此过程也体验了一回写 API 接口的感觉 全是眼泪啊~~~ )</li>\n</ol>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>由于能力有限,存在的问题还有很多，请看到此文的人不吝赐教，感激不尽。</p>\n<p>特别鸣谢:<a href=\"https://github.com/QC-L\" target=\"_blank\" rel=\"noopener\">QC-L老师</a>，<a href=\"https://github.com/marryyan\" target=\"_blank\" rel=\"noopener\">marryyan </a>的帮助.</p>\n<h3 id=\"未完待续。。。\"><a href=\"#未完待续。。。\" class=\"headerlink\" title=\"未完待续。。。\"></a>未完待续。。。</h3><h5 id=\"参考文章-https-segmentfault-com-a-1190000010736797\"><a href=\"#参考文章-https-segmentfault-com-a-1190000010736797\" class=\"headerlink\" title=\"参考文章:https://segmentfault.com/a/1190000010736797\"></a>参考文章:<a href=\"https://segmentfault.com/a/1190000010736797\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000010736797</a></h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"介绍一下Puppeteer\"><a href=\"#介绍一下Puppeteer\" class=\"headerlink\" title=\"介绍一下Puppeteer\"></a>介绍一下Puppeteer</h3><blockquote>\n<p>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API（默认headless也就是无UI的chrome，也可以配置为有UI<br>有点类似于PhantomJS，但Puppeteer是Chrome官方团队进行维护的，前景更好。<br>使用Puppeteer，相当于同时具有Linux和Chrome的能力，应用场景会非常多。就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关</p>\n</blockquote>\n<h4 id=\"详情请看Puppeteer官方文档\"><a href=\"#详情请看Puppeteer官方文档\" class=\"headerlink\" title=\"详情请看Puppeteer官方文档\"></a><a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser\" target=\"_blank\" rel=\"noopener\">详情请看Puppeteer官方文档</a></h4><p>阅读以下内容，可以实现爬取<a href=\"http://pianke.me\" target=\"_blank\" rel=\"noopener\">片刻网</a>的首页数据。</p>\n<h4 id=\"Puppeteer-几个重要功能\"><a href=\"#Puppeteer-几个重要功能\" class=\"headerlink\" title=\"Puppeteer 几个重要功能\"></a>Puppeteer 几个重要功能</h4><ul>\n<li>可以抓取网站内容</li>\n<li>可以自动化表单提交、搜索网络内容、UI测试等</li>\n<li>获取网页生成的PDF、图片、视频等资源</li>\n</ul>\n<p>接下来的操作基于 Node 环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir test &amp;&amp; cd test</span><br><span class=\"line\">npm init</span><br><span class=\"line\">npm install puppeteer</span><br></pre></td></tr></table></figure>\n<!--上述命令墙内用户可能会有问题，建议科学上网-->\n<h4 id=\"Puppeteer-基本用法\"><a href=\"#Puppeteer-基本用法\" class=\"headerlink\" title=\"Puppeteer 基本用法\"></a>Puppeteer 基本用法</h4><p>1.使用<code>puppeteer.launch()</code>运行puppeteer，他会return一个promise，使用then方法获取browser实例，<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser\" target=\"_blank\" rel=\"noopener\">Browser API</a>.</p>\n<p>2.拿到browser实例后，通过<code>browser.newPage()</code>方法，可以得到一个page实例，<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-page\" target=\"_blank\" rel=\"noopener\">Page API</a>.</p>\n<p>3.使用<code>page.goto()</code>方法，<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">跳转至ES6标准入门</a>.</p>\n<p>4.在<code>page.evaluate()</code>方法中注册回调函数，并分析dom结构，从下图可以进行详细分析，并通过<code>document.querySelectorAll(&#39;ol li a&#39;)</code>拿到想要获取的内容.</p>\n<h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><p><a href=\"https://github.com/easy261925/Puppeteer\" target=\"_blank\" rel=\"noopener\">点我查看详细代码</a></p>\n<p>或 <code>git clone git@github.com:easy261925/Puppeteer.git</code></p>\n<h4 id=\"说一下我遇到坑吧\"><a href=\"#说一下我遇到坑吧\" class=\"headerlink\" title=\"说一下我遇到坑吧\"></a>说一下我遇到坑吧</h4><ol>\n<li>在配置环境的时候由于网络的原因，在安装 Puppetee 的时候可能会无法安装,<a href=\"https://pan.baidu.com/s/1dIMKjk\" target=\"_blank\" rel=\"noopener\"> node_modules 百度云下载地址 </a> 密码: bxhy. 不需要 <code>npm i</code>了, 下载完后直接使用<code>node getData.js</code>即可.</li>\n<li>代码的实现过程, 在看过网上很多关于 Puppeteer 技术文章和同学大力帮助之后，也算把想要的结果得到了，但是关于 async Promise await 等函数以及 ES6 Array<br>的新用法还不是特别清楚， 本人打算学习<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\"> 阮一峰老师的ES6 </a>之后, 在来详细补充其原理.</li>\n<li>爬取到的数据是通过 class 名，找到里面元素的 src/style/innerText，但是获取到的数据格式为:<code>img:[&#39;1.jpg&#39;,&#39;2.jpg&#39;];title:[ &#39;AAAAAAA&#39;,&#39;BBBBBBB&#39;]</code> 为了使用方便，我们对数据做了一些调整，让它变为<code>[{item1:[&#39;1.jpg&#39;,&#39;AAAAAAA&#39;]},{item1:[&#39;2.jpg&#39;,&#39;BBBBBBB&#39;]}]</code>,这样我们在铺到页面上时使用更加方便了.( 经历此过程也体验了一回写 API 接口的感觉 全是眼泪啊~~~ )</li>\n</ol>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>由于能力有限,存在的问题还有很多，请看到此文的人不吝赐教，感激不尽。</p>\n<p>特别鸣谢:<a href=\"https://github.com/QC-L\" target=\"_blank\" rel=\"noopener\">QC-L老师</a>，<a href=\"https://github.com/marryyan\" target=\"_blank\" rel=\"noopener\">marryyan </a>的帮助.</p>\n<h3 id=\"未完待续。。。\"><a href=\"#未完待续。。。\" class=\"headerlink\" title=\"未完待续。。。\"></a>未完待续。。。</h3><h5 id=\"参考文章-https-segmentfault-com-a-1190000010736797\"><a href=\"#参考文章-https-segmentfault-com-a-1190000010736797\" class=\"headerlink\" title=\"参考文章:https://segmentfault.com/a/1190000010736797\"></a>参考文章:<a href=\"https://segmentfault.com/a/1190000010736797\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000010736797</a></h5>"},{"title":"实战项目总结一 (to8to项目基础配置)","date":"2018-03-18T03:58:31.000Z","_content":"\n# 实战项目总结一 (to8to项目基础配置)\n\n\n## `webpack` 的配置 (@3.11.0)\n\n\n#### `webpack.base.js` 文件\n\n#### loader\n> `eslint` 代码格式规范: `eslint-loader` \n>  \n> `js` 处理 js 文件，可以使用 ES6 等高级语法: `babel-loader`\n> \n> 开发和生产环境都使用了 `less`: `style-loader,css-loader,less-loader`\n> \n>  图片处理: `url-loader`\n> \n> \n#### plugins\n\n>`HTMLWebpackPlugin` 打包后的 `js` 文件放入到指定 `.html` 文件中 \n>\n\n#### 项目路径别名 (alias)\n\n```js\n Common: path.join(__dirname, '..', 'src/components/common/')\n```\n\n#### 代码\n`webpack.base.js`\n\n```js\nconst path = require('path')\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\n// 合并路径方法\nconst resolve = (dir) => {\n  return path.join(__dirname, '..', dir)\n}\n\nmodule.exports = {\n  entry: {\n    bundle: path.join(__dirname, '../src/index.js')\n  },\n  output: {\n    path: path.resolve('dist'),\n    filename: '[name].[hash:7].js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: [\n          /node_modules/, /build/, resolve('src/router/')\n        ], // 不需要规范代码的文件夹\n        loader: 'eslint-loader',\n        enforce: 'pre', // 编译之前\n        include: [\n          resolve('src'), resolve('test') // 需要规范代码的文件夹\n        ],\n        options: {\n          formatter: require('eslint-friendly-formatter')\n        }\n      }, {\n        test: /\\.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [\n              '@babel/preset-env', '@babel/preset-react'\n            ],\n            'plugins': [\n              [\n                'import', {\n                  'libraryName': 'antd',\n                  'libraryDirectory': 'es',\n                  'style': 'true'\n                }\n                // 按需加载 antd\n              ],\n              ['@babel/plugin-transform-runtime', {\n                'helpers': false,\n                'polyfill': false,\n                'regenerator': true,\n                'moduleName': '@babel/runtime'\n              }\n              \t// 项目支持 async/await等高级语法\n              ],\n              ['transform-react-remove-prop-types']\n              // 生产环境删除 prop=types\n            ]\n          }\n        },\n        exclude: /node_modules/ // 不需要打包的文件夹\n      }, {\n        test: /\\.less$/,\n        use: [\n          {\n            loader: 'style-loader'\n          }, {\n            loader: 'css-loader'\n          }, {\n            loader: 'less-loader'\n          }\n        ]\n      }, {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 8192,\n              name: 'assets/images/[hash:8].[name].[ext]'\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [new HTMLWebpackPlugin({template: 'index.html', filename: 'index.html', inject: 'body'})],\n  resolve: {\n    alias: {\n      Common: path.join(__dirname, '..', 'src/components/common/'),\n      Pages: path.join(__dirname, '..', 'src/pages/'),\n      Styles: path.join(__dirname, '..', 'src/assets/style'),\n      Component: path.join(__dirname, '..', 'src/components/'),\n      CommonActions: path.join(__dirname, '..', 'src/actions/commonActions'),\n      CommonReducers: path.join(__dirname, '..', 'src/reducers/commonReducers'),\n      Images: path.join(__dirname, '..', 'src/assets/image'),\n      Datas: path.join(__dirname, '..', 'src/assets/data')\n    }\n  }\n}\n```\n \n\n--\n#### `webpack.dev.js` 文件\n\n使用 `webpack-merge` 合并 `webpack.base.js`\n\n#### loader\n\n处理 css 文件 (因为已经采用了 `less` 作为 `css` 样式处理), 此 `loader` 可以省略\n\n#### devtool\n\n>`devtool: \"inline-source-map\"`\n>\n>生成一个 DataUrl 形式的 SourceMap 文件.\n\n#### devServer\n\n```\ndevServer: {\n    hot: true,  // 热处理\n    inline: true,\n    proxy: { // 跨域代理\n      '/api': {\n        target: 'https://example.com/',\n        changeOrigin: true,\n        pathRewrite: {'^/api': ''}\n      }\n    }\n  }\n```\n\n#### plugins\n\n`NamedModulesPlugin` `HotModuleReplacementPlugin` 协助处理文件热更新\n\n#### 代码\n\n```js\nconst merge = require(\"webpack-merge\");\nconst base = require(\"./webpack.base\");\nconst webpack = require(\"webpack\");\n\nmodule.exports = merge(base, {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          \"style-loader\", \"css-loader\"\n        ],\n        exclude: /node_modules/\n      }\n    ]\n  },\n  devtool: \"inline-source-map\",\n  devServer: {\n    hot: true,\n    inline: true,\n    proxy: {\n      '/api': {\n        target: 'https://exmaple.com/',\n        changeOrigin: true,\n        pathRewrite: {'^/api': ''}\n      }\n    }\n  },\n  plugins: [\n    new webpack.NamedModulesPlugin(),\n    new webpack.HotModuleReplacementPlugin()\n  ]\n})\n```\n\n--\n#### `webpack.prod.js` 文件\n\n#### devtool\n\n>`source-map` \n>\n>解决开发代码与实际运行代码不一致时，帮助我们 debug 到原始开发代码\n\n#### loader\n\n> 把 css 样式为 .html 中的 style\n> \n> `extract-text-webpack-plugin`\n> \n\n#### plugins\n`extract-text-webpack-plugin` 处理 `css` 样式为 `style`\n\n`clean-webpack-plugin` 删除 `dist` 文件夹\n\n`webpack.optimize.CommonsChunkPlugin` 提取项目中的公共代码部分到 `common.js`中\n\n`webpack.DllReferencePlugin` 将第三方插件/库与项目中的代码分开打包，提升打包效率\n\n`uglifyjs-webpack-plugin` 丑化/压缩打包后的代码\n\n#### 代码\n\n```js\nconst merge = require(\"webpack-merge\");\nconst base = require(\"./webpack.base\");\nconst ExtractTextWebpackPlugin = require(\"extract-text-webpack-plugin\");\nconst CleanWebpackPlugin = require(\"clean-webpack-plugin\");\nconst UglifyjsWebpackPlugin = require(\"uglifyjs-webpack-plugin\");\nconst webpack = require(\"webpack\");\nconst path = require(\"path\");\n\nmodule.exports = merge(base, {\n  // entry: {\n  //  vendor: [\"react\",\"react-dom\"]\n  // },\n  dependencies: [\"./lib/vendor.js\"],\n  devtool: \"source-map\",\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ExtractTextWebpackPlugin.extract({fallback: \"style-loader\", use: \"css-loader\"}),\n        exclude: /node_moudles/\n      }\n    ]\n  },\n  plugins: [\n    new ExtractTextWebpackPlugin(\"styles.css\"),\n    new CleanWebpackPlugin([\"dist\"]),\n    // new UglifyjsWebpackPlugin({sourceMap: false}),\n    new webpack\n      .optimize\n      .CommonsChunkPlugin({name: \"common\", filename: \"common.js\"}),\n    // new webpack\n    //   .optimize\n    //   .CommonsChunkPlugin({\n    //     name: [\"vendor\",\"common\"],\n    //     // filename: \"vendor.js\" (给 chunk 一个不同的名字)\n    //     minChunks: Infinity,\n    //     // (随着 entry chunk 越来越多， 这个配置保证没其它的模块会打包进 vendor chunk)\n    //   })\n    new webpack.DllReferencePlugin({\n      manifest: path.resolve(__dirname, \"../lib/manifest.json\")\n    })\n  ]\n});\n\n```\n\n--\n#### `webpack.dll.js` 文件\n\n#### entry\n\n需要抽离出来的第三方库\n\n`react` `react-dom` `react-router-dom` `redux` `react-redux`\n\n#### output\n\n抽离出来的文件出口配置,放到 `/lib/vendor.js`\n\n#### plugins\n\n`webpack.DllPlugin` 将第三方库抽离出来并打包\n\n`uglifyjs-webpack-plugin` 丑化/压缩代码\n\n#### 代码\n```js\nconst webpack = require(\"webpack\");\nconst path = require(\"path\");\nconst UglifyjsWebpackPlugin = require(\"uglifyjs-webpack-plugin\");\n\nmodule.exports = {\n  entry: [\n    \"react\",\n    \"react-dom\",\n    \"react-router-dom\",\n    \"redux\",\n    \"react-redux\"\n    /** ... 等其他依赖库 */\n  ],\n  output: {\n    path: path.resolve(\"lib\"),\n    filename: \"vendor.js\",\n    library: \"vendor_[hash]\"\n  },\n  plugins: [\n    new webpack.DllPlugin({\n      name: \"vendor_[hash]\",\n      path: path.resolve(\"lib/manifest.json\")\n    }),\n    new UglifyjsWebpackPlugin()\n  ]\n}\n```\n\n","source":"_posts/实战项目总结一 (to8to项目基础配置).md","raw":"---\ntitle: 实战项目总结一 (to8to项目基础配置)\ndate: 2018-03-18 11:58:31\ntags: 技术总结 webpack to8to react\ncategories: React webpack\n---\n\n# 实战项目总结一 (to8to项目基础配置)\n\n\n## `webpack` 的配置 (@3.11.0)\n\n\n#### `webpack.base.js` 文件\n\n#### loader\n> `eslint` 代码格式规范: `eslint-loader` \n>  \n> `js` 处理 js 文件，可以使用 ES6 等高级语法: `babel-loader`\n> \n> 开发和生产环境都使用了 `less`: `style-loader,css-loader,less-loader`\n> \n>  图片处理: `url-loader`\n> \n> \n#### plugins\n\n>`HTMLWebpackPlugin` 打包后的 `js` 文件放入到指定 `.html` 文件中 \n>\n\n#### 项目路径别名 (alias)\n\n```js\n Common: path.join(__dirname, '..', 'src/components/common/')\n```\n\n#### 代码\n`webpack.base.js`\n\n```js\nconst path = require('path')\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\n// 合并路径方法\nconst resolve = (dir) => {\n  return path.join(__dirname, '..', dir)\n}\n\nmodule.exports = {\n  entry: {\n    bundle: path.join(__dirname, '../src/index.js')\n  },\n  output: {\n    path: path.resolve('dist'),\n    filename: '[name].[hash:7].js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: [\n          /node_modules/, /build/, resolve('src/router/')\n        ], // 不需要规范代码的文件夹\n        loader: 'eslint-loader',\n        enforce: 'pre', // 编译之前\n        include: [\n          resolve('src'), resolve('test') // 需要规范代码的文件夹\n        ],\n        options: {\n          formatter: require('eslint-friendly-formatter')\n        }\n      }, {\n        test: /\\.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [\n              '@babel/preset-env', '@babel/preset-react'\n            ],\n            'plugins': [\n              [\n                'import', {\n                  'libraryName': 'antd',\n                  'libraryDirectory': 'es',\n                  'style': 'true'\n                }\n                // 按需加载 antd\n              ],\n              ['@babel/plugin-transform-runtime', {\n                'helpers': false,\n                'polyfill': false,\n                'regenerator': true,\n                'moduleName': '@babel/runtime'\n              }\n              \t// 项目支持 async/await等高级语法\n              ],\n              ['transform-react-remove-prop-types']\n              // 生产环境删除 prop=types\n            ]\n          }\n        },\n        exclude: /node_modules/ // 不需要打包的文件夹\n      }, {\n        test: /\\.less$/,\n        use: [\n          {\n            loader: 'style-loader'\n          }, {\n            loader: 'css-loader'\n          }, {\n            loader: 'less-loader'\n          }\n        ]\n      }, {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 8192,\n              name: 'assets/images/[hash:8].[name].[ext]'\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [new HTMLWebpackPlugin({template: 'index.html', filename: 'index.html', inject: 'body'})],\n  resolve: {\n    alias: {\n      Common: path.join(__dirname, '..', 'src/components/common/'),\n      Pages: path.join(__dirname, '..', 'src/pages/'),\n      Styles: path.join(__dirname, '..', 'src/assets/style'),\n      Component: path.join(__dirname, '..', 'src/components/'),\n      CommonActions: path.join(__dirname, '..', 'src/actions/commonActions'),\n      CommonReducers: path.join(__dirname, '..', 'src/reducers/commonReducers'),\n      Images: path.join(__dirname, '..', 'src/assets/image'),\n      Datas: path.join(__dirname, '..', 'src/assets/data')\n    }\n  }\n}\n```\n \n\n--\n#### `webpack.dev.js` 文件\n\n使用 `webpack-merge` 合并 `webpack.base.js`\n\n#### loader\n\n处理 css 文件 (因为已经采用了 `less` 作为 `css` 样式处理), 此 `loader` 可以省略\n\n#### devtool\n\n>`devtool: \"inline-source-map\"`\n>\n>生成一个 DataUrl 形式的 SourceMap 文件.\n\n#### devServer\n\n```\ndevServer: {\n    hot: true,  // 热处理\n    inline: true,\n    proxy: { // 跨域代理\n      '/api': {\n        target: 'https://example.com/',\n        changeOrigin: true,\n        pathRewrite: {'^/api': ''}\n      }\n    }\n  }\n```\n\n#### plugins\n\n`NamedModulesPlugin` `HotModuleReplacementPlugin` 协助处理文件热更新\n\n#### 代码\n\n```js\nconst merge = require(\"webpack-merge\");\nconst base = require(\"./webpack.base\");\nconst webpack = require(\"webpack\");\n\nmodule.exports = merge(base, {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          \"style-loader\", \"css-loader\"\n        ],\n        exclude: /node_modules/\n      }\n    ]\n  },\n  devtool: \"inline-source-map\",\n  devServer: {\n    hot: true,\n    inline: true,\n    proxy: {\n      '/api': {\n        target: 'https://exmaple.com/',\n        changeOrigin: true,\n        pathRewrite: {'^/api': ''}\n      }\n    }\n  },\n  plugins: [\n    new webpack.NamedModulesPlugin(),\n    new webpack.HotModuleReplacementPlugin()\n  ]\n})\n```\n\n--\n#### `webpack.prod.js` 文件\n\n#### devtool\n\n>`source-map` \n>\n>解决开发代码与实际运行代码不一致时，帮助我们 debug 到原始开发代码\n\n#### loader\n\n> 把 css 样式为 .html 中的 style\n> \n> `extract-text-webpack-plugin`\n> \n\n#### plugins\n`extract-text-webpack-plugin` 处理 `css` 样式为 `style`\n\n`clean-webpack-plugin` 删除 `dist` 文件夹\n\n`webpack.optimize.CommonsChunkPlugin` 提取项目中的公共代码部分到 `common.js`中\n\n`webpack.DllReferencePlugin` 将第三方插件/库与项目中的代码分开打包，提升打包效率\n\n`uglifyjs-webpack-plugin` 丑化/压缩打包后的代码\n\n#### 代码\n\n```js\nconst merge = require(\"webpack-merge\");\nconst base = require(\"./webpack.base\");\nconst ExtractTextWebpackPlugin = require(\"extract-text-webpack-plugin\");\nconst CleanWebpackPlugin = require(\"clean-webpack-plugin\");\nconst UglifyjsWebpackPlugin = require(\"uglifyjs-webpack-plugin\");\nconst webpack = require(\"webpack\");\nconst path = require(\"path\");\n\nmodule.exports = merge(base, {\n  // entry: {\n  //  vendor: [\"react\",\"react-dom\"]\n  // },\n  dependencies: [\"./lib/vendor.js\"],\n  devtool: \"source-map\",\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ExtractTextWebpackPlugin.extract({fallback: \"style-loader\", use: \"css-loader\"}),\n        exclude: /node_moudles/\n      }\n    ]\n  },\n  plugins: [\n    new ExtractTextWebpackPlugin(\"styles.css\"),\n    new CleanWebpackPlugin([\"dist\"]),\n    // new UglifyjsWebpackPlugin({sourceMap: false}),\n    new webpack\n      .optimize\n      .CommonsChunkPlugin({name: \"common\", filename: \"common.js\"}),\n    // new webpack\n    //   .optimize\n    //   .CommonsChunkPlugin({\n    //     name: [\"vendor\",\"common\"],\n    //     // filename: \"vendor.js\" (给 chunk 一个不同的名字)\n    //     minChunks: Infinity,\n    //     // (随着 entry chunk 越来越多， 这个配置保证没其它的模块会打包进 vendor chunk)\n    //   })\n    new webpack.DllReferencePlugin({\n      manifest: path.resolve(__dirname, \"../lib/manifest.json\")\n    })\n  ]\n});\n\n```\n\n--\n#### `webpack.dll.js` 文件\n\n#### entry\n\n需要抽离出来的第三方库\n\n`react` `react-dom` `react-router-dom` `redux` `react-redux`\n\n#### output\n\n抽离出来的文件出口配置,放到 `/lib/vendor.js`\n\n#### plugins\n\n`webpack.DllPlugin` 将第三方库抽离出来并打包\n\n`uglifyjs-webpack-plugin` 丑化/压缩代码\n\n#### 代码\n```js\nconst webpack = require(\"webpack\");\nconst path = require(\"path\");\nconst UglifyjsWebpackPlugin = require(\"uglifyjs-webpack-plugin\");\n\nmodule.exports = {\n  entry: [\n    \"react\",\n    \"react-dom\",\n    \"react-router-dom\",\n    \"redux\",\n    \"react-redux\"\n    /** ... 等其他依赖库 */\n  ],\n  output: {\n    path: path.resolve(\"lib\"),\n    filename: \"vendor.js\",\n    library: \"vendor_[hash]\"\n  },\n  plugins: [\n    new webpack.DllPlugin({\n      name: \"vendor_[hash]\",\n      path: path.resolve(\"lib/manifest.json\")\n    }),\n    new UglifyjsWebpackPlugin()\n  ]\n}\n```\n\n","slug":"实战项目总结一 (to8to项目基础配置)","published":1,"updated":"2018-03-18T16:16:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoi5wzzr000hf7kr47sktzr3","content":"<h1 id=\"实战项目总结一-to8to项目基础配置\"><a href=\"#实战项目总结一-to8to项目基础配置\" class=\"headerlink\" title=\"实战项目总结一 (to8to项目基础配置)\"></a>实战项目总结一 (to8to项目基础配置)</h1><h2 id=\"webpack-的配置-3-11-0\"><a href=\"#webpack-的配置-3-11-0\" class=\"headerlink\" title=\"webpack 的配置 (@3.11.0)\"></a><code>webpack</code> 的配置 (@3.11.0)</h2><h4 id=\"webpack-base-js-文件\"><a href=\"#webpack-base-js-文件\" class=\"headerlink\" title=\"webpack.base.js 文件\"></a><code>webpack.base.js</code> 文件</h4><h4 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h4><blockquote>\n<p><code>eslint</code> 代码格式规范: <code>eslint-loader</code> </p>\n<p><code>js</code> 处理 js 文件，可以使用 ES6 等高级语法: <code>babel-loader</code></p>\n<p>开发和生产环境都使用了 <code>less</code>: <code>style-loader,css-loader,less-loader</code></p>\n<p> 图片处理: <code>url-loader</code></p>\n</blockquote>\n<h4 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h4><blockquote>\n<p><code>HTMLWebpackPlugin</code> 打包后的 <code>js</code> 文件放入到指定 <code>.html</code> 文件中 </p>\n</blockquote>\n<h4 id=\"项目路径别名-alias\"><a href=\"#项目路径别名-alias\" class=\"headerlink\" title=\"项目路径别名 (alias)\"></a>项目路径别名 (alias)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Common: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/components/common/'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><code>webpack.base.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> HTMLWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并路径方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"function\">(<span class=\"params\">dir</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> path.join(__dirname, <span class=\"string\">'..'</span>, dir)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    bundle: path.join(__dirname, <span class=\"string\">'../src/index.js'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(<span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].[hash:7].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        exclude: [</span><br><span class=\"line\">          /node_modules/, /build/, resolve(<span class=\"string\">'src/router/'</span>)</span><br><span class=\"line\">        ], <span class=\"comment\">// 不需要规范代码的文件夹</span></span><br><span class=\"line\">        loader: <span class=\"string\">'eslint-loader'</span>,</span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>, <span class=\"comment\">// 编译之前</span></span><br><span class=\"line\">        include: [</span><br><span class=\"line\">          resolve(<span class=\"string\">'src'</span>), resolve(<span class=\"string\">'test'</span>) <span class=\"comment\">// 需要规范代码的文件夹</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          formatter: <span class=\"built_in\">require</span>(<span class=\"string\">'eslint-friendly-formatter'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            presets: [</span><br><span class=\"line\">              <span class=\"string\">'@babel/preset-env'</span>, <span class=\"string\">'@babel/preset-react'</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">'plugins'</span>: [</span><br><span class=\"line\">              [</span><br><span class=\"line\">                <span class=\"string\">'import'</span>, &#123;</span><br><span class=\"line\">                  <span class=\"string\">'libraryName'</span>: <span class=\"string\">'antd'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'libraryDirectory'</span>: <span class=\"string\">'es'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'style'</span>: <span class=\"string\">'true'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 按需加载 antd</span></span><br><span class=\"line\">              ],</span><br><span class=\"line\">              [<span class=\"string\">'@babel/plugin-transform-runtime'</span>, &#123;</span><br><span class=\"line\">                <span class=\"string\">'helpers'</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                <span class=\"string\">'polyfill'</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                <span class=\"string\">'regenerator'</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                <span class=\"string\">'moduleName'</span>: <span class=\"string\">'@babel/runtime'</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              \t<span class=\"comment\">// 项目支持 async/await等高级语法</span></span><br><span class=\"line\">              ],</span><br><span class=\"line\">              [<span class=\"string\">'transform-react-remove-prop-types'</span>]</span><br><span class=\"line\">              <span class=\"comment\">// 生产环境删除 prop=types</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span> <span class=\"comment\">// 不需要打包的文件夹</span></span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'style-loader'</span></span><br><span class=\"line\">          &#125;, &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'css-loader'</span></span><br><span class=\"line\">          &#125;, &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'less-loader'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              limit: <span class=\"number\">8192</span>,</span><br><span class=\"line\">              name: <span class=\"string\">'assets/images/[hash:8].[name].[ext]'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [<span class=\"keyword\">new</span> HTMLWebpackPlugin(&#123;<span class=\"attr\">template</span>: <span class=\"string\">'index.html'</span>, <span class=\"attr\">filename</span>: <span class=\"string\">'index.html'</span>, <span class=\"attr\">inject</span>: <span class=\"string\">'body'</span>&#125;)],</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      Common: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/components/common/'</span>),</span><br><span class=\"line\">      Pages: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/pages/'</span>),</span><br><span class=\"line\">      Styles: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/assets/style'</span>),</span><br><span class=\"line\">      Component: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/components/'</span>),</span><br><span class=\"line\">      CommonActions: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/actions/commonActions'</span>),</span><br><span class=\"line\">      CommonReducers: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/reducers/commonReducers'</span>),</span><br><span class=\"line\">      Images: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/assets/image'</span>),</span><br><span class=\"line\">      Datas: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/assets/data'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>–</p>\n<h4 id=\"webpack-dev-js-文件\"><a href=\"#webpack-dev-js-文件\" class=\"headerlink\" title=\"webpack.dev.js 文件\"></a><code>webpack.dev.js</code> 文件</h4><p>使用 <code>webpack-merge</code> 合并 <code>webpack.base.js</code></p>\n<h4 id=\"loader-1\"><a href=\"#loader-1\" class=\"headerlink\" title=\"loader\"></a>loader</h4><p>处理 css 文件 (因为已经采用了 <code>less</code> 作为 <code>css</code> 样式处理), 此 <code>loader</code> 可以省略</p>\n<h4 id=\"devtool\"><a href=\"#devtool\" class=\"headerlink\" title=\"devtool\"></a>devtool</h4><blockquote>\n<p><code>devtool: &quot;inline-source-map&quot;</code></p>\n<p>生成一个 DataUrl 形式的 SourceMap 文件.</p>\n</blockquote>\n<h4 id=\"devServer\"><a href=\"#devServer\" class=\"headerlink\" title=\"devServer\"></a>devServer</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    hot: true,  // 热处理</span><br><span class=\"line\">    inline: true,</span><br><span class=\"line\">    proxy: &#123; // 跨域代理</span><br><span class=\"line\">      &apos;/api&apos;: &#123;</span><br><span class=\"line\">        target: &apos;https://example.com/&apos;,</span><br><span class=\"line\">        changeOrigin: true,</span><br><span class=\"line\">        pathRewrite: &#123;&apos;^/api&apos;: &apos;&apos;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"plugins-1\"><a href=\"#plugins-1\" class=\"headerlink\" title=\"plugins\"></a>plugins</h4><p><code>NamedModulesPlugin</code> <code>HotModuleReplacementPlugin</code> 协助处理文件热更新</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-merge\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> base = <span class=\"built_in\">require</span>(<span class=\"string\">\"./webpack.base\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(base, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">\"style-loader\"</span>, <span class=\"string\">\"css-loader\"</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devtool: <span class=\"string\">\"inline-source-map\"</span>,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    inline: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      <span class=\"string\">'/api'</span>: &#123;</span><br><span class=\"line\">        target: <span class=\"string\">'https://exmaple.com/'</span>,</span><br><span class=\"line\">        changeOrigin: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        pathRewrite: &#123;<span class=\"string\">'^/api'</span>: <span class=\"string\">''</span>&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NamedModulesPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>–</p>\n<h4 id=\"webpack-prod-js-文件\"><a href=\"#webpack-prod-js-文件\" class=\"headerlink\" title=\"webpack.prod.js 文件\"></a><code>webpack.prod.js</code> 文件</h4><h4 id=\"devtool-1\"><a href=\"#devtool-1\" class=\"headerlink\" title=\"devtool\"></a>devtool</h4><blockquote>\n<p><code>source-map</code> </p>\n<p>解决开发代码与实际运行代码不一致时，帮助我们 debug 到原始开发代码</p>\n</blockquote>\n<h4 id=\"loader-2\"><a href=\"#loader-2\" class=\"headerlink\" title=\"loader\"></a>loader</h4><blockquote>\n<p>把 css 样式为 .html 中的 style</p>\n<p><code>extract-text-webpack-plugin</code></p>\n</blockquote>\n<h4 id=\"plugins-2\"><a href=\"#plugins-2\" class=\"headerlink\" title=\"plugins\"></a>plugins</h4><p><code>extract-text-webpack-plugin</code> 处理 <code>css</code> 样式为 <code>style</code></p>\n<p><code>clean-webpack-plugin</code> 删除 <code>dist</code> 文件夹</p>\n<p><code>webpack.optimize.CommonsChunkPlugin</code> 提取项目中的公共代码部分到 <code>common.js</code>中</p>\n<p><code>webpack.DllReferencePlugin</code> 将第三方插件/库与项目中的代码分开打包，提升打包效率</p>\n<p><code>uglifyjs-webpack-plugin</code> 丑化/压缩打包后的代码</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-merge\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> base = <span class=\"built_in\">require</span>(<span class=\"string\">\"./webpack.base\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"extract-text-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CleanWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"clean-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyjsWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"uglifyjs-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(base, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// entry: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  vendor: [\"react\",\"react-dom\"]</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;,</span></span><br><span class=\"line\">  dependencies: [<span class=\"string\">\"./lib/vendor.js\"</span>],</span><br><span class=\"line\">  devtool: <span class=\"string\">\"source-map\"</span>,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: ExtractTextWebpackPlugin.extract(&#123;<span class=\"attr\">fallback</span>: <span class=\"string\">\"style-loader\"</span>, <span class=\"attr\">use</span>: <span class=\"string\">\"css-loader\"</span>&#125;),</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_moudles/</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextWebpackPlugin(<span class=\"string\">\"styles.css\"</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CleanWebpackPlugin([<span class=\"string\">\"dist\"</span>]),</span><br><span class=\"line\">    <span class=\"comment\">// new UglifyjsWebpackPlugin(&#123;sourceMap: false&#125;),</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack</span><br><span class=\"line\">      .optimize</span><br><span class=\"line\">      .CommonsChunkPlugin(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"common\"</span>, <span class=\"attr\">filename</span>: <span class=\"string\">\"common.js\"</span>&#125;),</span><br><span class=\"line\">    <span class=\"comment\">// new webpack</span></span><br><span class=\"line\">    <span class=\"comment\">//   .optimize</span></span><br><span class=\"line\">    <span class=\"comment\">//   .CommonsChunkPlugin(&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     name: [\"vendor\",\"common\"],</span></span><br><span class=\"line\">    <span class=\"comment\">//     // filename: \"vendor.js\" (给 chunk 一个不同的名字)</span></span><br><span class=\"line\">    <span class=\"comment\">//     minChunks: Infinity,</span></span><br><span class=\"line\">    <span class=\"comment\">//     // (随着 entry chunk 越来越多， 这个配置保证没其它的模块会打包进 vendor chunk)</span></span><br><span class=\"line\">    <span class=\"comment\">//   &#125;)</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">      manifest: path.resolve(__dirname, <span class=\"string\">\"../lib/manifest.json\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>–</p>\n<h4 id=\"webpack-dll-js-文件\"><a href=\"#webpack-dll-js-文件\" class=\"headerlink\" title=\"webpack.dll.js 文件\"></a><code>webpack.dll.js</code> 文件</h4><h4 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h4><p>需要抽离出来的第三方库</p>\n<p><code>react</code> <code>react-dom</code> <code>react-router-dom</code> <code>redux</code> <code>react-redux</code></p>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h4><p>抽离出来的文件出口配置,放到 <code>/lib/vendor.js</code></p>\n<h4 id=\"plugins-3\"><a href=\"#plugins-3\" class=\"headerlink\" title=\"plugins\"></a>plugins</h4><p><code>webpack.DllPlugin</code> 将第三方库抽离出来并打包</p>\n<p><code>uglifyjs-webpack-plugin</code> 丑化/压缩代码</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyjsWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"uglifyjs-webpack-plugin\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: [</span><br><span class=\"line\">    <span class=\"string\">\"react\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-dom\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-router-dom\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"redux\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-redux\"</span></span><br><span class=\"line\">    <span class=\"comment\">/** ... 等其他依赖库 */</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(<span class=\"string\">\"lib\"</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">\"vendor.js\"</span>,</span><br><span class=\"line\">    library: <span class=\"string\">\"vendor_[hash]\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DllPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">\"vendor_[hash]\"</span>,</span><br><span class=\"line\">      path: path.resolve(<span class=\"string\">\"lib/manifest.json\"</span>)</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> UglifyjsWebpackPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"实战项目总结一-to8to项目基础配置\"><a href=\"#实战项目总结一-to8to项目基础配置\" class=\"headerlink\" title=\"实战项目总结一 (to8to项目基础配置)\"></a>实战项目总结一 (to8to项目基础配置)</h1><h2 id=\"webpack-的配置-3-11-0\"><a href=\"#webpack-的配置-3-11-0\" class=\"headerlink\" title=\"webpack 的配置 (@3.11.0)\"></a><code>webpack</code> 的配置 (@3.11.0)</h2><h4 id=\"webpack-base-js-文件\"><a href=\"#webpack-base-js-文件\" class=\"headerlink\" title=\"webpack.base.js 文件\"></a><code>webpack.base.js</code> 文件</h4><h4 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h4><blockquote>\n<p><code>eslint</code> 代码格式规范: <code>eslint-loader</code> </p>\n<p><code>js</code> 处理 js 文件，可以使用 ES6 等高级语法: <code>babel-loader</code></p>\n<p>开发和生产环境都使用了 <code>less</code>: <code>style-loader,css-loader,less-loader</code></p>\n<p> 图片处理: <code>url-loader</code></p>\n</blockquote>\n<h4 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h4><blockquote>\n<p><code>HTMLWebpackPlugin</code> 打包后的 <code>js</code> 文件放入到指定 <code>.html</code> 文件中 </p>\n</blockquote>\n<h4 id=\"项目路径别名-alias\"><a href=\"#项目路径别名-alias\" class=\"headerlink\" title=\"项目路径别名 (alias)\"></a>项目路径别名 (alias)</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Common: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/components/common/'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><code>webpack.base.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> HTMLWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并路径方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"function\">(<span class=\"params\">dir</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> path.join(__dirname, <span class=\"string\">'..'</span>, dir)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    bundle: path.join(__dirname, <span class=\"string\">'../src/index.js'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(<span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].[hash:7].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        exclude: [</span><br><span class=\"line\">          /node_modules/, /build/, resolve(<span class=\"string\">'src/router/'</span>)</span><br><span class=\"line\">        ], <span class=\"comment\">// 不需要规范代码的文件夹</span></span><br><span class=\"line\">        loader: <span class=\"string\">'eslint-loader'</span>,</span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>, <span class=\"comment\">// 编译之前</span></span><br><span class=\"line\">        include: [</span><br><span class=\"line\">          resolve(<span class=\"string\">'src'</span>), resolve(<span class=\"string\">'test'</span>) <span class=\"comment\">// 需要规范代码的文件夹</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          formatter: <span class=\"built_in\">require</span>(<span class=\"string\">'eslint-friendly-formatter'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            presets: [</span><br><span class=\"line\">              <span class=\"string\">'@babel/preset-env'</span>, <span class=\"string\">'@babel/preset-react'</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">'plugins'</span>: [</span><br><span class=\"line\">              [</span><br><span class=\"line\">                <span class=\"string\">'import'</span>, &#123;</span><br><span class=\"line\">                  <span class=\"string\">'libraryName'</span>: <span class=\"string\">'antd'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'libraryDirectory'</span>: <span class=\"string\">'es'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'style'</span>: <span class=\"string\">'true'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 按需加载 antd</span></span><br><span class=\"line\">              ],</span><br><span class=\"line\">              [<span class=\"string\">'@babel/plugin-transform-runtime'</span>, &#123;</span><br><span class=\"line\">                <span class=\"string\">'helpers'</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                <span class=\"string\">'polyfill'</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                <span class=\"string\">'regenerator'</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                <span class=\"string\">'moduleName'</span>: <span class=\"string\">'@babel/runtime'</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              \t<span class=\"comment\">// 项目支持 async/await等高级语法</span></span><br><span class=\"line\">              ],</span><br><span class=\"line\">              [<span class=\"string\">'transform-react-remove-prop-types'</span>]</span><br><span class=\"line\">              <span class=\"comment\">// 生产环境删除 prop=types</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span> <span class=\"comment\">// 不需要打包的文件夹</span></span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'style-loader'</span></span><br><span class=\"line\">          &#125;, &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'css-loader'</span></span><br><span class=\"line\">          &#125;, &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'less-loader'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              limit: <span class=\"number\">8192</span>,</span><br><span class=\"line\">              name: <span class=\"string\">'assets/images/[hash:8].[name].[ext]'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [<span class=\"keyword\">new</span> HTMLWebpackPlugin(&#123;<span class=\"attr\">template</span>: <span class=\"string\">'index.html'</span>, <span class=\"attr\">filename</span>: <span class=\"string\">'index.html'</span>, <span class=\"attr\">inject</span>: <span class=\"string\">'body'</span>&#125;)],</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      Common: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/components/common/'</span>),</span><br><span class=\"line\">      Pages: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/pages/'</span>),</span><br><span class=\"line\">      Styles: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/assets/style'</span>),</span><br><span class=\"line\">      Component: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/components/'</span>),</span><br><span class=\"line\">      CommonActions: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/actions/commonActions'</span>),</span><br><span class=\"line\">      CommonReducers: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/reducers/commonReducers'</span>),</span><br><span class=\"line\">      Images: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/assets/image'</span>),</span><br><span class=\"line\">      Datas: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">'src/assets/data'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>–</p>\n<h4 id=\"webpack-dev-js-文件\"><a href=\"#webpack-dev-js-文件\" class=\"headerlink\" title=\"webpack.dev.js 文件\"></a><code>webpack.dev.js</code> 文件</h4><p>使用 <code>webpack-merge</code> 合并 <code>webpack.base.js</code></p>\n<h4 id=\"loader-1\"><a href=\"#loader-1\" class=\"headerlink\" title=\"loader\"></a>loader</h4><p>处理 css 文件 (因为已经采用了 <code>less</code> 作为 <code>css</code> 样式处理), 此 <code>loader</code> 可以省略</p>\n<h4 id=\"devtool\"><a href=\"#devtool\" class=\"headerlink\" title=\"devtool\"></a>devtool</h4><blockquote>\n<p><code>devtool: &quot;inline-source-map&quot;</code></p>\n<p>生成一个 DataUrl 形式的 SourceMap 文件.</p>\n</blockquote>\n<h4 id=\"devServer\"><a href=\"#devServer\" class=\"headerlink\" title=\"devServer\"></a>devServer</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    hot: true,  // 热处理</span><br><span class=\"line\">    inline: true,</span><br><span class=\"line\">    proxy: &#123; // 跨域代理</span><br><span class=\"line\">      &apos;/api&apos;: &#123;</span><br><span class=\"line\">        target: &apos;https://example.com/&apos;,</span><br><span class=\"line\">        changeOrigin: true,</span><br><span class=\"line\">        pathRewrite: &#123;&apos;^/api&apos;: &apos;&apos;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"plugins-1\"><a href=\"#plugins-1\" class=\"headerlink\" title=\"plugins\"></a>plugins</h4><p><code>NamedModulesPlugin</code> <code>HotModuleReplacementPlugin</code> 协助处理文件热更新</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-merge\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> base = <span class=\"built_in\">require</span>(<span class=\"string\">\"./webpack.base\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(base, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">\"style-loader\"</span>, <span class=\"string\">\"css-loader\"</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devtool: <span class=\"string\">\"inline-source-map\"</span>,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    inline: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      <span class=\"string\">'/api'</span>: &#123;</span><br><span class=\"line\">        target: <span class=\"string\">'https://exmaple.com/'</span>,</span><br><span class=\"line\">        changeOrigin: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        pathRewrite: &#123;<span class=\"string\">'^/api'</span>: <span class=\"string\">''</span>&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NamedModulesPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>–</p>\n<h4 id=\"webpack-prod-js-文件\"><a href=\"#webpack-prod-js-文件\" class=\"headerlink\" title=\"webpack.prod.js 文件\"></a><code>webpack.prod.js</code> 文件</h4><h4 id=\"devtool-1\"><a href=\"#devtool-1\" class=\"headerlink\" title=\"devtool\"></a>devtool</h4><blockquote>\n<p><code>source-map</code> </p>\n<p>解决开发代码与实际运行代码不一致时，帮助我们 debug 到原始开发代码</p>\n</blockquote>\n<h4 id=\"loader-2\"><a href=\"#loader-2\" class=\"headerlink\" title=\"loader\"></a>loader</h4><blockquote>\n<p>把 css 样式为 .html 中的 style</p>\n<p><code>extract-text-webpack-plugin</code></p>\n</blockquote>\n<h4 id=\"plugins-2\"><a href=\"#plugins-2\" class=\"headerlink\" title=\"plugins\"></a>plugins</h4><p><code>extract-text-webpack-plugin</code> 处理 <code>css</code> 样式为 <code>style</code></p>\n<p><code>clean-webpack-plugin</code> 删除 <code>dist</code> 文件夹</p>\n<p><code>webpack.optimize.CommonsChunkPlugin</code> 提取项目中的公共代码部分到 <code>common.js</code>中</p>\n<p><code>webpack.DllReferencePlugin</code> 将第三方插件/库与项目中的代码分开打包，提升打包效率</p>\n<p><code>uglifyjs-webpack-plugin</code> 丑化/压缩打包后的代码</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-merge\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> base = <span class=\"built_in\">require</span>(<span class=\"string\">\"./webpack.base\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"extract-text-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CleanWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"clean-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyjsWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"uglifyjs-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(base, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// entry: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  vendor: [\"react\",\"react-dom\"]</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;,</span></span><br><span class=\"line\">  dependencies: [<span class=\"string\">\"./lib/vendor.js\"</span>],</span><br><span class=\"line\">  devtool: <span class=\"string\">\"source-map\"</span>,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: ExtractTextWebpackPlugin.extract(&#123;<span class=\"attr\">fallback</span>: <span class=\"string\">\"style-loader\"</span>, <span class=\"attr\">use</span>: <span class=\"string\">\"css-loader\"</span>&#125;),</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_moudles/</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextWebpackPlugin(<span class=\"string\">\"styles.css\"</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CleanWebpackPlugin([<span class=\"string\">\"dist\"</span>]),</span><br><span class=\"line\">    <span class=\"comment\">// new UglifyjsWebpackPlugin(&#123;sourceMap: false&#125;),</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack</span><br><span class=\"line\">      .optimize</span><br><span class=\"line\">      .CommonsChunkPlugin(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"common\"</span>, <span class=\"attr\">filename</span>: <span class=\"string\">\"common.js\"</span>&#125;),</span><br><span class=\"line\">    <span class=\"comment\">// new webpack</span></span><br><span class=\"line\">    <span class=\"comment\">//   .optimize</span></span><br><span class=\"line\">    <span class=\"comment\">//   .CommonsChunkPlugin(&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     name: [\"vendor\",\"common\"],</span></span><br><span class=\"line\">    <span class=\"comment\">//     // filename: \"vendor.js\" (给 chunk 一个不同的名字)</span></span><br><span class=\"line\">    <span class=\"comment\">//     minChunks: Infinity,</span></span><br><span class=\"line\">    <span class=\"comment\">//     // (随着 entry chunk 越来越多， 这个配置保证没其它的模块会打包进 vendor chunk)</span></span><br><span class=\"line\">    <span class=\"comment\">//   &#125;)</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">      manifest: path.resolve(__dirname, <span class=\"string\">\"../lib/manifest.json\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>–</p>\n<h4 id=\"webpack-dll-js-文件\"><a href=\"#webpack-dll-js-文件\" class=\"headerlink\" title=\"webpack.dll.js 文件\"></a><code>webpack.dll.js</code> 文件</h4><h4 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h4><p>需要抽离出来的第三方库</p>\n<p><code>react</code> <code>react-dom</code> <code>react-router-dom</code> <code>redux</code> <code>react-redux</code></p>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h4><p>抽离出来的文件出口配置,放到 <code>/lib/vendor.js</code></p>\n<h4 id=\"plugins-3\"><a href=\"#plugins-3\" class=\"headerlink\" title=\"plugins\"></a>plugins</h4><p><code>webpack.DllPlugin</code> 将第三方库抽离出来并打包</p>\n<p><code>uglifyjs-webpack-plugin</code> 丑化/压缩代码</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyjsWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"uglifyjs-webpack-plugin\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: [</span><br><span class=\"line\">    <span class=\"string\">\"react\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-dom\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-router-dom\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"redux\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-redux\"</span></span><br><span class=\"line\">    <span class=\"comment\">/** ... 等其他依赖库 */</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(<span class=\"string\">\"lib\"</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">\"vendor.js\"</span>,</span><br><span class=\"line\">    library: <span class=\"string\">\"vendor_[hash]\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DllPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">\"vendor_[hash]\"</span>,</span><br><span class=\"line\">      path: path.resolve(<span class=\"string\">\"lib/manifest.json\"</span>)</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> UglifyjsWebpackPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjoi5wzz50002f7kr0eq9xp7h","category_id":"cjoi5wzz90004f7krqzddqzjd","_id":"cjoi5wzzp000ef7krow16dkff"},{"post_id":"cjoi5wzz70003f7kr4zqm9abb","category_id":"cjoi5wzz90004f7krqzddqzjd","_id":"cjoi5wzzt000jf7kr30dwrpva"},{"post_id":"cjoi5wzzn000df7kr3ozgmxar","category_id":"cjoi5wzzs000if7kriswnte25","_id":"cjoi5wzzv000pf7krhudazxzm"},{"post_id":"cjoi5wzzr000hf7kr47sktzr3","category_id":"cjoi5wzzu000mf7kr8712wn7w","_id":"cjoi5wzzw000rf7kr3orjk7hb"}],"PostTag":[{"post_id":"cjoi5wzz50002f7kr0eq9xp7h","tag_id":"cjoi5wzzc0005f7krcke5tii1","_id":"cjoi5wzzj000bf7kru2l0qyqr"},{"post_id":"cjoi5wzz70003f7kr4zqm9abb","tag_id":"cjoi5wzzc0005f7krcke5tii1","_id":"cjoi5wzzq000gf7kr75brdc0h"},{"post_id":"cjoi5wzzf0008f7kryci7yyoo","tag_id":"cjoi5wzzp000ff7krsm9it00b","_id":"cjoi5wzzt000lf7kryy5yqh7h"},{"post_id":"cjoi5wzzn000df7kr3ozgmxar","tag_id":"cjoi5wzzt000kf7kr0l911b4l","_id":"cjoi5wzzu000of7kro4nfyq8e"},{"post_id":"cjoi5wzzr000hf7kr47sktzr3","tag_id":"cjoi5wzzu000nf7krsec7k29j","_id":"cjoi5wzzv000qf7krq7tk5kdy"}],"Tag":[{"name":"React","_id":"cjoi5wzzc0005f7krcke5tii1"},{"name":"svn","_id":"cjoi5wzzp000ff7krsm9it00b"},{"name":"puppeteer","_id":"cjoi5wzzt000kf7kr0l911b4l"},{"name":"技术总结 webpack to8to react","_id":"cjoi5wzzu000nf7krsec7k29j"}]}}